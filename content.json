{"pages":[{"title":"友情链接","text":"","link":"/link/index.html"},{"title":"我的分类页","text":"","link":"/categories/index.html"},{"title":"我的标签页","text":"","link":"/tags/index.html"}],"posts":[{"title":"禁止用户调试网站","text":"禁止用户调试网站 web想禁止调试，没有绝对安全的方式 妙用1 debugger示例用setInterval执行debugger，打开控制台就会暂停代码 12345678(() =&gt; { function ban() { setInterval(() =&gt; { debugger; }, 50); } ban();})(); 妙用2 debugger示例效果：打开控制台就进入debugger，如果还像 妙用1 的破解之法解决，浏览器会被卡死 12345678910111213141516(() =&gt; { let timeLimit = 50; setInterval(loop, 1); function loop() { let startTime = new Date(); debugger; if (new Date() - startTime &gt; timeLimit) { window.stop(); let total = ''; for (let i = 0; i &lt; 1000000; i++) { total = total + i.toString(); history.pushState(0, 0, total); } } }})(); 分析下面这一段是导致浏览器卡死的罪魁祸首 12345let total = '';for (let i = 0; i &lt; 1000000; i++) { total = total + i.toString(); history.pushState(0, 0, total);} 但是默认应该就会执行，为什么打开控制台才进入这一段呢？答案就在这一段 12345let startTime = new Date();debugger;if (new Date() - startTime &gt; timeLimit) { // ...} 只有进入debugger的情况下，new Date()才会比startTime（上一次的时间）大50ms 也可以这样操作：跳转至空页面 123if (new Date() - startTime &gt; timeLimit) { window.location.href = 'about:blank';} 还有很多方式，只要避免能调试当前页面即可 第三方库：disable-devtool https://github.com/theajack/disable-devtool：**0.3.7** 使用方式12345&lt;script disable-devtool-auto src='https://cdn.jsdelivr.net/npm/disable-devtool' stopIntervalTime=&quot;false&quot;&gt;&lt;/script&gt; 配置含义123456789101112131415161718192021222324252627282930313233interface IConfig { md5?: string; // 绕过禁用的md5值，用于线上，默认不启用绕过禁用 url?: string; // 关闭页面失败时的跳转页面，默认值为localhost tkName?: string; // 绕过禁用时的url参数名称，默认为 ddtk ondevtoolopen?(type: DetectorType, next: Function): void; // 开发者面板打开的回调，启用时url参数无效，type 为监测模式，详见3.5， next函数是关闭当前窗口 ondevtoolclose?(): void; // 开发者面板关闭的回调 interval?: number; // 定时器的时间间隔 默认200ms disableMenu?: boolean; // 是否禁用右键菜单 默认为true stopIntervalTime?: number; // 在移动端时取消监视的等待时长 clearIntervalWhenDevOpenTrigger?: boolean; // 是否在触发之后停止监控 默认为false， 在使用ondevtoolclose时该参数无效 detectors?: Array&lt;DetectorType&gt;; // 启用的检测器 检测器详情见 3.5 默认为全部，建议使用全部 clearLog?: boolean; // 是否每次都清除log disableSelect?: boolean; // 是否禁用选择文本 默认为false disableCopy?: boolean; // 是否禁用复制 默认为false disableCut?: boolean; // 是否禁用剪切 默认为false disablePaste: boolean; // 是否禁用粘贴 默认为false ignore?: (string|RegExp)[] | null | (()=&gt;boolean); // 某些情况忽略禁用 disableIframeParents?: boolean; // iframe中是否禁用所有父窗口 timeOutUrl?: string; // 关闭页面超时跳转的url; rewriteHTML: string; // 检测到打开之后重写页面}enum DetectorType { Unknown = -1, RegToString = 0, // 根据正则检测 DefineId, // 根据dom id检测 Size, // 根据窗口尺寸检测 DateToString, // 根据Date.toString 检测 FuncToString, // 根据Function.toString 检测 Debugger, // 根据断点检测，仅在ios chrome 真机情况下有效 Performance, // 根据log大数据性能检测 DebugLib, // 检测第三方调试工具 eruda 和 vconsole }; 关键源码禁用快捷键12345678910111213141516171819202122232425262728293031323334353637const KEY = {J: 74, I: 73, U: 85, S: 83, F12: 123};// 禁用 ctrl + shift + i/jconst isOpenDevToolKey = IS.macos ? ((e: KeyboardEvent, code: number) =&gt; (e.metaKey &amp;&amp; e.altKey &amp;&amp; (code === KEY.I || code === KEY.J))) : ((e: KeyboardEvent, code: number) =&gt; (e.ctrlKey &amp;&amp; e.shiftKey &amp;&amp; (code === KEY.I || code === KEY.J)));const isViewSourceCodeKey = IS.macos ? ((e: KeyboardEvent, code: number) =&gt; (e.metaKey &amp;&amp; e.altKey &amp;&amp; code === KEY.U) || (e.metaKey &amp;&amp; code === KEY.S)) : ((e: KeyboardEvent, code: number) =&gt; (e.ctrlKey &amp;&amp; (code === KEY.S || code === KEY.U)));target.addEventListener('keydown', (e) =&gt; {e = e || target.event;const keyCode = e.keyCode || e.which;if ( keyCode === KEY.F12 || // 禁用f12 isOpenDevToolKey(e, keyCode) || // 禁用 ctrl + shift + i isViewSourceCodeKey(e, keyCode) // 禁用 ctrl + u 和 ctrl + s 查看和保存源码) { return preventEvent(target, e);}}, true);target.addEventListener('contextmenu', (e: Event &amp; {pointerType: string}) =&gt; { if (e.pointerType === 'touch') return; return preventEvent(target, e);});addPreventListener(target, 'selectstart');addPreventListener(target, 'copy');addPreventListener(target, 'cut');addPreventListener(target, 'paste');function addPreventListener (target: Window, name: string) { target.addEventListener(name, (e: Event) =&gt; { return preventEvent(target, e); });} 检测方法DataToString利用 不打开控制不会执行console.log，执行了两次toString后视为打开了控制台 1234567891011121314151617init () { this.count = 0; this.date = new Date(); this.date.toString = () =&gt; { this.count ++; return ''; };}detect () { this.count = 0; log(this.date); clearLog(); if (this.count &gt;= 2) { this.onDevToolOpen(); }} definePropertyconsole.log触发 getter 的特性来检测是否打开了开发者工具。当控制台试图渲染 this.div 对象时，触发了 id 属性的 getter，从而调用 this.onDevToolOpen() 来响应检测结果。 123456789101112131415init () { this.div = document.createElement('div'); (this.div as any).__defineGetter__('id', () =&gt; { this.onDevToolOpen(); }); Object.defineProperty(this.div, 'id', { get: () =&gt; { this.onDevToolOpen(); }, });}detect () { log(this.div);} Detector利用Function的toString 1234567891011121314151617init () { this.count = 0; this.func = () =&gt; {}; this.func.toString = () =&gt; { this.count ++; return ''; };}detect () { this.count = 0; log(this.func); clearLog(); if (this.count &gt;= 2) { this.onDevToolOpen(); }} performance通过控制台打印大对象数组所花的大量时间来检测开发者工具是否被打开 123456789101112131415161718init () { this.maxPrintTime = 0; this.largeObjectArray = createLargeObjectArray();}detect () { const tablePrintTime = calculateTime(() =&gt; {table(this.largeObjectArray);}); const logPrintTime = calculateTime(() =&gt; {log(this.largeObjectArray);}); this.maxPrintTime = Math.max(this.maxPrintTime, logPrintTime); clearLog(); if (tablePrintTime === 0 || this.maxPrintTime === 0) return false; if (tablePrintTime &gt; this.maxPrintTime * 10) { this.onDevToolOpen(); }} debugger原理同本文开头方式 1234567detect () { const date = now(); (() =&gt; {debugger;})(); if (now() - date &gt; 100) { this.onDevToolOpen(); }} resize通过监测内外窗口尺寸（如outerWidth和innerWidth的差值）是否异常变化来检测开发者工具的打开状态 123456789101112131415161718192021222324252627282930313233343536373839init () { this.checkWindowSizeUneven(); window.addEventListener('resize', () =&gt; { setTimeout(() =&gt; { this.checkWindowSizeUneven(); }, 100); }, true);}// 检测内外窗口的大小是否因devtool而产生差值private checkWindowSizeUneven () { const screenRatio = countScreenZoomRatio(); if (screenRatio === false) { // 如果获取不到屏幕缩放尺寸 则不启用sizeDetector return true; } const widthUneven = window.outerWidth - window.innerWidth * screenRatio &gt; 200; // 调大一点防止误伤 const heightUneven = window.outerHeight - window.innerHeight * screenRatio &gt; 300; // 调大一点防止误伤 if (widthUneven || heightUneven) { this.onDevToolOpen(); return false; } clearDevToolOpenState(this.type); return true;}// 获取像素比function countScreenZoomRatio () { if (checkExist(window.devicePixelRatio)) { return window.devicePixelRatio; } const screen = window.screen as any; if (checkExist(screen)) { return false; } if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) { return screen.deviceXDPI / screen.logicalXDPI; } return false;}; 总结其实就三种检测类型 resize console.log debugger 但产生了多种检测器，从而增大破解的难度 破解之法破解之法1仅需停用断点，即可破解 破解之法2只要一律不在此处暂停（debugger），甚至还可以加断点调试网站 破解之法3可以添加条件断点 破解之法4先在一个空页面打开控制台，再进入页面，可以攻击只有debugger的网站 破解之法5使用浏览器开发者工具替换修改js（Sources面板 –&gt; Overrides），详情可看：在本地替换 Web 内容和 HTTP 响应标头 破解之法5直接安装油猴脚本即可，或者自己写一个 参考🔏别想调试我的前端页面代码🔒⚔️不让我在控制台上调试，哼，休想🛠️","link":"/2024/10/28/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/%E7%A6%81%E6%AD%A2%E7%94%A8%E6%88%B7%E8%B0%83%E8%AF%95%E7%BD%91%E7%AB%99/"},{"title":"水塘抽样算法","text":"目的水塘抽样的目标是从一个很大的或未知大小的数据集中随机选取k个样本。 特点：不要求一次性读取所有数据，也不需要知道数据总量，能保证每个元素被选中的概率相等 算法步骤 初始化样本池：先将流中的前k个元素放入样本池。 迭代处理元素：对于第i个新元素，以k/i的概率决定是否将其替换进样本池。 选择替换的元素：如果新元素需要被替换进样本池，随机选择样本池中的一个元素进行替换。 证明过程 前k个元素被放入样本池 第k+1个元素被选中替换的概率是k / (k + 1) 此时样本池中的1-k个元素保留的概率：(1 - k / (k + 1)) + (k / (k + 1) * (k - 1) / k) = k / (k + 1)，即 没中k+1的概率 + 选中k+1但没被替换的概率 从而到k+1时，所有元素保留在样本池中等概率 代码实现12345678910111213141516171819function getRandomInt(max) { return Math.floor(Math.random() * max);}function reservoir_sampling(data, k) { const reservoir = []; for (let i = 0; i &lt; k; i++) { reservoir.push(data[i]); } for (let i = k; i &lt; data.length; i++) { const j = getRandomInt(i); if (j &lt; k) { reservoir[j] = data[i]; } } return reservoir;}","link":"/2024/10/12/%E7%AE%97%E6%B3%95/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"},{"title":"npm script","text":"串行 or 并行并行跑命令：&amp;，在命令结尾加&amp; wait，可以使用ctrl c关闭命令行来结束进程串行跑命令：&amp;&amp; 控制日志输出 –silent（-s）：输出尽可能少的日志 –verbose：显示尽可能多的状态，日志级别的输出，用于调试 npm自动补全 不支持workspace的仓库 npm官方支持补全：npm-completion 第 1 步，把 npm completion 产生的命令放在单独的文件中： 1npm completion &gt;&gt; ~/.npm-completion.bash 第 2 步，在 .bashrc 或者 .zshrc 中引入这个文件： 12echo &quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot; &gt;&gt; ~/.bashrcecho &quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot; &gt;&gt; ~/.zshrc 最后执行 source ~/.zshrc 或者 source ~/.bashrc，来让自动完成生效。 使用补全方式：尝试在命令行中输入 npm run，然后键入空格（空格很重要），然后键入 tab 键 一些跨平台的第三方库 rimraf 或 del-cli，用来删除文件和目录，实现类似于 rm -rf 的功能； cpr，用于拷贝、复制文件和目录，实现类似于 cp -r 的功能； make-dir-cli，用于创建目录，实现类似于 mkdir -p 的功能； 跨平台的引用变量Linux 下直接可以用 $npm_package_name，而 Windows 下必须使用 %npm_package_name%，我们可以使用 cross-var 1npm i cross-var -D 使用方式1234 &quot;scripts&quot;: {- &quot;cover:open&quot;: &quot;opn http://localhost:$npm_package_config_port&quot;,+ &quot;cover:open&quot;: &quot;cross-var opn http://localhost:$npm_package_config_port&quot;, }, 引入 cross-var 之后，它竟然给我们安装了 babel，如果想保持依赖更轻量的话，可以考虑使用 cross-var-no-babel 跨平台的环境变量因为不同平台的环境变量语法不同，我们可以使用 cross-env 来实现 npm script 的跨平台兼容 1npm i cross-env -D 使用方式1234 &quot;scripts&quot;: {- &quot;test&quot;: &quot;NODE_ENV=test mocha tests/&quot;,+ &quot;test&quot;: &quot;cross-env NODE_ENV=test mocha tests/&quot;, }, 抽离script到单独文件当 npm script 不断累积、膨胀的时候，全部放在 package.json 里面可能并不是个好主意，因为这样会导致 package.json 糟乱，可读性降低。 借助 scripty 我们可以将 npm script 剥离到单独的文件中，从而把复杂性隔到单独的模块里面，让代码整体看起来更加清晰。 1npm i scripty -D 使用方式执行npm run foo:bar会向scripts/foo/bar寻找可执行脚本并执行 123&quot;scripts&quot;: { &quot;foo:bar&quot;: &quot;scripty&quot;} 钩子npm script 的设计者为命令的执行增加了类似生命周期的机制，具体来说就是 pre 和 post 钩子脚本 举例来说，运行 npm run test 的时候，分 3 个阶段： 检查 scripts 对象中是否存在 pretest 命令，如果有，先执行该命令； 检查是否有 test 命令，有的话运行 test 命令，没有的话报错； 检查是否存在 posttest 命令，如果有，执行 posttest 命令； 在 Git Hooks 中执行 npm script1npm install -D husky 在package.json增加 12345{ &quot;scripts&quot;: { &quot;precommit&quot;: &quot;eslint src/**/*.js&quot; }} 但是这样会检查到项目中所有的lint错误，如何只检查提交的文件呢？ 需要用到lint-staged 1npm install -D lint-staged package.json改为如下，就可以只lint提交的文件啦 12345678{ &quot;scripts&quot;: { &quot;precommit&quot;: &quot;lint-staged&quot; }, &quot;lint-staged&quot;: { &quot;src/**/*.js&quot;: &quot;eslint&quot; }} 参考文章用 husky 和 lint-staged 构建超溜的代码检查工作流","link":"/2023/10/06/Js/npm-script/"},{"title":"Vueuse源码解读","text":"本文不会放api的用法，建议先看看是怎么用的 写本篇文章时间间隔较长，所以代码版本不一 项目架构采用monorepo的形式，项目目录下有多个子项目，下面放了资料链接和几处用法，其他本文不多赘述。 现代前端工程为什么越来越离不开 Monorepo?为什么使用pnpm可以光速建立好用的monorepo（比yarn/lerna效率高）pnpm workspace文档 为了使所有子项目都使用同一个依赖版本，使用pnpm.overrides配置，如下 12345678{ &quot;pnpm&quot;: { &quot;overrides&quot;: { &quot;vue-demi&quot;: &quot;0.12.1&quot;, // 在postinstall钩子中根据当前环境的vue版本，获取兼容vue3和vue2的api &quot;vite&quot;: &quot;^2.6.7&quot; } }} 在正常配置下，如果直接pnpm install将会在每个子项目的node_modules有同样的依赖，但是所有子项目相同的依赖其实只需要提取出来放在根目录的node_modules下即可，可配置如下 1234&quot;peerDependencies&quot;: { &quot;@vue/composition-api&quot;: &quot;^1.1.0&quot;, &quot;vue&quot;: &quot;^2.6.0 || ^3.2.0&quot;}, 详情请看如下链接 探讨npm依赖管理之peerDependenciespnpm monorepo之多组件实例和peerDependencies困境回溯如何处理 peers 前置知识unref - ref的反操作 如果传入一个ref，返回其值 否则原样放回 1234// 源码实现function unref&lt;T&gt;(ref: T | Ref&lt;T&gt;): T { return isRef(ref) ? ref.value : ref} 使用例子：实现一个响应式的add函数，可以传入ref或值 123456function add( a: Ref&lt;number&gt; | number, b: Ref&lt;number&gt; | number) { return computed(() =&gt; unref(a) + unref(b))} MaybeRef类型vueuse大量使用MaybeRef来支持可选择性的响应式参数 1type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T 上面的加法函数就可以简写为 123function add(a: MaybeRef&lt;number&gt;, b: MaybeRef&lt;number&gt;) { return computed(() =&gt; unref(a) + unref(b))} Effect作用域APIVue官方文档：Effect 作用域 API 动机 在Vue的setup中，响应式effect会在初始化的时候被收集，在实例被卸载的时候，响应式effect就会自动被取消了，但是在我们在组件外写一个独立的包（就如vueuse）时，我们该如何取消computed &amp; watch的响应式依赖呢？vue3.2提出了effectScope，接下来介绍相关的api effectScope利用effectScope创建一个作用域对象，如下面接口定义所示，run接受一个函数，这个作用域对象会自动捕获函数内部的响应式effect (例如计算属性或侦听器) 类型 123456function effectScope(detached?: boolean): EffectScopeinterface EffectScope { run&lt;T&gt;(fn: () =&gt; T): T | undefined // 如果这个域不活跃则为 undefined stop(): void} 示例 12345678910const scope = effectScope()scope.run(() =&gt; { const doubled = computed(() =&gt; counter.value * 2) watch(doubled, () =&gt; console.log(doubled.value)) watchEffect(() =&gt; console.log('Count: ', doubled.value))})// 丢弃(dispose) 该作用域内的所有 effectscope.stop() getCurrentScope如果有，则返回当前活跃的 effect 作用域。 类型 1function getCurrentScope(): EffectScope | undefined onScopeDispose在当前活跃的 effect 作用域上注册一个处理回调。该回调会在相关的 effect 作用域结束之后被调用，在VCA（Vue Composition API）函数中可用作onUnmounted的非组件替代品，区别在于其工作在scope中而不是组件实例 1234// 当前 effectScope 结束后调用onScopeDispose(() =&gt; { window.removeEventListener('mousemove', handler)}) 那么如此抽象的effectScope在尤大降低心智负担的主张下为什么要被提出呢，下面列了个官方rfc中的例子 示例 在vue的rfc中reactivity-effect-scope有这样的一个例子，如果有个监控鼠标位置的hook（useMouse），需要监听mousemove事件，如果在多个组件调用了这个hook，而内部是通过在onUnmounted钩子来移除mousemove监听器，onUnmounted耦合在每个组件实例，则无法以更有效率的方式共享这个mousemove监听器（即） 为了做到在组件间共享useMouse的响应式effect和监听器，可以创建一个函数来管理scope如下（这个hook也在vueuse中） 123456789101112131415161718192021function createSharedComposable(composable) { let subscribers = 0 // 订阅计数器，每次调用subscribers + 1 let state, scope const dispose = () =&gt; { if (scope &amp;&amp; --subscribers &lt;= 0) { scope.stop() state = scope = null } } return (...args) =&gt; { subscribers++ if (!state) { // 只在第一次创建effectScope scope = effectScope(true) // true为独立的scope作用域 state = scope.run(() =&gt; composable(...args)) } onScopeDispose(dispose) // 在当前活跃的effect作用域上注册一个回调 return state }} 可以看到dispose函数的含义是，当没有一个组件在使用它的时候会注销(dispose)创建的effectScope，我们只需要如下操作，即可得到一个在所有组件共享的useMouse 1const useSharedMouse = createSharedComposable(useMouse) 更加详细的关于effectScope的讨论在Reactivity’s effectScope API #212 本来是打算完全按照官网的分类进行解读，但是由于VCA（Vue Composition API）的思想，hook被拆的很碎再组合在一起，并不能单纯靠分类进行解读，所以在讲某个分类的hook时也会带上其他的hooks，接下来是对我觉得 常用 或者 有学习到东西 的hook源码进行解读 StatecreateGlobalState 用来做挂组件公共状态管理 简单的单例模式实现，effectScope的参数为true时，其不会被父scope收集和回收，独立存在 123456789101112131415export function createGlobalState&lt;T&gt;( stateFactory: () =&gt; T,): CreateGlobalStateReturn&lt;T&gt; { let initialized = false let state: T const scope = effectScope(true) return () =&gt; { if (!initialized) { state = scope.run(stateFactory)! initialized = true } return state }} useLocalStorage12345678export function useLocalStorage&lt;T extends(string|number|boolean|object|null)&gt; ( key: string, initialValue: MaybeRef&lt;T&gt;, options: StorageOptions&lt;T&gt; = {},): RemovableRef&lt;any&gt; { const { window = defaultWindow } = options return useStorage(key, initialValue, window?.localStorage, options)} 可以看到就是用useStorage来实现的，useSessionStorage也是一样，下面我们来看看useStorage useStorage在浏览器默认的Storage之上像store.js一样对数据进行预处理（序列化），否则如果存一个对象在浏览器的Storage存的会是xxx.toString()之后的值。但是useStorage比起store.js更进一步的增加了对Map和Set类型的数据的处理（Map和Set存在默认的Storage和store.js都是空对象） 利用适配器模式，对每种数据类型定义read、write 123456789101112131415161718192021222324252627282930export const StorageSerializers: Record&lt;'boolean' | 'object' | 'number' | 'any' | 'string' | 'map' | 'set', Serializer&lt;any&gt;&gt; = { boolean: { read: (v: any) =&gt; v === 'true', write: (v: any) =&gt; String(v), }, object: { read: (v: any) =&gt; JSON.parse(v), write: (v: any) =&gt; JSON.stringify(v), }, number: { read: (v: any) =&gt; Number.parseFloat(v), write: (v: any) =&gt; String(v), }, any: { read: (v: any) =&gt; v, write: (v: any) =&gt; String(v), }, string: { read: (v: any) =&gt; v, write: (v: any) =&gt; String(v), }, map: { // map序列化 read: (v: any) =&gt; new Map(JSON.parse(v)), write: (v: any) =&gt; JSON.stringify(Array.from((v as Map&lt;any, any&gt;).entries())), }, set: { // set序列化 read: (v: any) =&gt; new Set(JSON.parse(v)), write: (v: any) =&gt; JSON.stringify(Array.from((v as Set&lt;any&gt;).entries())), },} 接下来判断用户传入的数据类型，进行选择对应的read、write方法 12345678910111213141516171819202122export function guessSerializerType&lt;T extends(string | number | boolean | object | null)&gt;(rawInit: T) { return rawInit == null ? 'any' : rawInit instanceof Set ? 'set' : rawInit instanceof Map ? 'map' : rawInit instanceof Date ? 'date' : typeof rawInit === 'boolean' ? 'boolean' : typeof rawInit === 'string' ? 'string' : typeof rawInit === 'object' ? 'object' : !Number.isNaN(rawInit) ? 'number' : 'any'}const type = guessSerializerType&lt;T&gt;(rawInit)const serializer = options.serializer ?? StorageSerializers[type] // 用户还可以定义自己的序列化方法，但必须具有read和write方法 下面是对数据的初始化 1234567891011121314151617181920const rawInit: T = unref(initialValue) // 用户传入的初始值const data = (shallow ? shallowRef : ref)(initialValue) as Ref&lt;T&gt; // 用户可以配置是浅响应式还是深，最后会返回给用户if (!storage) returntry { const rawValue = storage.getItem(key) if (rawValue == null) { // 如果key对应的值为空，那么是首次 data.value = rawInit // 初始化值 if (writeDefaults &amp;&amp; rawInit !== null) // 用户可配置（writeDefaults）是否首次存入Storage storage.setItem(key, serializer.write(rawInit)) } else { data.value = serializer.read(rawValue) // 如果Storage存在对应值，序列化读取 }}catch (e) { onError(e) // 用户传入的错误处理函数} 然后是根据监听data的变化存入Storage，watchWithFilter可以看做是新增了eventFilter选项的watch，在后文会描述，也是vueuse很重要的一个特性 12345678910111213141516171819watchWithFilter( data, () =&gt; { try { if (data.value == null) storage.removeItem(key) else storage.setItem(key, serializer.write(data.value)) } catch (e) { onError(e) } }, { flush, // 均是用户可配置的选项 deep, eventFilter, },) 是不是觉得很OK了，但仍有巨隐蔽的bug（哈哈哈)，为了支持响应式的存取Storage，用了ref类型的data，在同源下的多个标签的情况下，其中一个页面对另一个页面用useStorage修改了数据，但另一个页面useStorage内部的data还是原来的值 解决方式：监听storage事件（当页面使用的storage被其他页面修改时会触发） 123456789101112131415function read(event?: StorageEvent) { // 将上面初始化值的逻辑封装为read函数 if (!storage || (event &amp;&amp; event.key !== key)) return try { const rawValue = event ? event.newValue : storage.getItem(key) // 读值省略... } catch (e) { onError(e) }}if (window &amp;&amp; listenToStorageChanges) // 用户也可以配置（listenToStorageChanges）不监听 useEventListener(window, 'storage', e =&gt; setTimeout(() =&gt; read(e), 0)) // 重新读取值给data Browser 浏览器相关的hook，基于web暴露的api来实现 可配置全局对象Browser hook的源码开头都有或类似下面这一段 1234567export const defaultWindow = /* #__PURE__ */ isClient ? window : undefinedexport function useXXX&lt;T&gt;(options: ConfigurableWindow = {}) { const { window = defaultWindow } = options window.xxx // ...} 用户可以配置当前window对象，这种配置方式对于使用iframe和测试环境不同的window对象十分有用 useEventListener先上一个简易版本的useEventListener，利用VCA，将事件的监听和注销放在一个函数中处理 123456789function useEventListener (target, listener, options, target = window) { onMounted(() =&gt; { target.addEventListener(type, listener, options) }) onUnmounted(() =&gt; { target.removeEventListener(type, listener, options) })} 除此之外，源码还提供了当target的类型是ref时的情况，为了减少篇幅，下面的代码删减了参数为空的边界情况 12345678910111213141516171819202122232425262728293031323334353637export function useEventListener(...args: any[]) { let target: MaybeRef&lt;EventTarget&gt; | undefined = defaultWindow; let event: string let listener: any let options: any [target, event, listener, options] = args let cleanup = noop const stopWatch = watch( () =&gt; unref(target), (el) =&gt; { cleanup() if (!el) return el.addEventListener(event, listener, options) cleanup = () =&gt; { el.removeEventListener(event, listener, options) cleanup = noop } }, { immediate: true, flush: 'post' }, // 为什么flush是post？下面会讲解 ) const stop = () =&gt; { stopWatch() cleanup() } tryOnScopeDispose(stop) // 还设计了返回stop函数，可以调用useEventListener返回的函数直接回收 return stop} 为什么需要支持ref target用unref得到ref中的dom元素，监听dom元素的改变以重新监听事件，应用场景就放官网例子 1234&lt;template&gt; &lt;div v-if=&quot;cond&quot; ref=&quot;element&quot;&gt;Div1&lt;/div&gt; &lt;div v-else ref=&quot;element&quot;&gt;Div2&lt;/div&gt;&lt;/template&gt; 1234import { useEventListener } from '@vueuse/core'const element = ref&lt;HTMLDivElement&gt;()useEventListener(element, 'keydown', (e) =&gt; { console.log(e.key) }) 为什么需要watch设置flush为post详情请看#356 Bug: useEventListener doesn’t work correctly with v-if，意思就是新版vue的watch默认在所有组件update前执行，那么ref没有更新导致事件没有更新，所以需要在组件update完毕后更新事件。 tryOnScopeDispose是啥先判断是否有活跃的effectScope，有的话用onScopeDispose在其上注册fn回调 1234567export function tryOnScopeDispose(fn: Fn) { if (getCurrentScope()) { onScopeDispose(fn) return true } return false} v10.4.1更新：支持event传递数组，方便浏览器兼容事件 useEyeDroppernew window.EyeDropper()可以获取取色器的功能 usePreferredReducedMotionprefers-reduced-motion用于检测用户的系统是否被开启了动画减弱功能 1useMediaQuery('(prefers-reduced-motion: reduce)', options) usePreferredContrastprefers-contrast判断用户喜欢何种对比度（more、less、custom） useMediaQuerywindow.matchMedia(query)返回MediaQueryList类型 12345678interface MediaQueryList extends EventTarget { // 浏览器原生类型 readonly matches: boolean; // 是否匹配 readonly media: string; // 媒体查询值 onchange: ((this: MediaQueryList, ev: MediaQueryListEvent) =&gt; any) | null; // 媒体查询改变回调 // 事件绑定相关...}let mql: MediaQueryList = window.matchMedia('(max-width: 600px)'); usePermissionnavigator.permissions可以获取用户权限（摄像头、麦克风等） 123456789101112131415161718const isSupported = Boolean(navigator &amp;&amp; 'permissions' in navigator)const state = ref&lt;PermissionState | undefined&gt;() // 存权限状态const onChange = () =&gt; { if (permissionStatus) state.value = permissionStatus.state}try { permissionStatus = await navigator!.permissions.query({ name: 'camera' // https://w3c.github.io/permissions/#enumdef-permissionname }) useEventListener(permissionStatus, 'change', onChange) // 有三个状态 denied&quot; | &quot;granted&quot; | &quot;prompt&quot; onChange()}catch { state.value = 'prompt'} usePreferredLanguagesnavigator.languages可以获取用户的偏好语言，可以通过languagechange事件监听改变 12345const value = ref&lt;readonly string[]&gt;(navigator.languages)useEventListener(window, 'languagechange', () =&gt; { value.value = navigator.languages}) useSharenavigator.share可以进行分享 12345678910111213const isSupported = navigator &amp;&amp; 'canShare' in navigatorif (isSupported) { granted = navigator.canShare({ // 判断是否能被分享 title?: string files?: File[] text?: string url?: string }) if (granted) return navigator.share!(data)} useWakeLock Screen Wake Lock API可以阻止设备变暗或锁屏 123456789101112const isSupported = navigator &amp;&amp; 'wakeLock' in navigatorfunction request(type: WakeLockType) { if (!isSupported) return wakeLock = await navigator.wakeLock.request(type)}function release() { if (!isSupported || !wakeLock) return await wakeLock.release() // 释放WakeLockSentinel wakeLock = null} useVibrate Vibration API可以使设备振动 12window.navigator.vibrate([200, 100, 200]); // 设备振动 200 ms，然后暂停 100 ms，然后再次振动设备 200 msnavigator.vibrate(0); // 停止振动 useWebNotificationNotification可以给用户发送消息 useFullscreenFullscreen_API用以控制全屏展示，虽然常见，但是看源码对兼容性有了多一层考虑 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 请求全屏const requestMethod = computed&lt;'requestFullscreen' | undefined&gt;(() =&gt; { return [ 'requestFullscreen', 'webkitRequestFullscreen', 'webkitEnterFullscreen', 'webkitEnterFullScreen', 'webkitRequestFullScreen', 'mozRequestFullScreen', 'msRequestFullscreen', ].find(m =&gt; (document &amp;&amp; m in document) || (targetRef.value &amp;&amp; m in targetRef.value)) as any})// 退出全屏const exitMethod = computed&lt;'exitFullscreen' | undefined&gt;(() =&gt; { return [ 'exitFullscreen', 'webkitExitFullscreen', 'webkitExitFullScreen', 'webkitCancelFullScreen', 'mozCancelFullScreen', 'msExitFullscreen', ].find(m =&gt; (document &amp;&amp; m in document) || (targetRef.value &amp;&amp; m in targetRef.value)) as any})// 当前是否处于全屏状态的判断const fullscreenEnabled = computed&lt;'fullscreenEnabled' | undefined&gt;(() =&gt; { return [ 'fullScreen', 'webkitIsFullScreen', 'webkitDisplayingFullscreen', 'mozFullScreen', 'msFullscreenElement', ].find(m =&gt; (document &amp;&amp; m in document) || (targetRef.value &amp;&amp; m in targetRef.value)) as any})// 获取当前全屏元素的方法名const fullscreenElementMethod = [ 'fullscreenElement', 'webkitFullscreenElement', 'mozFullScreenElement', 'msFullscreenElement',].find(m =&gt; (document &amp;&amp; m in document)) as 'fullscreenElement' | undefined 利用适配器的方式进行调用，target[requestMethod.value]() 下面是不同浏览器监听全局变化的事件名 12345678910const eventHandlers = [ 'fullscreenchange', 'webkitfullscreenchange', 'webkitendfullscreen', 'mozfullscreenchange', 'MSFullscreenChange',]// useEventListener支持传数组useEventListener(() =&gt; unrefElement(targetRef), eventHandlers, handlerCallback, false) SensorsonStartTyping在开始输入的时候执行，我们可以拿来做到不管编辑器是否聚焦，只要输入就聚焦到编辑器并输入 1234567891011export function onStartTyping(callback: (event: KeyboardEvent) =&gt; void, options: ConfigurableDocument = {}) { const { document = defaultDocument } = options const keydown = (event: KeyboardEvent) =&gt; { isTypedCharValid(event) // 检测是否是有效输入 0...9 A...Z a...z &amp;&amp; callback(event) } if (document) useEventListener(document, 'keydown', keydown, { passive: true })} 在上面的基础上还需要做一点，如果已经聚焦到non-editable elements，那么就不执行，如何检测non-editable elements呢，如下 1234567891011121314151617function isFocusedElementEditable() { const { activeElement, body } = document if (!activeElement) return false if (activeElement === body) return false switch (activeElement.tagName) { case 'INPUT': case 'TEXTAREA': return true } return activeElement.hasAttribute('contenteditable')} useMagicKeys恰如其名，magic，先上用法 123456const { space, shift } = useMagicKeys()watch(space, (v) =&gt; { if (v) console.log('space has been pressed')}) 又没传参，他怎么监听到我要的space和shift，难不成他返回了所有键？那当然不是，上源码（抽离了关键逻辑） 12345678910111213141516171819202122232425262728293031323334export function useMagicKeys(options: UseMagicKeysOptions&lt;boolean&gt; = {}): any { const current = reactive(new Set&lt;string&gt;()) const obj = { toJSON() { return {} }, current, } const refs: Record&lt;string, any&gt; = useReactive ? reactive(obj) : obj useEventListener(target, 'keydown', (e: KeyboardEvent) =&gt; { updateRefs(e, true) // 更新按下的键到refs，键为e.key?.toLowerCase()，值为true }, { passive }) useEventListener(target, 'keyup', (e: KeyboardEvent) =&gt; { updateRefs(e, false) // 更新按下的键到refs，键为e.key?.toLowerCase()，值为false }, { passive }) const proxy = new Proxy( refs, { get(target, prop, rec) { if (!(prop in refs)) { // 初始将对应的键设为false，如'shift' refs[prop] = ref(false) } const r = Reflect.get(target, prop, rec) return useReactive ? toValue(r) : r }, }, ) return proxy as any} 这样refs只存了取的键的状态，而不是所有键的状态 usePageLeave用MouseEvent.relatedTarget检测是否离开屏幕 123456789101112131415export function usePageLeave(options: ConfigurableWindow = {}) { const handler = (event: MouseEvent) =&gt; { const from = event.relatedTarget || event.toElement // 如果为null，则移出屏幕 isLeft.value = !from } if (window) { useEventListener(window, 'mouseout', handler, { passive: true }) useEventListener(window.document, 'mouseleave', handler, { passive: true }) useEventListener(window.document, 'mouseenter', handler, { passive: true }) } return isLeft} useSpeechSynthesis利用SpeechSynthesis来做到语音阅读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function useSpeechSynthesis(text: MaybeRefOrGetter&lt;string&gt;, options: UseSpeechSynthesisOptions = {}) { // ... const synth = window &amp;&amp; (window as any).speechSynthesis as SpeechSynthesis; const bindEventsForUtterance = (utterance: SpeechSynthesisUtterance) =&gt; { utterance.lang = toValue(lang) utterance.voice = toValue(options.voice) || null utterance.pitch = toValue(pitch) utterance.rate = toValue(rate) utterance.volume = volume utterance.onstart = () =&gt; { isPlaying.value = true status.value = 'play' } utterance.onpause = () =&gt; { isPlaying.value = false status.value = 'pause' } utterance.onresume = () =&gt; { isPlaying.value = true status.value = 'play' } utterance.onend = () =&gt; { isPlaying.value = false status.value = 'end' } utterance.onerror = (event) =&gt; { error.value = event } } const utterance = computed(() =&gt; { isPlaying.value = false status.value = 'init' const newUtterance = new SpeechSynthesisUtterance(spokenText.value) bindEventsForUtterance(newUtterance) return newUtterance }) const speak = () =&gt; { synth!.cancel() utterance &amp;&amp; synth!.speak(utterance.value) } const stop = () =&gt; { synth!.cancel() isPlaying.value = false } tryOnScopeDispose(() =&gt; { isPlaying.value = false }) // ...} AnimationuseTransition可配置项 123456789101112131415161718type CubicBezierPoints = [number, number, number, number]type EasingFunction = (n: number) =&gt; numberexport function useTransition( source: Ref&lt;number | number[]&gt; | MaybeRef&lt;number&gt;[], options: TransitionOptions = {},): ComputedRef&lt;any&gt; { const { // 时间相关单位均为ms delay = 0, // delay 后执行 disabled = false, // 是否关闭 duration = 1000, // 持续时间 onFinished = noop, // 完成后执行 onStarted = noop, // 开始时执行 transition = linear, // 转化算法 MaybeRef&lt;EasingFunction | CubicBezierPoints&gt;，默认值是 x =&gt; x } = options // ...} 预处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export function useTransition( source: Ref&lt;number | number[]&gt; | MaybeRef&lt;number&gt;[], options: TransitionOptions = {},): ComputedRef&lt;any&gt; { // 可配置项 // 创建当前的过渡函数，如果用户自定义了过渡函数则不做处理，否则根据贝赛尔曲线值创建过渡函数 const currentTransition = computed(() =&gt; { const t = unref(transition) return isFunction(t) ? t : createEasingFunction(t) }) // 用unref处理source参数，如果source是数组则依次unref const sourceValue = computed(() =&gt; { const s = unref&lt;number | MaybeRef&lt;number&gt;[]&gt;(source) return isNumber(s) ? s : s.map(unref) as number[] }) // 规格化source，整成数组 const sourceVector = computed(() =&gt; isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value) // ...}// 创建过渡函数，纯数学function createEasingFunction([p0, p1, p2, p3]: CubicBezierPoints): EasingFunction { const a = (a1: number, a2: number) =&gt; 1 - 3 * a2 + 3 * a1 const b = (a1: number, a2: number) =&gt; 3 * a2 - 6 * a1 const c = (a1: number) =&gt; 3 * a1 const calcBezier = (t: number, a1: number, a2: number) =&gt; ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t const getSlope = (t: number, a1: number, a2: number) =&gt; 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1) const getTforX = (x: number) =&gt; { let aGuessT = x for (let i = 0; i &lt; 4; ++i) { const currentSlope = getSlope(aGuessT, p0, p2) if (currentSlope === 0) return aGuessT const currentX = calcBezier(aGuessT, p0, p2) - x aGuessT -= currentX / currentSlope } return aGuessT } return (x: number) =&gt; p0 === p1 &amp;&amp; p2 === p3 ? x : calcBezier(getTforX(x), p1, p3)} 提供了几种过渡预设 12345export const TransitionPresets: Record&lt;string, CubicBezierPoints | EasingFunction&gt; = { easeInSine: [0.12, 0, 0.39, 0], easeOutSine: [0.61, 1, 0.88, 1], // ...} 详情可以看 缓动函数、 MDN：缓动函数 关键逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344const outputVector = ref(sourceVector.value.slice(0)) // 用以存储输出// 过渡主流程，可以暂停const { resume, pause } = useRafFn(() =&gt; { // 可以暂停、恢复的 requestAnimationFrame const now = Date.now() const progress = clamp(1 - ((endAt - now) / currentDuration), 0, 1) // 过渡进度，clamp将值限制在0-1之间 outputVector.value = startVector.map((val, i) =&gt; val + ((diffVector[i] ?? 0) * currentTransition.value(progress))) // 更新output if (progress &gt;= 1) { // 完成过渡 pause() // 暂停 requestAnimationFrame onFinished() // 执行options中的完成回调 }}, { immediate: false })const timeout = useTimeoutFn(start, delay, { immediate: false }) // delay毫秒后执行start函数const start = () =&gt; { pause() // 暂停 过渡 currentDuration = unref(duration) diffVector = outputVector.value.map((n, i) =&gt; (sourceVector.value[i] ?? 0) - (outputVector.value[i] ?? 0)) // 初始值和当前值的diff startVector = outputVector.value.slice(0) // 拷贝初始值 startAt = Date.now() // 开始时间 endAt = startAt + currentDuration // 结束时间，用在计算progress resume() // 开始过渡 onStarted() // 执行options中的开始回调}watch(sourceVector, () =&gt; { // 监听sourceVector的变化 if (unref(disabled)) { // 如果暂停过渡，将输出还原回初始值 outputVector.value = sourceVector.value.slice(0) } else { if (unref(delay) &lt;= 0) start() // 如果没有延迟，则开始过渡 else timeout.start() // 如果有延迟，则开始上面创建好的timeout }}, { deep: true })return computed(() =&gt; { const targetVector = unref(disabled) ? sourceVector : outputVector // 如果暂停过渡，将输出还原回初始值 return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value // 为值解开数组包装，数组原样返回}) @Sound可以简单的让你的网站带上声音 123import buttonSfx from '../assets/sounds/button.mp3'const { play } = useSound(buttonSfx) demo：https://sound.vueuse.org/","link":"/2023/09/10/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vueuse%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"title":"【源码解读】p-limit 限制并发数","text":"github: https://github.com/sindresorhus/p-limit 使用方式123456789101112import pLimit from 'p-limit';const limit = pLimit(1); // 只能有一个promise在执行const input = [ limit(() =&gt; fetchSomething('foo')), limit(() =&gt; fetchSomething('bar')), limit(() =&gt; doSomething())];const result = await Promise.all(input);console.log(result); 函数源码初始化（pLimit）1234567891011121314151617181920212223242526import Queue from &quot;yocto-queue&quot;;export default function pLimit(concurrency) { const queue = new Queue(); let activeCount = 0; const enqueue = (fn, resolve, args) =&gt; { queue.enqueue(run.bind(undefined, fn, resolve, args)); (async () =&gt; { // 思考里讲解为什么这里需要Promise.resolve() await Promise.resolve() if (activeCount &lt; concurrency &amp;&amp; queue.size &gt; 0) { queue.dequeue()(); } })(); }; const generator = (fn, ...args) =&gt; new Promise((resolve) =&gt; { enqueue(fn, resolve, args); }); return generator;} pLimit函数的入参 concurrency 是最大并发数，调用一次 pLimit 会生成一个限制并发的函数 generator 依赖yocto-queue的队列能力，每次调用generator会返回个promise 会向队列入队一个run（执行函数） 如果当前在执行promise数量小于concurrency（并发数），就出队并执行 执行函数（run）123456789101112131415161718192021const next = () =&gt; { activeCount--; if (queue.size &gt; 0) { queue.dequeue()(); }};const run = async (fn, resolve, args) =&gt; { activeCount++; const result = (async () =&gt; fn(...args))(); resolve(result); try { await result; } catch {} next();}; run函数执行 activeCount加一 执行异步函数fn，并将结果传递给resolve await了result，使得next执行有序 执行next时表示promise结果已经返回，activeCount-1，并开始执行下一个promise 思考为什么使用队列而不是数组相关issus：Improve performance shift方法每次调用时, 都需要遍历一次数组, 将数组进行一次平移, 时间复杂度是O(n)队列的dequeue时间复杂度则是O(1) 为什么在入队并且执行的时候，判断执行前需要await Promise.resolve()相关issus：Always run limited functions asynchronously 不加的话，有时候执行是同步的，有时候执行是异步的，有可能会导致在下一行代码执行之前状态就已经改变了，让程序运行结果不可预测 1234567(async () =&gt; { await Promise.resolve() if (activeCount &lt; concurrency &amp;&amp; queue.size &gt; 0) { queue.dequeue()(); }})(); 加上可以保证所有出队执行都是异步的 如何添加超时逻辑1234567891011121314let timer = null;const timerPromise = new Promise((resolve, reject) =&gt; { timer = setTimeout(() =&gt; { reject('time out'); }, 1000);});Promise.all([ timerPromise, fetchPromise,]).then(res =&gt; clearTimeout(timer)).catch(err =&gt; console.error(err)); 更正规的写法可以参考：p-timeout 参考文章Node.js 并发能力总结","link":"/2023/04/19/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/p-limit-%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0/"},{"title":"【源码解读】arrify 转数组","text":"半年没写博客，从简单的源码开始启动 github: https://github.com/sindresorhus/arrify 功能代码比较简单，就先展示一下全部js代码 12345678910111213141516171819export default function arrify(value) { if (value === null || value === undefined) { return []; } if (Array.isArray(value)) { return value; } if (typeof value === 'string') { return [value]; } if (typeof value[Symbol.iterator] === 'function') { return [...value]; } return [value];} 在我看来和Array.from的区别如下 Array.from arrify undefined 报错：Uncaught TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator)) [] Null 报错：Uncaught TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator)) [] document.querySelector(‘*’) 带所有元素的数组 [document.querySelector(‘*’)] 作者对于array like处理的回应，翻译一下：故意这么整的，arrify应当只是数组化，而不是对类数组进行转换，对类数组转换可以用Array.from ps：在我尝试的时候，用chrome控制台Array.from(document.querySelector(‘‘))，会得到一个*空数组**，但是本地创建的html测试是没问题的，不知道为什么 关于string的处理为什么不直接去掉value === ‘string’这个if语句块，这样在最后也能返回[value]？ 答：string有Symbol.iterator属性，所以会执行[…value] 类型定义重载定义？最开始的类型定义是用重载的方式，对不同参数类型进行处理，代码如下 123456declare function arrify(value: null | undefined): [];declare function arrify(value: string): [string];declare function arrify&lt;ValueType&gt;(value: ValueType[]): ValueType[];declare function arrify&lt;ValueType&gt;(value: ReadonlyArray&lt;ValueType&gt;): ReadonlyArray&lt;ValueType&gt;;declare function arrify&lt;ValueType&gt;(value: Iterable&lt;ValueType&gt;): ValueType[];declare function arrify&lt;ValueType&gt;(value: ValueType): [ValueType]; 但是在该issus提出了，参数不支持联合类型，case如下 1arrify(Boolean() ? [1, 2] : 3); 参数会被ts推断为number | number[]，并不满足上面所有重载方法的定义，考虑联合类型后，各种类型组合的数量太多了，函数重载的定义方式无法满足需求。 改进版类型定义如下，其实也和js的判断一一对应 1234567891011export default function arrify&lt;ValueType&gt;( value: ValueType): ValueType extends (null | undefined) ? [] : ValueType extends string ? [string] : ValueType extends readonly unknown[] ? ValueType : ValueType extends Iterable&lt;infer T&gt; ? T[] : [ValueType]; 使用extend后，会将联合类型的每一个取出来执行判断，得出结果后再合并成联合类型，例子： 1234567891011type value&lt;ValueType&gt; = ValueType extends (null | undefined) ? [] : ValueType extends string ? [string] : ValueType extends readonly unknown[] ? ValueType : ValueType extends Iterable&lt;infer T&gt; ? T[] : [ValueType];type test = value&lt;number | string[]&gt; // [number] | string[] 总结还是比较老的仓库，他的一些设计理念我不是很认同，我觉得给人用的第三方库就应该能够处理所有的情况，而不是为了设计理念来严格定义，不对一些情况进行处理","link":"/2022/05/21/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/arrify-%E8%BD%AC%E6%95%B0%E7%BB%84/"},{"title":"Mitt源码解读","text":"github地址：https://github.com/developit/mitt 200b大小的event bus库 类型系统让人眼前一亮的是，该库对类型有着较强规范，用户可以很方便的用下面的方式定义事件类型，在该issus被提出 12345678910type Events = { foo: string; // 事件名: 参数类型 bar?: number;};const emitter = mitt&lt;Events&gt;(); // inferred as Emitter&lt;Events&gt;emitter.on('foo', (e) =&gt; {}); // 'e' has inferred type 'string'emitter.emit('foo', 42); // Error: Argument of type 'number' is not assignable to parameter of type 'string'. (2345) 那它是如何做到的呢，先把实现代码展示出来再分部讲解（直接看懂的可以跳过讲解）。 1234567891011121314151617181920212223export type EventType = string | symbol;export type Handler&lt;T = unknown&gt; = (event: T) =&gt; void;export default function mitt&lt;Events extends Record&lt;EventType, unknown&gt;&gt;( all?: EventHandlerMap&lt;Events&gt; // 可以暂时忽略这里): Emitter&lt;Events&gt; { type GenericEventHandler = | Handler&lt;Events[keyof Events]&gt; | WildcardHandler&lt;Events&gt;; // 为了适配用 * return { // ... on&lt;Key extends keyof Events&gt; (type: Key, handler: GenericEventHandler) { // ... }, off&lt;Key extends keyof Events&gt; (type: Key, handler?: GenericEventHandler) { // ... }, emit&lt;Key extends keyof Events&gt;(type: Key, evt?: Events[Key]) { // ... } }} RecordRecord&lt;K, T&gt;是typescript内置的类型函数 1234// Construct a type with a set of properties K of type Ttype Record&lt;K extends keyof any, T&gt; = { [P in K]: T;}; 代表的意思是从第一个参数获取所有键，值为第二个参数，源码中Record&lt;EventType, unknown&gt;即为 1234export type EventType = string | symbol;Record&lt;EventType, unknown&gt; === { [P in string | symbol]: unknown;} Events extends Record&lt;EventType, unknown&gt;利用泛型约束将用户传入的Events类型约束为上述类型 类型编程就像余华老师睡一觉醒来后有了这么一个题目叫《活着》，觉得题目非常好就开始写了，第一次见到Linbudu的博客，见到了一个词——类型编程，有了这么一个概念（虽然不知道是在何时何地被提出的），突然很多知识就有了一个系统的名称，引导人们探索这个系统下的各种应用，下面就是一个很简单的一个例子。 123export type Handler&lt;T = unknown&gt; = (event: T) =&gt; void;type GenericEventHandler = Handler&lt;Events[keyof Events]&gt; Events[keyof Events]就是将用户定义的Events类型的值类型全部取出，在最上面的使用方式的例子里，会有如下的转化结果。 1234567type Events = { foo: string; // 事件名: 参数类型 bar?: number;};Events[keyof Events] === string | number;type GenericEventHandler = Handler&lt;Events[keyof Events]&gt; === (event: string | number) =&gt; void 再看on、off、emit函数定义，去除了 支持type为*的功能 123456789on&lt;Key extends keyof Events&gt; (type: Key, handler: Handler&lt;Events[Key]&gt;) { // ...}off&lt;Key extends keyof Events&gt; (type: Key, handler?: Handler&lt;Events[Key]&gt;) { // ...}emit&lt;Key extends keyof Events&gt;(type: Key, evt?: Events[Key]) { // ...} 因此我们在on、off和emit只能注册或注销事件名和handler的参数与用户定义Events类型一致的事件 代码逻辑可替换的allall用来存储用户注册的事件，mitt会初始化一个Map作为默认的，但是用户可以传入自己的Map。 12345export default function mitt&lt;Events extends Record&lt;EventType, unknown&gt;&gt;( all?: EventHandlerMap&lt;Events&gt;): Emitter&lt;Events&gt; { all = all || new Map();} on123456789on&lt;Key extends keyof Events&gt;(type: Key, handler: GenericEventHandler) { const handlers: Array&lt;GenericEventHandler&gt; | undefined = all!.get(type); if (handlers) { handlers.push(handler); } else { all!.set(type, [handler] as EventHandlerList&lt;Events[keyof Events]&gt;); }} 如果已经注册同名事件则直接将handler推进数组，否则创建个新数组存放hanlder。 off1234567891011off&lt;Key extends keyof Events&gt;(type: Key, handler?: GenericEventHandler) { const handlers: Array&lt;GenericEventHandler&gt; | undefined = all!.get(type); // 对应事件名的handler数组 if (handlers) { if (handler) { handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; 0, 1); } else { all!.set(type, []); } }} 有一个秀操作的点，当用户传入handler要删除对应事件名下的对应handler时，有这么一段。 1handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; 0, 1); 我们知道 indexOf没有在数组中找到对应的值，那么就会返回-1 &gt;&gt;&gt; 0（ 零填充右位移0位）不是没变？ 而splice(-1, 1)表示删除最后一位 综合起来看，如果-1 &gt;&gt;&gt; 0没变那么就会误删最后一个handler。 让我们看看&gt;&gt;&gt; 0是什么魔法 1console.log(-1 &gt;&gt;&gt; 0); // 4294967295 js number采用的是IEEE 754双精度浮点，&gt;&gt;&gt;会把number截断成32位int进行位移，更具体的不展开。如果没找到对应的handler，代码即为handlers.splice(4294967295, 1)，我们当然不可能存如此多的handler，也就不可能删除4294967295下标对应的handler，比起我们判断indexOf是否为-1缩短了代码（什么叫Microscopic啊？） emit 适配type为*的情况，为所有事件都注册handler，emit时取出*中的所有handler执行 12345678910111213141516171819emit&lt;Key extends keyof Events&gt;(type: Key, evt?: Events[Key]) { let handlers = all!.get(type); if (handlers) { (handlers as EventHandlerList&lt;Events[keyof Events]&gt;) .slice() .map((handler) =&gt; { handler(evt!); }); } handlers = all!.get('*'); if (handlers) { (handlers as WildCardEventHandlerList&lt;Events&gt;) .slice() .map((handler) =&gt; { handler(type, evt!); }); }} 题外话Once虽然源码并没有实现，但是既然是事件总线的文章，还是提一提。在我之前面试的时候经常被问到事件总线是如何实现的，其中就有Once的实现，我没有深入思考，只想着实现就完事了：给所有handler用对象包裹一层，然后加一个Once字段标识，在emit时判断Once是否为true，true的话执行完注销事件，但是这样on和emit都需要修改，多创建了一个对象并且不优雅。 我们可以充分利用js的灵活性，用一个函数包裹用户的handler，在该函数中off掉handler。 1234567891011once(type: Key, handler: GenericEventHandler) { function on () { const self: Emitter&lt;Events&gt; = this; function listener () { self.off(type, listener); handler.apply(this, arguments); } this.on(type, listener); }} 但是上面的代码有一个很隐蔽的问题：由于是用一个新的函数去包裹，在off时传旧handler去注销once事件无法成功 解决方式 在listener函数中存旧的handler 123456789101112once(type: Key, handler: GenericEventHandler) { function on () { const self: Emitter&lt;Events&gt; = this; function listener () { self.off(type, listener); handler.apply(this, arguments); } listener.fn = handler; // 增加了这里 this.on(type, listener); }} 不过用这种方式的话，我们的&gt;&gt;&gt;魔法就不能使用的（这是mitt没有once的原因？） 1234567891011121314off&lt;Key extends keyof Events&gt;(type: Key, handler?: GenericEventHandler) { const handlers: Array&lt;GenericEventHandler&gt; | undefined = all!.get(type); if (handlers) { if (handler) { for (let i = 0; i &lt; handlers.length; i++) { if (handler === handlers[i] || handler === handlers[i].fn) handlers.splice(i, 1); } } else { all!.set(type, []); } }} unknown在该Stronger typing #114commit中，大量的any被替换为unknown 关于unknown的特点可看[译] TypeScript 3.0: unknown 类型","link":"/2021/12/15/Ts/Mitt%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"title":"vueuse源码解析","text":"本文不会放api的用法，建议先看看是怎么用的 项目架构采用monorepo的形式，项目目录下有多个子项目，下面放了资料链接和几处用法，其他本文不多赘述。 现代前端工程为什么越来越离不开 Monorepo?为什么使用pnpm可以光速建立好用的monorepo（比yarn/lerna效率高）pnpm workspace文档 为了使所有子项目都使用同一个依赖版本，使用pnpm.overrides配置，如下 12345678{ &quot;pnpm&quot;: { &quot;overrides&quot;: { &quot;vue-demi&quot;: &quot;0.12.1&quot;, // 在postinstall钩子中根据当前环境的vue版本，获取兼容vue3和vue2的api &quot;vite&quot;: &quot;^2.6.7&quot; } }} 在正常配置下，如果直接pnpm install将会在每个子项目的node_modules有同样的依赖，但是所有子项目相同的依赖其实只需要提取出来放在根目录的node_modules下即可，可配置如下 1234&quot;peerDependencies&quot;: { &quot;@vue/composition-api&quot;: &quot;^1.1.0&quot;, &quot;vue&quot;: &quot;^2.6.0 || ^3.2.0&quot;}, 详情请看如下链接 探讨npm依赖管理之peerDependenciespnpm monorepo之多组件实例和peerDependencies困境回溯如何处理 peers 前置知识unref - ref的反操作 如果传入一个ref，返回其值 否则原样放回 1234// 源码实现function unref&lt;T&gt;(ref: T | Ref&lt;T&gt;): T { return isRef(ref) ? ref.value : ref} 使用例子：实现一个响应式的add函数，可以传入ref或值 123456function add( a: Ref&lt;number&gt; | number, b: Ref&lt;number&gt; | number) { return computed(() =&gt; unref(a) + unref(b))} MaybeRef类型vueuse大量使用MaybeRef来支持可选择性的响应式参数 1type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T 上面的加法函数就可以简写为 123function add(a: MaybeRef&lt;number&gt;, b: MaybeRef&lt;number&gt;) { return computed(() =&gt; unref(a) + unref(b))} Effect作用域APIVue官方文档：Effect 作用域 API 动机 在Vue的setup中，响应式effect会在初始化的时候被收集，在实例被卸载的时候，响应式effect就会自动被取消了，但是在我们在组件外写一个独立的包（就如vueuse）时，我们该如何停止computed &amp; watch的响应式依赖呢？vue3.2提出了effectScope effectScope利用effectScope创建一个作用域对象，如下面接口定义所示，run接受一个函数，这个作用域对象会自动捕获函数内部的响应式effect (例如计算属性或侦听器) 类型 123456function effectScope(detached?: boolean): EffectScopeinterface EffectScope { run&lt;T&gt;(fn: () =&gt; T): T | undefined // 如果这个域不活跃则为 undefined stop(): void} 示例 12345678910const scope = effectScope()scope.run(() =&gt; { const doubled = computed(() =&gt; counter.value * 2) watch(doubled, () =&gt; console.log(doubled.value)) watchEffect(() =&gt; console.log('Count: ', doubled.value))})// 处理(dispose) 该作用域内的所有 effectscope.stop() getCurrentScope如果有，则返回当前活跃的 effect 作用域。 类型 1function getCurrentScope(): EffectScope | undefined onScopeDispose在当前活跃的 effect 作用域上注册一个处理回调。该回调会在相关的 effect 作用域结束之后被调用，在VCA函数中可用作onUnmounted的非组件替代品，区别在于其工作在scope中而不是组件实例 123onScopeDispose(() =&gt; { window.removeEventListener('mousemove', handler)}) 示例 在vue的rfc中reactivity-effect-scope有这样的一个例子，如果有个监控鼠标位置的hook（useMouse），需要监听mousemove事件，如果在多个组件调用了这个hook，而内部是通过在onUnmounted钩子来移除mousemove监听器，onUnmounted耦合在每个组件实例，则无法以更有效率的方式共享这个mousemove监听器 为了做到在组件间共享useMouse的响应式effect和监听器，可以创建一个函数来管理scope如下（这个hook也在vueuse中） 123456789101112131415161718192021function createSharedComposable(composable) { let subscribers = 0 // 每次调用subscribers + 1 let state, scope const dispose = () =&gt; { if (scope &amp;&amp; --subscribers &lt;= 0) { scope.stop() state = scope = null } } return (...args) =&gt; { subscribers++ if (!state) { // 只在第一次创建effectScope scope = effectScope(true) // true为独立的scope作用域 state = scope.run(() =&gt; composable(...args)) } onScopeDispose(dispose) // 在当前活跃的effect作用域上注册一个回调 return state }} 可以看到dispose函数的含义是，当没有一个组件在使用它的时候会注销(dispose)创建的effectScope，我们只需要如下操作，即可得到一个在所有组件共享的useMouse 1const useSharedMouse = createSharedComposable(useMouse) 更加详细的关于effectScope的讨论在Reactivity’s effectScope API #212 本来是打算完全按照官网的分类进行解读，但是由于VCA的思想，hook被拆的很碎再组合在一起，并不能单纯靠分类进行解读，所以在讲某个分类的hook时也会带上其他的hooks，接下来是对我觉得 常用 或者 有学习到东西 的hook源码进行解读 Browser 浏览器相关的hook，基于web暴露的api来实现 可配置全局对象Browser hook的源码开头都有或类似下面这一段 1234567export const defaultWindow = /* #__PURE__ */ isClient ? window : undefinedexport function useXXX&lt;T&gt;(options: ConfigurableWindow = {}) { const { window = defaultWindow } = options window.xxx // ...} 用户可以配置当前window对象，这种配置方式对于使用iframe和测试环境不同的window对象十分有用 useEventListener先上一个简易版本的useEventListener，利用VCA，将事件的监听和注销放在一个函数中处理 123456789function useEventListener (target, listener, options, target = window) { onMounted(() =&gt; { target.addEventListener(type, listener, options) }) onUnmounted(() =&gt; { target.removeEventListener(type, listener, options) })} 除此之外，源码还提供了当target的类型是ref时的情况，为了减少篇幅，下面的代码删减了参数为空的边界情况 123456789101112131415161718192021222324252627282930313233343536export function useEventListener(...args: any[]) { let target: MaybeRef&lt;EventTarget&gt; | undefined = defaultWindow; let event: string let listener: any let options: any [target, event, listener, options] = args let cleanup = noop const stopWatch = watch( () =&gt; unref(target), (el) =&gt; { cleanup() if (!el) return el.addEventListener(event, listener, options) cleanup = () =&gt; { el.removeEventListener(event, listener, options) cleanup = noop } }, { immediate: true, flush: 'post' }, // 为什么flush是post？下面会讲解 ) const stop = () =&gt; { stopWatch() cleanup() } tryOnScopeDispose(stop) return stop} 为什么需要支持ref target用unref得到ref中的dom元素，监听dom元素的改变以重新监听事件，应用场景就放官网例子 1234&lt;template&gt; &lt;div v-if=&quot;cond&quot; ref=&quot;element&quot;&gt;Div1&lt;/div&gt; &lt;div v-else ref=&quot;element&quot;&gt;Div2&lt;/div&gt;&lt;/template&gt; 1234import { useEventListener } from '@vueuse/core'const element = ref&lt;HTMLDivElement&gt;()useEventListener(element, 'keydown', (e) =&gt; { console.log(e.key) }) 为什么需要watch设置flush为post详情请看#356 Bug: useEventListener doesn’t work correctly with v-if，意思就是新版vue的watch默认在所有组件update前执行，那么ref没有更新导致事件没有更新，所以需要在组件update完毕后更新事件。 tryOnScopeDispose是啥先判断是否有活跃的effectScope，有的话用onScopeDispose在其上注册fn回调 1234567export function tryOnScopeDispose(fn: Fn) { if (getCurrentScope()) { onScopeDispose(fn) return true } return false} useEyeDroppernew window.EyeDropper()可以获取取色器的功能 useMediaQuerywindow.matchMedia(query)返回MediaQueryList类型 12345678interface MediaQueryList extends EventTarget { // 浏览器原生类型 readonly matches: boolean; // 是否匹配 readonly media: string; // 媒体查询值 onchange: ((this: MediaQueryList, ev: MediaQueryListEvent) =&gt; any) | null; // 媒体查询改变回调 // 事件绑定相关...}let mql: MediaQueryList = window.matchMedia('(max-width: 600px)'); usePermissionnavigator.permissions可以获取用户权限（摄像头、麦克风等） 123456789101112131415161718const isSupported = Boolean(navigator &amp;&amp; 'permissions' in navigator)const state = ref&lt;PermissionState | undefined&gt;() // 存权限状态const onChange = () =&gt; { if (permissionStatus) state.value = permissionStatus.state}try { permissionStatus = await navigator!.permissions.query({ name: 'camera' // https://w3c.github.io/permissions/#enumdef-permissionname }) useEventListener(permissionStatus, 'change', onChange) // 有三个状态 denied&quot; | &quot;granted&quot; | &quot;prompt&quot; onChange()}catch { state.value = 'prompt'} usePreferredLanguagesnavigator.languages可以获取用户的偏好语言，可以通过languagechange事件监听改变 12345const value = ref&lt;readonly string[]&gt;(navigator.languages)useEventListener(window, 'languagechange', () =&gt; { value.value = navigator.languages}) useSharenavigator.share可以进行分享 12345678910111213const isSupported = navigator &amp;&amp; 'canShare' in navigatorif (isSupported) { granted = navigator.canShare({ // 判断是否能被分享 title?: string files?: File[] text?: string url?: string }) if (granted) return navigator.share!(data)} useWakeLockScreen Wake Lock API可以阻止设备变暗或锁屏 123456789101112const isSupported = navigator &amp;&amp; 'wakeLock' in navigatorfunction request(type: WakeLockType) { if (!isSupported) return wakeLock = await navigator.wakeLock.request(type)}function release() { if (!isSupported || !wakeLock) return await wakeLock.release() // 释放WakeLockSentinel wakeLock = null} WatchStatecreateGlobalState 用来做挂组件公共状态管理 简单的单例模式实现，effectScope的参数为true时，其不会被父scope收集和回收，独立存在 123456789101112131415export function createGlobalState&lt;T&gt;( stateFactory: () =&gt; T,): CreateGlobalStateReturn&lt;T&gt; { let initialized = false let state: T const scope = effectScope(true) return () =&gt; { if (!initialized) { state = scope.run(stateFactory)! initialized = true } return state }} useLocalStorage12345678export function useLocalStorage&lt;T extends(string|number|boolean|object|null)&gt; ( key: string, initialValue: MaybeRef&lt;T&gt;, options: StorageOptions&lt;T&gt; = {},): RemovableRef&lt;any&gt; { const { window = defaultWindow } = options return useStorage(key, initialValue, window?.localStorage, options)} 可以看到就是用useStorage来实现的，useSessionStorage也是一样，下面我们来看看useStorage useStorage在浏览器默认的Storage之上像store.js一样对数据进行预处理（序列化），否则如果存一个对象在浏览器的Storage存的会是xxx.toString()之后的值。但是useStorage比起store.js更进一步的增加了对Map和Set类型的数据的处理（Map和Set存在默认的Storage和store.js都是空对象） 利用适配器模式，对每种数据类型定义read、write 123456789101112131415161718192021222324252627282930export const StorageSerializers: Record&lt;'boolean' | 'object' | 'number' | 'any' | 'string' | 'map' | 'set', Serializer&lt;any&gt;&gt; = { boolean: { read: (v: any) =&gt; v === 'true', write: (v: any) =&gt; String(v), }, object: { read: (v: any) =&gt; JSON.parse(v), write: (v: any) =&gt; JSON.stringify(v), }, number: { read: (v: any) =&gt; Number.parseFloat(v), write: (v: any) =&gt; String(v), }, any: { read: (v: any) =&gt; v, write: (v: any) =&gt; String(v), }, string: { read: (v: any) =&gt; v, write: (v: any) =&gt; String(v), }, map: { // map序列化 read: (v: any) =&gt; new Map(JSON.parse(v)), write: (v: any) =&gt; JSON.stringify(Array.from((v as Map&lt;any, any&gt;).entries())), }, set: { // set序列化 read: (v: any) =&gt; new Set(JSON.parse(v)), write: (v: any) =&gt; JSON.stringify(Array.from((v as Set&lt;any&gt;).entries())), },} 接下来判断用户传入的数据类型，进行选择对应的read、write方法 12345678910111213141516171819const type = rawInit == null ? 'any' : rawInit instanceof Set ? 'set' : rawInit instanceof Map ? 'map' : typeof rawInit === 'boolean' ? 'boolean' : typeof rawInit === 'string' ? 'string' : typeof rawInit === 'object' ? 'object' : Array.isArray(rawInit) // 这里不太认同，typeof [] === 'object'，没必要再加这个判断了把 ? 'object' : !Number.isNaN(rawInit) ? 'number' : 'any'const serializer = options.serializer ?? StorageSerializers[type] // 用户还可以定义自己的序列化方法，但必须具有read和write方法 下面是对数据的初始化 1234567891011121314151617181920const rawInit: T = unref(initialValue) // 用户传入的初始值const data = (shallow ? shallowRef : ref)(initialValue) as Ref&lt;T&gt; // 用户可以配置是浅响应式还是深，最后会返回给用户if (!storage) returntry { const rawValue = storage.getItem(key) if (rawValue == null) { // 如果key对应的值为空，那么是首次 data.value = rawInit // 初始化值 if (writeDefaults &amp;&amp; rawInit !== null) // 用户可配置是否首次存入Storage storage.setItem(key, serializer.write(rawInit)) } else { data.value = serializer.read(rawValue) // 如果Storage存在对应值，序列化读取 }}catch (e) { onError(e) // 用户传入的错误处理函数} 然后是根据监听data的变化存入Storage，watchWithFilter可以看做是新增了eventFilter选项的watch，在后文会描述，也是vueuse很重要的一个特性 12345678910111213141516171819watchWithFilter( data, () =&gt; { try { if (data.value == null) storage.removeItem(key) else storage.setItem(key, serializer.write(data.value)) } catch (e) { onError(e) } }, { flush, // 均是用户可配置的选项 deep, eventFilter, },) 但仍有巨隐蔽的bug（哈哈哈)，为了支持响应式的存取Storage，用了ref类型的data，在同源下的多个标签的情况下，其中一个页面对另一个页面用useStorage修改了数据，但另一个页面useStorage内部的data还是原来的值 解决方式：监听storage事件（当页面使用的storage被其他页面修改时会触发） 123456789101112131415function read(event?: StorageEvent) { // 将上面初始化值的逻辑封装为read函数 if (!storage || (event &amp;&amp; event.key !== key)) return try { const rawValue = event ? event.newValue : storage.getItem(key) // 读值省略... } catch (e) { onError(e) }}if (window &amp;&amp; listenToStorageChanges) // 用户也可以配置不监听 useEventListener(window, 'storage', e =&gt; setTimeout(() =&gt; read(e), 0)) // 重新读取值给data SensorsonClickOutside1 AnimationuseRafFn 可以暂停、恢复、获取当前状态的requestAnimationFrame 1234567891011121314151617181920212223242526272829303132333435363738export function useRafFn(fn: Fn, options: RafFnOptions = {}): Pausable { const { immediate = true, window = defaultWindow, } = options const isActive = ref(false) function loop() { if (!isActive.value) return fn() if (window) window.requestAnimationFrame(loop) } function resume() { if (!isActive.value) { // 如果是非活跃状态才可以恢复 isActive.value = true loop() } } function pause() { isActive.value = false // 暂停就直接设置为false，在loop中如果false则直接跳过fn执行 } if (immediate) resume() tryOnScopeDispose(pause) return { isActive, pause, resume, }} 留有疑问：为什么pause中不用cancelAnimationFrame来取消requestAnimationFrame useTransition可配置项 123456789101112131415161718type CubicBezierPoints = [number, number, number, number]type EasingFunction = (n: number) =&gt; numberexport function useTransition( source: Ref&lt;number | number[]&gt; | MaybeRef&lt;number&gt;[], options: TransitionOptions = {},): ComputedRef&lt;any&gt; { const { // 时间相关单位均为ms delay = 0, // delay 后执行 disabled = false, // 是否关闭 duration = 1000, // 持续时间 onFinished = noop, // 完成后执行 onStarted = noop, // 开始时执行 transition = linear, // 转化算法 MaybeRef&lt;EasingFunction | CubicBezierPoints&gt;，默认值是 x =&gt; x } = options // ...} 预处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export function useTransition( source: Ref&lt;number | number[]&gt; | MaybeRef&lt;number&gt;[], options: TransitionOptions = {},): ComputedRef&lt;any&gt; { // 可配置项 // 创建当前的过渡函数，如果用户自定义了过渡函数则不做处理，否则根据贝赛尔曲线值创建过渡函数 const currentTransition = computed(() =&gt; { const t = unref(transition) return isFunction(t) ? t : createEasingFunction(t) }) // 用unref处理source参数，如果source是数组则依次unref const sourceValue = computed(() =&gt; { const s = unref&lt;number | MaybeRef&lt;number&gt;[]&gt;(source) return isNumber(s) ? s : s.map(unref) as number[] }) // 规格化source，整成数组 const sourceVector = computed(() =&gt; isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value) // ...}// 创建过渡函数，纯数学function createEasingFunction([p0, p1, p2, p3]: CubicBezierPoints): EasingFunction { const a = (a1: number, a2: number) =&gt; 1 - 3 * a2 + 3 * a1 const b = (a1: number, a2: number) =&gt; 3 * a2 - 6 * a1 const c = (a1: number) =&gt; 3 * a1 const calcBezier = (t: number, a1: number, a2: number) =&gt; ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t const getSlope = (t: number, a1: number, a2: number) =&gt; 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1) const getTforX = (x: number) =&gt; { let aGuessT = x for (let i = 0; i &lt; 4; ++i) { const currentSlope = getSlope(aGuessT, p0, p2) if (currentSlope === 0) return aGuessT const currentX = calcBezier(aGuessT, p0, p2) - x aGuessT -= currentX / currentSlope } return aGuessT } return (x: number) =&gt; p0 === p1 &amp;&amp; p2 === p3 ? x : calcBezier(getTforX(x), p1, p3)} 提供了几种过渡预设 12345export const TransitionPresets: Record&lt;string, CubicBezierPoints | EasingFunction&gt; = { easeInSine: [0.12, 0, 0.39, 0], easeOutSine: [0.61, 1, 0.88, 1], // ...} 详情可以看 缓动函数、 MDN：缓动函数 关键逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344const outputVector = ref(sourceVector.value.slice(0)) // 用以存储输出// 过渡主流程，可以暂停const { resume, pause } = useRafFn(() =&gt; { // 可以暂停、恢复的 requestAnimationFrame const now = Date.now() const progress = clamp(1 - ((endAt - now) / currentDuration), 0, 1) // 过渡进度，clamp将值限制在0-1之间 outputVector.value = startVector.map((val, i) =&gt; val + ((diffVector[i] ?? 0) * currentTransition.value(progress))) // 更新output if (progress &gt;= 1) { // 完成过渡 pause() // 暂停 requestAnimationFrame onFinished() // 执行options中的完成回调 }}, { immediate: false })const timeout = useTimeoutFn(start, delay, { immediate: false }) // delay毫秒后执行start函数const start = () =&gt; { pause() // 暂停 过渡 currentDuration = unref(duration) diffVector = outputVector.value.map((n, i) =&gt; (sourceVector.value[i] ?? 0) - (outputVector.value[i] ?? 0)) // 初始值和当前值的diff startVector = outputVector.value.slice(0) // 拷贝初始值 startAt = Date.now() // 开始时间 endAt = startAt + currentDuration // 结束时间，用在计算progress resume() // 开始过渡 onStarted() // 执行options中的开始回调}watch(sourceVector, () =&gt; { // 监听sourceVector的变化 if (unref(disabled)) { // 如果暂停过渡，将输出还原回初始值 outputVector.value = sourceVector.value.slice(0) } else { if (unref(delay) &lt;= 0) start() // 如果没有延迟，则开始过渡 else timeout.start() // 如果有延迟，则开始上面创建好的timeout }}, { deep: true })return computed(() =&gt; { const targetVector = unref(disabled) ? sourceVector : outputVector // 如果暂停过渡，将输出还原回初始值 return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value // 为值解开数组包装，数组原样返回}) 未完待续。。。","link":"/2021/12/11/Vue/vueuse%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"【源码解读】模块懒加载(在使用时)","text":"在看为什么vue文档能做到新内容可用更新（利用service worker）的时候，顺便看到了update-notifier（提示版本更新的库，实现方式：定时检查npm上的版本和本地package.json的版本对比，有差异就提示用户更新），看update-notifier源码的时候发现有很多lazyImport，觉得挺新奇，于是有了这篇文章 思想为了提高应用的启动时间，在没有用到仓库的额外功能时不加载模块，所以将模块加载延迟到使用之前 使用方式1234const importLazy = require('import-lazy')(require);const _ = importLazy('lodash');_.isNumber(2); // 在使用的时候才触发模块加载 实现方式实际上是用proxy代理了get操作，在get的时候才触发模块加载 1234567891011121314151617181920212223242526const lazy = (importedModule, importFn, moduleId) =&gt; importedModule === undefined ? importFn(moduleId) : importedModule;module.exports = importFn =&gt; { return moduleId =&gt; { let importedModule; const handler = { get: (target, property) =&gt; { importedModule = lazy(importedModule, importFn, moduleId); return Reflect.get(importedModule, property); }, apply: (target, thisArgument, argumentsList) =&gt; { importedModule = lazy(importedModule, importFn, moduleId); return Reflect.apply(importedModule, thisArgument, argumentsList); }, construct: (target, argumentsList) =&gt; { importedModule = lazy(importedModule, importFn, moduleId); return Reflect.construct(importedModule, argumentsList); } }; // eslint-disable-next-line prefer-arrow-callback return new Proxy(function () {}, handler); };}; 这也导致我们在使用import-lazy的时候不能按需加载 1const {isNumber, isString} = importLazy('lodash'); // 不支持","link":"/2021/09/23/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E5%9D%97%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"title":"跨平台的拖拽","text":"crossvent：封装跨平台事件绑定的库 跨平台的触摸事件利用crossvent封装绑定跨平台拖拽事件的方法touchy，以便支持移动端和pc端 根据环境获取的触摸事件名，用懒加载的方式替换掉touchy函数，之后绑定事件不需要再判断 1234567891011121314151617181920212223242526272829303132333435import { add as addEvent } from 'crossvent';let touchy = function (el, type, fn) { const touch = { mouseup: 'touchend', mousedown: 'touchstart', mousemove: 'touchmove' }; const pointers = { mouseup: 'pointerup', mousedown: 'pointerdown', mousemove: 'pointermove' }; const microsoft = { mouseup: 'MSPointerUp', mousedown: 'MSPointerDown', mousemove: 'MSPointerMove' }; if (window.navigator.pointerEnabled) { touchy = function (el, type, fn) { addEvent(el, pointers[type], fn); }; } else if (window.navigator.msPointerEnabled) { touchy = function (el, type, fn) { addEvent(el, microsoft[type], fn); }; } else { touchy = function (el, type, fn) { addEvent(el, touch[type], fn); addEvent(el, type, fn); }; } touchy(el, type, fn);}; 初始化事件 12345678910111213const documentElement = document.documentElement;function draggable (dom) { initEvents(); function initEvents () { touchy(dom, 'mousedown', mousedown); touchy(documentElement, 'mousemove', mousemove); touchy(documentElement, 'mouseup', mouseup); } //...} 这里在documentElement上绑定mousemove和mouseup事件，是因为避免渲染速度低于拖拽速度，导致鼠标超出拖拽范围而无法拖拽和释放 这里提一下绑定事件时有一个passive选项，具体可以查看 使用 passive 改善的滚屏性能，可以设置为false，使事件回调可以使用e.preventDefault禁用默认的行为 mousedown123456function mousedown (e) { active = true; e = getEventHost(e); _moveX = e.clientX; _moveY = e.clientY;} 在documentElement上绑定mousemove和mouseup事件，所以需要标记是否是处于拖拽状态，然后mousemove和mouseup中判断如果不是拖拽状态则跳出函数。 为了适配移动端（touchEvent没有clientX、clientY、x、y），引出了getEventHost 123456789function getEventHost (e) { if (e.targetTouches &amp;&amp; e.targetTouches.length) { return e.targetTouches[0]; } if (e.changedTouches &amp;&amp; e.changedTouches.length) { return e.changedTouches[0]; } return e;} 我们看看touch、targetTouches、changedTouches的定义 touches: 当前屏幕上所有触摸点的列表 targetTouches: 当前对象上所有触摸点的列表 changedTouches: 涉及当前(引发)事件的触摸点的列表 mousemove这里实现的是可拖拽范围为document的可视区域 12345678910111213141516171819function mousemove (e) { if (!active) { // 如果不是出于拖拽状态直接放回 return; } e = getEventHost(e); const { x, y, height, width } = dom.getBoundingClientRect(); const curLeft = x + e.clientX - _moveX; const curTop = y + e.clientY - _moveY; dom.style.left = `${clamp(curLeft, 0, documentElement.clientWidth - width - 1)}px`; dom.style.top = `${clamp(curTop, 0, documentElement.clientHeight - height)}px`; _moveX = e.clientX; _moveY = e.clientY;}// 将value限制在[min, max]之间function clamp (value, min, max) { return Math.min(Math.max(value, min), max);} mouseup123function mouseup () { active = false;} 总结我们可以自定义mousemove的行为，但整体的框架不会变","link":"/2021/09/12/Js/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8B%96%E6%8B%BD/"},{"title":"【源码解读】Axios源码解析","text":"工具类bind123456789function bind(fn, thisArg) { return function wrap() { var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) { args[i] = arguments[i]; } return fn.apply(thisArg, args); };}; extend12345678910function extend(a, b, thisArg) { forEach(b, function assignValue(val, key) { if (thisArg &amp;&amp; typeof val === 'function') { a[key] = bind(val, thisArg); } else { a[key] = val; } }); return a;} merge12345678910111213141516171819function merge(/* obj1, obj2, obj3, ... */) { var result = {}; function assignValue(val, key) { if (isPlainObject(result[key]) &amp;&amp; isPlainObject(val)) { result[key] = merge(result[key], val); } else if (isPlainObject(val)) { result[key] = merge({}, val); } else if (isArray(val)) { result[key] = val.slice(); } else { result[key] = val; } } for (var i = 0, l = arguments.length; i &lt; l; i++) { forEach(arguments[i], assignValue); } return result;} 从使用方式看起对几种调用方式做了编号 axios(option) axios(url[, option]) axios[method](url[, option])（get、delete等方法） axios[method](url[, data[, option]])（post、put等方法） axios.request(option) 让我们看看源码他是怎么做到能够支持这么多调用方式的 1234567891011121314151617181920212223// /lib/axios.jsfunction createInstance(defaultConfig) { var context = new Axios(defaultConfig); // 等同于 Axios.prototype.request.bind(context) // request方法中对第一个参数是否为 string 做了判断，使支持1、2种调用方式 var instance = bind(Axios.prototype.request, context); // 把Axios.prototype上的方法扩展到instance对象上， // 这样 instance 就有了 get、post、put、request等方法，使支持3、4、5调用方式 // 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context utils.extend(instance, Axios.prototype, context); // 把context对象上的自身属性和方法扩展到instance上 // 这样，instance 就有了 defaults、interceptors 属性。（这两个属性后面我们会介绍） utils.extend(instance, context); return instance;}// 接收默认配置项作为参数（后面会介绍配置项），创建一个Axios实例，最终会被作为对象导出var axios = createInstance(defaults); 主要是为了能够做到1、2种调用方式，所以是返回request函数，并在其上挂载Axios实例的方法 接下来看看上述代码操作的主体：Axios、Axios.prototype.request 以及 Axios.prototype上的请求方法 1234567891011121314151617181920212223242526272829303132333435363738// /lib/core/Axios.jsfunction Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };}Axios.prototype.request = function request(config) { if (typeof config === 'string') { // 使支持1、2两种调用方式 config = arguments[1] || {}; config.url = arguments[0]; } else { config = config || {}; } // ...};// Provide aliases for supported request methodsutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { Axios.prototype[method] = function(url, config) { return this.request(mergeConfig(config || {}, { method: method, url: url, data: (config || {}).data })); };});utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { Axios.prototype[method] = function(url, data, config) { return this.request(mergeConfig(config || {}, { method: method, url: url, data: data })); };}); 结合上面createInstance的代码，我们可以看到为什么我们可以使用多种方式调用axios 我们先不看具体请求逻辑是怎么实现的，先看看拦截器是怎么做到在请求前后预处理的。 拦截器（interceptor）在上文Axios的构造器中我们可以看到 1234this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager()}; InterceptorManager类用以管理拦截器 InterceptorManager类123456789101112131415161718192021222324252627282930function InterceptorManager() { this.handlers = []; // 存储拦截器函数}// 用以添加拦截器InterceptorManager.prototype.use = function use(fulfilled, rejected, options) { this.handlers.push({ fulfilled: fulfilled, rejected: rejected, synchronous: options ? options.synchronous : false, // 是否是同步执行 runWhen: options ? options.runWhen : null // 指定拦截器在某种情况下执行 }); return this.handlers.length - 1;};// 删除拦截器InterceptorManager.prototype.eject = function eject(id) { if (this.handlers[id]) { this.handlers[id] = null; }};// 将handler的每一项交由fn处理InterceptorManager.prototype.forEach = function forEach(fn) { utils.forEach(this.handlers, function forEachHandler(h) { if (h !== null) { fn(h); } });}; request中InterceptorManager使用方式123456789101112131415161718192021222324252627282930313233343536373839404142Axios.prototype.request = function request(config) { // 这里有合并 config 的操作，优先级是 defaults -&gt; { method: &quot;get&quot; } -&gt; this.defaults -&gt; config // 也就是 库默认的配置 -&gt; 默认为get请求 -&gt; 创建Axios实例设置的配置 -&gt; 请求的配置 var requestInterceptorChain = []; // 请求拦截器链 this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { // 无法通过runWhen条件的则不执行 if (typeof interceptor.runWhen === 'function' &amp;&amp; interceptor.runWhen(config) === false) { return; } // 以 fulfilled、rejected 成对unshift到 requestInterceptorChain requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected); }); var responseInterceptorChain = []; // 响应拦截器链 this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { // 以 fulfilled、rejected 成对unshift到 responseInterceptorChain responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected); }); var promise; // dispatchRequest是发送请求，第二个undefined是为了符合提取方式的占位值 var chain = [dispatchRequest, undefined]; // 将 请求拦截器 放置在dispatchRequest前面 Array.prototype.unshift.apply(chain, requestInterceptorChain); // 将 响应拦截器 放置在dispatchRequest后面 chain.concat(responseInterceptorChain); // 通过此方式将config传入到请求拦截器的第一个fulfilled promise = Promise.resolve(config); while (chain.length) { // 因为在chain中fulfilled、rejected是成对存在的 // 而 请求拦截器 必须返回config，下一个 请求拦截器 就会接受上一个config // 响应拦截器 会接受 dispatchRequest 的响应体或错误 promise = promise.then(chain.shift(), chain.shift()); } return promise;} 大致流程就是如此 synchronous但是axios还为请求拦截器提供了synchronous选项，需要全部请求拦截器设置synchronous为true，那么就以同步的方式运行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Axios.prototype.request = function request(config) { // ... var requestInterceptorChain = []; // 新增：用以标记是否是同步执行请求拦截器 var synchronousRequestInterceptors = true; this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { if (typeof interceptor.runWhen === 'function' &amp;&amp; interceptor.runWhen(config) === false) { return; } // 新增：需要 全部请求拦截器 设置synchronous成true才会同步执行 synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous; requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected); }); var responseInterceptorChain = []; this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected); }); var promise; // 新增：默认是异步的方式执行 if (!synchronousRequestInterceptors) { var chain = [dispatchRequest, undefined]; Array.prototype.unshift.apply(chain, requestInterceptorChain); chain.concat(responseInterceptorChain); promise = Promise.resolve(config); while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); } return promise; } // 新增：同步的方式执行请求拦截器 var newConfig = config; while (requestInterceptorChain.length) { var onFulfilled = requestInterceptorChain.shift(); var onRejected = requestInterceptorChain.shift(); try { newConfig = onFulfilled(newConfig); } catch (error) { onRejected(error); break; } } try { promise = dispatchRequest(newConfig); } catch (error) { return Promise.reject(error); } while (responseInterceptorChain.length) { promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift()); } return promise;}; 启发：链式调用1234new Man(&quot;Hank&quot;).sleep(1).eat(&quot;supper&quot;).sleep(1).eat(&quot;me&quot;).sleepFirst(2);// 打印结果// 'This is Hank' -(等待2s)--&gt; 'Wale up after 2' -(等待1s)--&gt; 'Wale up after 1' 'Eat supper' -(等待1s)--&gt; 'Eat me' 写法放在文末 发起请求dispatchRequest在拿到请求拦截器处理后的config后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// /lib/core/dispatchRequest.jsfunction dispatchRequest(config) { // 1.请求如果被取消则 throw cancel Error throwIfCancellationRequested(config); // 2.确保headers存在 config.headers = config.headers || {}; // 3.后面会讲：数据转化器转化请求data，也可以在config自定义配置transformRequest config.data = transformData.call( config, config.data, config.headers, config.transformRequest ); // 4.扁平header设置，这里可以利用config.headers.get = {}设置某种请求类型的headers config.headers = utils.merge( config.headers.common || {}, config.headers[config.method] || {}, config.headers ); // 5.删除无用header，因为在第四步时扁平化定义在headers了 utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) { delete config.headers[method]; } ); // 可以自定义适配器，默认为XHR（web）或http（node）适配器 var adapter = config.adapter || defaults.adapter; return adapter(config).then(function onAdapterResolution(response) { // ... return response; }, function onAdapterRejection(reason) { // ... return Promise.reject(reason); });};function throwIfCancellationRequested(config) { if (config.cancelToken) { config.cancelToken.throwIfRequested(); }} 跨端实现（adapter）适配器模式 是否有XMLHttpRequest对象来判断是否是web环境 是否有process对象来判断node环境 12345678910// /lib/defaults.jsfunction getDefaultAdapter() { var adapter; if (typeof XMLHttpRequest !== 'undefined') { adapter = require('./adapters/xhr'); } else if (typeof process !== 'undefined' &amp;&amp; Object.prototype.toString.call(process) === '[object process]') { adapter = require('./adapters/http'); } return adapter;} 封装xhr返回一个promise 123456789101112131415161718192021222324252627282930// /lib/adapters/xhr.jsfunction xhrAdapter(config) { return new Promise(function dispatchXhrRequest(resolve, reject) { // ... var request = new XMLHttpRequest(); var fullPath = buildFullPath(config.baseURL, config.url); // buildURL: 格式化url; config.paramsSerializer: 序列化方式； request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); request.timeout = config.timeout; request.onloadend = function onloadend() { // ... settle(resolve, reject, response); // 下面有代码 request = null; }; request.onabort = function handleError() { reject(/**/); request = null; }; request.onerror = function handleError() { reject(/**/); request = null; }; request.ontimeout = function handleTimeout() { reject(/**/); request = null; }; request.send(requestData); });}; 验证服务端的返回结果是否通过验证： 123456789// /lib/core/settle.jsfunction settle(resolve, reject, response) { var validateStatus = response.config.validateStatus; // 可以自定义成功规则 if (!response.status || !validateStatus || validateStatus(response.status)) { resolve(response); } else { reject(/**/); }}; 同理将http封装成promise 取消请求（cancelToken）如何使用12345678910111213141516171819import axios from 'axios'// 第一种取消方法axios.get(url, { cancelToken: new axios.CancelToken(cancel =&gt; { if (/* 取消条件 */) { cancel('取消日志'); } })});// 第二种取消方法const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get(url, { cancelToken: source.token});source.cancel('取消日志'); 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344function CancelToken(executor) { if (typeof executor !== 'function') { throw new TypeError('executor must be a function.'); } var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) { resolvePromise = resolve; }); var token = this; executor(function cancel(message) { // 等到executor调用cancel方法，上面的this.promise就会执行下面的then回调 if (token.reason) { return; } token.reason = new Cancel(message); resolvePromise(token.reason); });}// 第二种方法的实现CancelToken.source = function source() { var cancel; var token = new CancelToken(function executor(c) { cancel = c; }); return { token: token, cancel: cancel };};// /lib/adapters/xhr.js 在send之前执行if (config.cancelToken) { config.cancelToken.promise.then(function onCanceled(cancel) { if (!request) { return; } request.abort(); // xhr的取消请求 reject(cancel); request = null; });} 启发链式调用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Man { constructor (name) { this.name = name; this.arr = []; console.log(`This is ${name}`); const executor = i =&gt; { if (i &lt; this.arr.length) { this.arr[i]().then(value =&gt; { console.log(value); executor(i + 1); }); } } Promise.resolve().then(()=&gt; { executor(0) }, 0); } sleep(sec) { this.arr.push(() =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(`Wale up after ${sec}`); }, sec * 1000); }) }) return this; } eat(food) { this.arr.push(() =&gt; { return Promise.resolve(`Eat ${food}`); }) return this; } sleepFirst(sec) { this.arr.unshift(() =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(`Wale up after ${sec}`); }, sec * 1000); }) }) return this; }} 参考Axios源码深度剖析","link":"/2021/08/25/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"egg入门","text":"快速初始化用npm 1npm init egg --type=simple 目录结构12345678910111213141516171819202122232425262728293031323334353637egg-project├── package.json├── app.js (可选) # 用于自定义启动时的初始化工作├── agent.js (可选) # 用于自定义启动时的初始化工作├── app| ├── router.js # 用于配置 URL 路由规则│ ├── controller # 用于解析用户的输入，处理后返回相应的结果│ | └── home.js│ ├── service (可选) # 用于编写业务逻辑层│ | └── user.js│ ├── middleware (可选) # 用于编写中间件│ | └── response_time.js│ ├── schedule (可选) # 用于定时任务│ | └── my_task.js│ ├── public (可选) # 用于放置静态资源│ | └── reset.css│ ├── view (可选) # 用于放置模板文件│ | └── home.tpl│ └── extend (可选) # 用于框架的扩展│ ├── helper.js (可选)│ ├── request.js (可选)│ ├── response.js (可选)│ ├── context.js (可选)│ ├── application.js (可选)│ └── agent.js (可选)├── config # 用于编写配置文件| ├── plugin.js # 用于配置需要加载的插件| ├── config.default.js│ ├── config.prod.js| ├── config.test.js (可选)| ├── config.local.js (可选)| └── config.unittest.js (可选)└── test # 用于单元测试 ├── middleware | └── response_time.test.js └── controller └── home.test.js 路由（Router） 将用户的请求基于 method 和 URL 分发到了对应的 Controller 上，感觉api和Koa差不多。 参数获取query就列一个query参数的获取，需要注意的是，app.controller.search与文件相对应（也就是app/controller/search.js） 1234567891011// curl http://127.0.0.1:7001/search?name=egg// app/router.jsmodule.exports = app =&gt; { app.router.get('/search', app.controller.search.index);};// app/controller/search.jsexports.index = async ctx =&gt; { ctx.body = `search: ${ctx.query.name}`; }; 为了避免用户恶意传递重复key的query参数导致系统报错，ctx.query只取第一次出现的值，并且保证一定是字符串类型 如果必须要重复的key，比如需要传递数组：id=1&amp;id=2&amp;id=3，可以用ctx.queries，其也保证了一定是数组类型 body框架内置了 bodyParser 中间件来对JSON和Form-Data的请求 body 解析成 object 挂载到 ctx.request.body 上。 body 最大长度为 100kb，超出长度413状态码，可以在 config/config.default.js 中覆盖框架的默认值 123456module.exports = { bodyParser: { jsonLimit: '1mb', formLimit: '1mb', },}; ctx.body是ctx.response.body的简写 header可以通过ctx.get(name)获取，其会自动处理大小写 Cookie获取、设置方式和Koa一样，配置方式如下 123456module.exports = { cookies: { // httpOnly: true | false, // sameSite: 'none|lax|strict', },}; Session框架内置 Session 插件，可以通过ctx.session，具体配置可以看 Cookie 与 Session 参数校验借助 Validate 插件提供便捷的参数校验机制，配置方式如下 12345// config/plugin.jsexports.validate = { enable: true, package: 'egg-validate',}; ctx上有一个validate方法，可以传入校验配置来对参数进行校验 1234567891011121314151617181920212223// curl -X POST http://127.0.0.1:7001/user --data 'username=abc@abc.com&amp;password=111111&amp;re-password=111111'// app/router.jsmodule.exports = app =&gt; { app.router.post('/user', app.controller.user);};// app/controller/user.jsconst createRule = { username: { type: 'email', }, password: { type: 'password', compare: 're-password', // 与re-password比较，是否一致 },};exports.create = async ctx =&gt; { // 如果校验报错，会抛出异常 ctx.validate(createRule); ctx.body = ctx.request.body;}; 重定向内部重定向1app.router.redirect('/', '/home/index', 302); 外部重定向1ctx.redirect(`http://cn.bing.com`); resources生成CRUD路由结构12345// app/router.jsmodule.exports = app =&gt; { const { router, controller } = app; router.resources('posts', '/api/posts', controller.posts);}; 接下来在对应文件下实现对应函数就可以了 1234567891011121314// app/controller/posts.jsexports.index = async () =&gt; {};exports.new = async () =&gt; {};exports.create = async () =&gt; {};exports.show = async () =&gt; {};exports.edit = async () =&gt; {};exports.update = async () =&gt; {};exports.destroy = async () =&gt; {}; Method Path Route Name Controller.Action GET /posts posts app.controllers.posts.index GET /posts/new new_post app.controllers.posts.new GET /posts/:id post app.controllers.posts.show GET /posts/:id/edit edit_post app.controllers.posts.edit POST /posts posts app.controllers.posts.create PUT /posts/:id post app.controllers.posts.update DELETE /posts/:id post app.controllers.posts.destroy 模块化123456789101112131415// app/router.jsmodule.exports = app =&gt; { require('./router/news')(app); require('./router/admin')(app);};// app/router/news.jsmodule.exports = app =&gt; { app.router.get('/news/list', app.controller.news.list);};// app/router/admin.jsmodule.exports = app =&gt; { app.router.get('/admin/user', app.controller.admin.user);}; 控制器（Controller） 解析用户的输入，处理后返回相应的结果，框架建议在 controller 对请求参数进行处理（校验、转换），然后调用对应的 service 方法处理业务 12345678910111213141516171819202122232425// app/controller/post.jsconst Controller = require('egg').Controller;class PostController extends Controller { async create() { const { ctx, service } = this; const createRule = { title: { type: 'string' }, content: { type: 'string' }, }; // 校验参数 ctx.validate(createRule); // 组装参数 const author = ctx.session.userId; const req = Object.assign(ctx.request.body, { author }); // 调用 Service 进行业务处理 const res = await service.post.create(req); // 设置响应内容和响应状态码 ctx.body = { id: res.id }; ctx.status = 201; }}module.exports = PostController; 获取上传的文件file模式在config中配置file模式 1234// config/config.default.jsexports.multipart = { mode: 'file',}; controller层代码 123456789101112131415161718192021222324252627// app/controller/upload.jsconst Controller = require('egg').Controller;const fs = require('mz/fs');module.exports = class extends Controller { async upload() { const { ctx } = this; console.log(ctx.request.body); console.log('got %d files', ctx.request.files.length); for (const file of ctx.request.files) { // files获取上传的多文件 console.log('field: ' + file.fieldname); console.log('filename: ' + file.filename); console.log('encoding: ' + file.encoding); console.log('mime: ' + file.mime); console.log('tmp filepath: ' + file.filepath); let result; try { // 处理文件，比如上传到云端 result = await ctx.oss.put('egg-multipart-test/' + file.filename, file.filepath); } finally { // 需要删除临时文件 await fs.unlink(file.filepath); } console.log(result); } }}; stream模式12345678910111213141516171819202122232425262728const path = require('path');const sendToWormhole = require('stream-wormhole');const Controller = require('egg').Controller;class UploaderController extends Controller { async upload() { const ctx = this.ctx; const stream = await ctx.getFileStream(); const name = 'egg-multipart-test/' + path.basename(stream.filename); // 文件处理，上传到云存储等等 let result; try { result = await ctx.oss.put(name, stream); } catch (err) { // 必须将上传的文件流消费掉，要不然浏览器响应会卡死 await sendToWormhole(stream); throw err; } ctx.body = { url: result.url, // 所有表单字段都能通过 `stream.fields` 获取到 fields: stream.fields, }; }}module.exports = UploaderController; Service层其不是单例，在每次请求时访问ctx.service.xx 时延迟实例化，所以可以用this.ctx获取每一次请求的上下文 1234567891011// app/service/user.jsconst Service = require('egg').Service;class UserService extends Service { async find(uid) { const user = await this.ctx.db.query('select * from user where uid = ?', uid); return user; }}module.exports = UserService; 函数return的值会返回给前端 定时任务所有的定时任务都统一存放在 app/schedule 目录下 123456789101112131415161718192021const Subscription = require('egg').Subscription;class UpdateCache extends Subscription { // 通过 schedule 属性来设置定时任务的执行间隔等配置 static get schedule() { return { interval: '1m', // 1 分钟间隔 type: 'all', // 指定所有的 worker 都需要执行 }; } // subscribe 是真正定时任务执行时被运行的函数 async subscribe() { const res = await this.ctx.curl('http://www.api.com/cache', { dataType: 'json', }); this.ctx.app.cache = res.data; }}module.exports = UpdateCache; 还可以简写为 123456789101112module.exports = { schedule: { interval: '1m', // 1 分钟间隔 type: 'all', // 指定所有的 worker 都需要执行 }, async task(ctx) { const res = await ctx.curl('http://www.api.com/cache', { dataType: 'json', }); ctx.app.cache = res.data; },}; 没有用过，具体配置看官方文档 定时任务 egg-mysql安装与配置1npm i --save egg-mysql 开启插件 12345// config/plugin.jsexports.mysql = { enable: true, package: 'egg-mysql',}; 数据库配置 123456789101112131415161718192021222324252627// config/config.${env}.jsexports.mysql = { // 单数据库信息配置 clients: { // clientId, 获取client实例，需要通过 app.mysql.get('clientId') 获取 db1: { host: 'mysql.com', port: '3306', user: 'test_user', password: 'test_password', database: 'test', }, db2: { host: 'mysql2.com', port: '3307', user: 'test_user', password: 'test_password', database: 'test', }, } // 所有数据库配置的默认值 default: {}, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false,}; 使用方式：12345const client1 = app.mysql.get('db1');await client1.query(sql, values);const client2 = app.mysql.get('db2');await client2.query(sql, values);","link":"/2021/07/18/node.js/egg%E5%85%A5%E9%97%A8/"},{"title":"redux入门","text":"Redux 官方文档对 Redux 的定义是：一个可预测的 JavaScript 应用状态管理容器 安装1npm install --save redux Store Redux应用只有单一的 store 通过createStore()创建一个store 123import { createStore } from 'redux'import todoApp from './reducers' // 这个在下面会讲let store = createStore(todoApp) createStore()的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。 提供四个函数 getState()方法获取 state dispatch(action)方法分发 action 更新 state subscribe(listener)注册监听器，返回的函数注销监听器 replaceReducer(nextReducer) 一般在 Webpack Code-Splitting 按需加载的时候用 redux规定禁止直接修改 state，也就是下面的写法 12var state = store.getState()state.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state 只能通过 dispatch 一个 action 来修改 Action是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。 1 Action格式除了type字段外，action的结构完全由你自己决定，一般参照 Flux 标准 Action 获取关于如何构造 action 的建议。 123456const ADD_TODO = 'ADD_TODO'// 下面是常见的action格式{ type: ADD_TODO, text: 'Build my first Redux app'} 2 Action创建函数就是生成action的方法 123456function addTodo(text) { return { type: ADD_TODO, text }} 3 dispatch只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程 1dispatch(addTodo(text)) Reducer指定了应用状态的变化如何响应 actions 并发送状态到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。 reducer就是一个纯函数，接收旧的 state 和 action，返回新的 state。 1;(previousState, action) =&gt; newState 123456789101112131415161718192021222324var initState = { counter: 0, todos: []}function reducer(state, action) { // 应用的初始状态是在第一次执行 reducer 时设置的 ※ if (!state) state = initState switch (action.type) { case 'ADD_TODO': var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆 nextState.todos.push(action.payload) return nextState case 'ADD_COUNT': return Object.assign({}, state, { visibilityFilter: action.filter }) default: // 由于 nextState 会把原 state 整个替换掉 // 若无修改，必须返回原 state（否则就是 undefined） return state }} 注意： 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值 在 default 情况下返回旧的 state。否则 state 会变成undefined 拆分Reducer当业务逻辑复杂时，所有状态聚合在一个reducer函数里处理，逻辑会变得相当复杂。 我们可以提出一个主reducer函数，它调用多个子 reducer 分别处理子 state 中的数据，然后再把这些数据合成一个大的单一对象。 主 reducer 并不需要设置初始化时完整的 state。初始时，如果传入 undefined, 子 reducer 将负责返回它们的默认值 12345678910111213141516171819202122232425262728293031323334353637383940function todos(state = [], action) { switch (action.type) { case ADD_TODO: return [ ...state, { text: action.text, completed: false } ] case TOGGLE_TODO: return state.map((todo, index) =&gt; { if (index === action.index) { return Object.assign({}, todo, { completed: !todo.completed }) } return todo }) default: return state }}function visibilityFilter(state = SHOW_ALL, action) { switch (action.type) { case SET_VISIBILITY_FILTER: return action.filter default: return state }}// 主reducerfunction todoApp(state = {}, action) { return { visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) }} 可以利用combineReducers()来简化代码 12345678import { combineReducers } from 'redux'const todoApp = combineReducers({ visibilityFilter, a: todos})export default todoApp 注意上面的写法和下面完全等价： 123456export default function todoApp(state = {}, action) { return { visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) }} 异步数据流如果只是简单的redux store是不支持用dispatch异步更新store，可以使用react-thunk来增强 安装1npm install redux-thunk 使用applyMiddleware引入中间件 与Koa和Express类似，redux也提供了注册中间件的方法：applyMiddleware，这个中间件执行时间是在dispatch一个action之后，到达reducer之前，执行顺序是从上到下，传递action 12345678910import thunk from 'redux-thunk'import { createStore, applyMiddleware } from 'redux'import rootReducer from './reducers'const store = createStore( rootReducer, applyMiddleware( thunk, // 允许我们 dispatch() 函数 )) 动机引入后允许我们dispatch一个函数，这个函数内部可以dispatch，这个函数接受两个参数，第一个是dispatch，第二个是getState，函数内部允许放一些异步操作，来解决redux只能同步dispatch(action)的问题 react-thunk 源码出乎意料的简单 1234567891011121314function createThunkMiddleware(extraArgument) { return ({ dispatch, getState }) =&gt; (next) =&gt; (action) =&gt; { if (typeof action === 'function') { // 如果是函数，当作函数执行 return action(dispatch, getState, extraArgument); } return next(action); };}const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 当然我们也可以用redux-promise这个中间件来dispatch一个promise redux-promise 源码1234567891011121314151617181920import isPromise from 'is-promise';import { isFSA } from 'flux-standard-action';export default function promiseMiddleware({ dispatch }) { return next =&gt; action =&gt; { // 判断是不是 flux 标准的action if (!isFSA(action)) { return isPromise(action) ? action.then(dispatch) : next(action); } return isPromise(action.payload) ? action.payload .then(result =&gt; dispatch({ ...action, payload: result })) .catch(error =&gt; { dispatch({ ...action, payload: error, error: true }); return Promise.reject(error); }) : next(action); };} 与react配合使用安装1npm install --save react-redux 使用方式利用 Provider 组件分发store状态 12345678910// ...import store from './app/store'import { Provider } from 'react-redux'ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 在组件中使用useSelector，useDispatch来获取 state 和分发 action 1234567891011121314151617181920// ...import { useSelector, useDispatch } from 'react-redux'import { decrement, increment } from './counterSlice'export function Counter() { const count = useSelector((state) =&gt; state.counter.value) // 从state中获取count的值 const dispatch = useDispatch() // 获取dispatch方法 return ( &lt;div&gt; &lt;button onClick={() =&gt; dispatch(increment())}&gt; Increment &lt;/button&gt; &lt;span&gt;{count}&lt;/span&gt; &lt;button onClick={() =&gt; dispatch(decrement())}&gt; Decrement &lt;/button&gt; &lt;/div&gt; )} 或者用connect函数包裹组件，将state和dispatch映射到props中 1connect(mapStateToProps, mapDispatchToProps)(MyComponent) 1234567891011121314151617181920212223242526272829303132const mapStateToProps = (state) =&gt; { return { // prop : state.xxx | 意思是将state中的某个数据映射到props中 foo: state.bar }}const mapDispatchToProps = (dispatch) =&gt; { // 默认传递参数就是dispatch return { onClick: () =&gt; { dispatch({ type: 'increatment' }); } };}class Foo extends Component { constructor(props){ super(props); } render () { return ( &lt;&gt; &lt;div&gt;this.props.foo&lt;/div&gt; &lt;button onClick = {this.props.onClick}&gt;点击increase&lt;/button&gt; &lt;/&gt; ) }}Foo = connect(mapStateToProps, mapDispatchToProps)(Foo);export default Foo; 同步react-router安装1npm install --save connected-react-router 使用1.创建一个以history作为参数，返回根reducer的函数 123456789// reducers.jsimport { combineReducers } from 'redux'import { connectRouter } from 'connected-react-router'const createRootReducer = (history) =&gt; combineReducers({ router: connectRouter(history), ... // rest of your reducers})export default createRootReducer; 2.创建一个history对象，将这个对象给上述的reducer和createRootReducer 12345678910111213141516171819202122// configureStore.jsimport { createBrowserHistory } from 'history'import { applyMiddleware, compose, createStore } from 'redux'import { routerMiddleware } from 'connected-react-router'import createRootReducer from './reducers'export const history = createBrowserHistory()export default function configureStore(preloadedState) { const store = createStore( createRootReducer(history), // root reducer with router state preloadedState, compose( applyMiddleware( routerMiddleware(history), // for dispatching history actions // ... ), ), ) return store} 3.利用 ConnectedRouter组件，传递给他history对象作为prop，并将该组件作为 react-redux的Provider组件的子组件 1234567891011121314151617181920// index.jsimport { Provider } from 'react-redux'import { Route, Switch } from 'react-router' // react-router v4/v5import { ConnectedRouter } from 'connected-react-router'import configureStore, { history } from './configureStore'const store = configureStore(/* 提供初始state */)ReactDOM.render( &lt;Provider store={store}&gt; &lt;ConnectedRouter history={history}&gt; { /* place ConnectedRouter under Provider */ } &lt;&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; render={() =&gt; (&lt;div&gt;Match&lt;/div&gt;)} /&gt; &lt;Route render={() =&gt; (&lt;div&gt;Miss&lt;/div&gt;)} /&gt; &lt;/Switch&gt; &lt;/&gt; &lt;/ConnectedRouter&gt; &lt;/Provider&gt;, document.getElementById('react-root')) 编程式导航connect-react-router也提供了路由跳转的方法，比如 push 和 replace，但是这些方法只是创建了action，需要dispatch这些方法产生的action 123456import {push, replace} from &quot;connected-react-router&quot;;function XXX() { dispatch(push(&quot;/page1&quot;)) // ...} 参考react学习笔记6-redux一篇文章总结redux、react-redux、redux-sagaRedux中文文档","link":"/2021/06/15/React/redux%E5%85%A5%E9%97%A8/"},{"title":"React Hook","text":"函数式组件只能使用props，Hook能够在函数式组件的情况下使用state、生命周期以及其他的React特性 为什么需要引入React Hook，可以查看官方文档：https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation 1. 注意事项 只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用 只能在 React 的函数组件或自定义Hook中调用 Hook，不要在其他 JavaScript 函数中调用 Hook 在 class 内部是不起作用的 2. useStateuseState在组件内创建的内部state，React 会在重复渲染时保留这个 state，该函数的第一个参数是初始值，可以传入一个函数，此函数只在初始渲染中被调用。调用该函数会返回一对值：[当前状态，更新当前状态的函数]。 这个更新状态的函数不会对state进行合并，而是直接替换，可以传递一个回调函数，携带参数是上一次的state 123456789101112import React, { useState } from 'react'; 2:function Example() { const [count, setCount] = useState(0); 5: return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 内部使用Object.js（浅）来比较新/旧state是否相等，在修改状态时，传的状态值没有变化，则不重新渲染 惰性初始值下面的代码中，initialState是只在初始化时有其存在价值，但是如果真如下面一样写了，那么这个计算出initialState昂贵的操作在每次render都会执行。 12const initialState = someExpensiveComputation(props); // 这是一个耗时的操作const [state, setState] = useState(initialState); 我们可以让someExpensiveComputation 运行在一个useState匿名函数参数下，该函数当且仅当初始化时被调用，从而优化性能。 1234const [state, setState] = useState(() =&gt; { const initialState = someExpensiveComputation(props); return initialState;}); 2. useEffect用来在函数式组件内使用class组件的生命周期函数，可以传递两个参数，第一个是执行回调函数，第二个是监听的变量数组。 使用方式1.只在第一次的componentDidMount执行第二个参数为 [] 123useEffect(()=&gt;{ // ...}, []) 2. 在第一次渲染和每次更新后执行第二个参数为空 123useEffect(()=&gt;{ // ...}) 3. 监听变量的变化执行第二个参数是一个变量数组，只要有一个变量变化了就会执行 123useEffect(() =&gt; { // count改变才会执行}, [count]) 4. 在componentWillUnmount中执行第一个回调函数可以return一个函数，这个return的函数会在componentWillUnmount这个生命周期执行。 12345useEffect(() =&gt; { console.log('use effect...', count) const timer = setInterval(() =&gt; setCount(count +1), 1000) return () =&gt; clearInterval(timer)}) 3. useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。 和createRef的区别：createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用（可以解决每次渲染引用不同的useState，导致状态异常的bug） 1234567891011121314151617181920212223function App () { const [renderIndex, setRenderIndex] = useState(1); const refFromUseRef = useRef(); const refFromCreateRef = createRef(); if (!refFromUseRef.current) { console.log(&quot;useRef&quot;) refFromUseRef.current = renderIndex; } if (!refFromCreateRef.current) { console.log(&quot;createRef&quot;) refFromCreateRef.current = renderIndex; } return ( &lt;div className=&quot;App&quot;&gt; Current render index: {renderIndex} &lt;p&gt;refFromUseRef value: {refFromUseRef.current}&lt;/p&gt; &lt;p&gt;refFromCreateRef value: {refFromCreateRef.current}&lt;/p&gt; &lt;button onClick={() =&gt; setRenderIndex(prev =&gt; prev + 1)}&gt; Cause re-render &lt;/button&gt; &lt;/div&gt; );} ![image-20210606235123989](D:\\OneDrive - mail2.gdut.edu.cn\\typora_img\\React Hook\\image-20210606235123989.png) 4. useImperativeHandleuseImperativeHandle可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛 useImperativeHandle 应当与 forwardRef 一起使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Child (props, parentRef) { // 子组件内部自己创建 ref let focusRef = useRef(); let inputRef = useRef(); useImperativeHandle(parentRef, () =&gt; { // 这个函数会返回一个对象 // 该对象会作为父组件 current 属性的值 // 通过这种方式，父组件可以使用操作子组件中的多个 ref return { focusRef, inputRef, name: '计数器', focus () { focusRef.current.focus(); }, changeText (text) { inputRef.current.value = text; } } }); return ( &lt;React.Fragment&gt; &lt;input ref={focusRef}/&gt; &lt;input ref={inputRef}/&gt; &lt;/React.Fragment&gt; )}Child = forwardRef(Child);function Parent () { const parentRef = useRef();//{current:''} function getFocus () { parentRef.current.focus(); // 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效 // parentRef.current.addNumber(666); parentRef.current.changeText('777'); console.log(parentRef.current.name); } return ( &lt;React.Fragment&gt; &lt;Child ref={parentRef}/&gt; &lt;button onClick={getFocus}&gt;获得焦点&lt;/button&gt; &lt;/React.Fragment&gt; )} 5.useMemo 父组件的state改变，子组件也会随之重新render，即使子组件内部state没有改变，我们可以用useMemo来进行性能优化 参数列表 回调函数，return出来的值作为useMemo的返回值 依赖项数组，只要有一个变量改变，就会重新执行回调，但不会触发渲染，如果没有提供依赖数组，则useMemo 在每次渲染时都会计算新的值 useMemo返回一个 memoized 值，它仅会在会在某个依赖项改变时才重新计算 memoized 值。 12345678910111213141516171819202122232425262728293031const Child = memo(({data}) =&gt; { console.log('child render...', data.name) return ( &lt;div&gt; &lt;div&gt;child&lt;/div&gt; &lt;div&gt;{data.name}&lt;/div&gt; &lt;/div&gt; );})const Hook = () =&gt; { console.log('Hook render...') const [count, setCount] = useState(0) const [name, setName] = useState('rose') const data = useMemo(() =&gt; { return { name } }, [name]) return( &lt;div&gt; &lt;div&gt; {count} &lt;/div&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;update count &lt;/button&gt; &lt;Child data={data}/&gt; &lt;/div&gt; )} 6. useCallback useCallback与useMemo的差别是，前者是缓存函数，后者是缓存值 123const onChange = useCallback((e) =&gt; { setText(e.target.value)}, []) useCallback(fn, deps)相当于useMemo(() =&gt; fn, deps) 7. useContext接收一个 context 对象（由React.createContext 所创建）并返回该 context 的当前值，当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定 1234567891011121314151617181920212223242526const TextContext = React.createContext();function App() { return ( &lt;TextContext.Provider value={666}&gt; &lt;Toolbar /&gt; &lt;/TextContext.Provider&gt; );}function Toolbar(props) { return ( &lt;div&gt; &lt;xxxButton /&gt; &lt;/div&gt; );}function xxxButton() { const text = useContext(ThemeContext); return ( &lt;button style={{ color: text }}&gt; I am styled by theme context! &lt;/button&gt; );} 当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染 8. useLayoutEffect useLayoutEffect会在浏览器 layout 之后，painting 之前执行 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect 可以使用它来读取 DOM 布局并同步触发重渲染 尽可能使用标准的 useEffect 以避免阻塞视图更新 1234567891011121314151617function LayoutEffect () { const [color, setColor] = useState('red'); useLayoutEffect(() =&gt; { alert(color); }); useEffect(() =&gt; { console.log('color', color); }); return ( &lt;React.Fragment&gt; &lt;div id=&quot;myDiv&quot; style={{ background: color }}&gt;颜色&lt;/div&gt; &lt;button onClick={() =&gt; setColor('red')}&gt;红&lt;/button&gt; &lt;button onClick={() =&gt; setColor('yellow')}&gt;黄&lt;/button&gt; &lt;button onClick={() =&gt; setColor('blue')}&gt;蓝&lt;/button&gt; &lt;/React.Fragment&gt; );} 先alert出red，再渲染出页面，阻塞渲染 9. 自定义Hook其实就是写一个函数内部调用其他Hook，每次使用自定义Hook时，所有的state和副作用都是完全隔离的 例如：我们可以对useRef封装成自定义Hook来获取上一次的值 123456789const usePrevious = state =&gt; { const ref = useRef(); useEffect(() =&gt; { ref.current = state; }) return ref.current;} 12345678910111213function App () { const [count, setCount] = useState(0); const prevCount = usePrevious(count); return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Cause re-render &lt;/button&gt; &lt;p&gt; {count} {prevCount}&lt;/p&gt; &lt;/div&gt; );} 每次点击button，prevCount都是上一次count的值 易错点1. 为什么我的count没有更新12345678function ErrorDemo() { const [count, setCount] = useState(0); const dom = useRef(null); useEffect(() =&gt; { dom.current.addEventListener('click', () =&gt; setCount(count + 1)); }, []); return &lt;div ref={dom}&gt;{count}&lt;/div&gt;;} 上面这段代码，用户点击div，count只会加到1，后面就不会再加了。 原因是：每次 count 都是重新声明的变量，指向一个全新的数据；每次的 setCount 虽然是重新声明的，但指向的是同一个引用。 解决方式一：函数式更新用回调函数的形式，() =&gt; setCount(prevCount =&gt; ++prevCount)，来消除对外部count的引用。 解决方式二：重新绑定事件12345useEffect(() =&gt; { dom.current.addEventListener('click', () =&gt; setCount(count + 1)); return () =&gt; dom.current.removeEventListener('click', () =&gt; setCount(count + 1));}, [count]); // 在这里对count进行监听，每次改变都会重新绑定事件return &lt;div&gt;{count}&lt;/div&gt;; 解决方式三：用ref重新获取引用12345678const dom = useRef(null);const countRef = useRef(count);useEffect(() =&gt; { dom.current.addEventListener('click', () =&gt; { countRef.current++; setCount(countRef.current); });}, []); 参考写React Hooks前必读终于搞懂 React Hooks了！！！！！","link":"/2021/06/08/React/React%20Hook/"},{"title":"React Router","text":"react-router：路由核心库，包含诸多和路由功能相关的核心代码 react-router-dom：利用路由核心库，结合实际的页面，实现跟页面路由密切相关的功能 安装123# react-router-dom依赖react-router# 安装的时候会把react-router一起安装了npm install react-router-dom -S 1.两种路由模式 Hash、History HashRouter：使用 hash 模式匹配 BrowserRouter：使用 BrowserHistory 模式匹配 两者区别1.底层原理不一样： BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。 HashRouter使用的是URL的哈希值。2.path表现形式不一样 BrowserRouter的路径中没有#，例如：localhost:3000/demo/test HashRouter的路径包含#,例如：localhost:3000/#/demo/test3.刷新后对路由state参数的影响 BrowserRouter没有任何影响，因为state保存在history对象中。 HashRouter刷新后会导致路由state参数的丢失！！！4.备注：HashRouter可以用于解决一些路径错误相关的问题。 2. 跳转组件 Link和NavLinkLink组件 1&lt;Link to=&quot;/xxxxx&quot;&gt;Demo&lt;/Link&gt; Link组件配置方式 to：要跳转的链接（String | Object | Function） replace：设置为true，则跳转替换路由栈顶 innerRef：可以将内部的a元素的ref附着在传递的对象或函数参数上（Function | RefObject） component：可以设置自定义的导航组件 12345const FancyLink = React.forwardRef((props, ref) =&gt; ( &lt;a ref={ref} {...props}&gt;💅 {props.children}&lt;/a&gt;))&lt;Link to=&quot;/&quot; component={FancyLink} /&gt; NavLink可以实现路由链接的高亮，通过activeClassName指定样式类名 1&lt;NavLink to=&quot;/xxxxx&quot;&gt;Demo&lt;/NavLink&gt; 3. route组件配置方式 path：匹配的路径 默认情况下，不区分大小写，可以设置sensitive属性为true，来区分大小写 默认情况下，只匹配初始目录，如果要精确匹配，配置exact属性为true 如果不写path，则会匹配任意路径 component：匹配成功后要显示的组件 children 传递React元素，无论是否匹配，一定会显示children，并且会忽略component属性 传递一个函数，该函数有多个参数，这些参数来自于上下文，该函数返回react元素，则一定会显示返回的元素，并且忽略component属性 render：匹配成功渲染的组件，内联书写render，而不是创建一个React元素 sensitive：true则对paht的大小写敏感 exact：精确匹配 route嵌套下述代码中，用户访问/repos时，会先加载App组件，然后在它的内部再加载Repos组件。 123456&lt;BrowserRouter history={hashHistory}&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;/repos&quot; component={Repos}/&gt; &lt;Route path=&quot;/about&quot; component={About}/&gt; &lt;/Route&gt;&lt;/BrowserRouter&gt; 匹配规则 :paramName :paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。 () ()表示URL的这个部分是可选的。 * *匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。 ** ** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。 此外，URL的查询字符串/foo?bar=baz，可以用this.props.location.query.bar获取。 12345678import { BrowserRouter, Route } from &quot;react-router-dom&quot;;&lt;BrowserRouter&gt; &lt;Route path=&quot;/a&quot; component={A} /&gt; &lt;Route path=&quot;/a/d&quot; exact component={D}/&gt; // 精确匹配 &lt;Route component={C} /&gt; &lt;Route path='/abc' children={E}/&gt;&lt;/BrowserRouter&gt; 上述代码，如果路由是 /a/d，则会渲染 A、D、C、E，react router是会从上至下完全匹配一遍，而为了解决这个问题，引入了Switch组件。 4. Switch组件会循环所有子元素，当匹配到第一个Route后，会立即停止匹配并渲染，因此不能在Switch组件的子元素中使用除Route外的其他组件 1234567&lt;Router&gt; &lt;Switch&gt; &lt;Route path=&quot;/a&quot; component={A} /&gt; &lt;Route path=&quot;/a/b&quot; component={B} /&gt; &lt;Route component={C} /&gt; &lt;/Switch&gt;&lt;/Router&gt; 5. Redirect组件一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由 1&lt;Redirect to=&quot;/about/&quot; /&gt; 6. 路由信息Router组件会创建一个上下文，并且向上下文中注入一些信息，该上下文对开发者是隐藏的，Route组件若匹配到了地址，则会将这些上下文中的信息作为属性传入对应的组件 12345678910111213141516171819import React from 'react'import { BrowserRouter as Router, Route, Switch } from &quot;react-router-dom&quot;// afunction A(props) { console.log(props) return &lt;h1&gt;组件A&lt;/h1&gt;}export default function App() { return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=&quot;/a&quot; component={A} /&gt; &lt;/Switch&gt; &lt;/Router&gt; )} 打印一下props 12345678910111213141516history: go: ƒ go(n) goBack: ƒ goBack() goForward: ƒ goForward() push: ƒ push(path, state) replace: ƒ replace(path, state)location: hash：页面hash pathname：页面的path state：push时传入的数据 search：传入的参数match: isExact：事实上，当前的路径和路由配置的路径是否是精确匹配的 params：获取路径中对应的数据 path：路径规则 url：页面路径 7.路由传参5.1 params 参数路由链接(携带参数)：&lt;Link to='/demo/test/tom/18'}&gt;详情&lt;/Link&gt;注册路由(声明接收)：&lt;Route path=&quot;/demo/test/:name/:age&quot; component={Test}/&gt;接收参数：this.props.match.params 5.2 search参数路由链接(携带参数)：&lt;Link to='/demo/test?name=tom&amp;age=18'}&gt;详情&lt;/Link&gt;注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component={Test}/&gt;接收参数：this.props.location.search备注：获取到的search是urlencoded编码字符串，需要借助querystring解析 5.3 state参数路由链接(携带参数)：&lt;Link to={{pathname:'/demo/test',state:{name:'tom',age:18}}}&gt;详情&lt;/Link&gt;注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component={Test}/&gt;接收参数：this.props.location.state备注：刷新也可以保留住参数 8. 编程式导航借助this.props.history上的方法，基本和H5的history一致，就只是列一下了 12345this.props.history.push()this.props.history.replace()this.props.history.goBack()this.props.history.goForward()this.props.history.go() 9. withRouter 由于只能在跳转的组件中获取路由信息，所以提出withRouter，用withRouter包裹的组件能获取路由信息 1234567891011121314function ButtonContainer(props) { let history = props.history; return ( &lt;div className={&quot;container&quot;}&gt; &lt;button onClick={() =&gt; {history.push(&quot;/a?key=a&quot;, &quot;A状态数据&quot;)}}&gt;A&lt;/button&gt; &lt;button onClick={() =&gt; {history.push(&quot;/a/b?key=b&quot;, &quot;B状态数据&quot;)}}&gt;B&lt;/button&gt; &lt;button onClick={() =&gt; {history.push(&quot;/a/c?key=c&quot;, &quot;C状态数据&quot;)}}&gt;C&lt;/button&gt; &lt;button onClick={() =&gt; {history.push(&quot;/a/d?key=d&quot;, &quot;D状态数据&quot;)}}&gt;D&lt;/button&gt; &lt;button onClick={() =&gt; {history.push(&quot;/a/news/2020/12/21&quot;)}}&gt;News&lt;/button&gt; &lt;/div&gt; )}const WithRouterButtonContainer = withRouter(ButtonContainer) 其返回值是一个新组件 参考react学习笔记5-React Router[React Router 使用教程](","link":"/2021/05/28/React/React%20Router/"},{"title":"React从入门到真香","text":"1. 设计思想 React 设计思想 React的设计哲学 - 简单之美 颠覆式前端UI开发框架:React 2. 安装 2.1 CDN的方式引入123&lt;script src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; react.js：React核心库 react-dom.js：提供操作 DOM 的 react 扩展库 babel.min.js：解析 JSX 语法代码转为 JS 代码的库 2.2 create-react-app安装create-react-app 1npm isntall -g create-react-app 创建项目 1create-react-app my-app 3. JSXjsx 允许在模板中用{}插入JavaScript表达式，如果{}中的变量是数组，则会展开这个数组的所有成员 123456789101112131415161718192021var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;{arr}&lt;/div&gt;, document.getElementById('example'));var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; { names.map(function (name) { // 列表渲染 return &lt;div&gt;Hello, {name}!&lt;/div&gt; }) } &lt;/div&gt;, document.getElementById('example2')); ReactDOM.render第一个参数是渲染的组件，第二个参数是挂载实例的位置。 className替换class 内联样式——style= 只能含有一个最外层标签 对于最后一个问题，可以使用React.Fragment组件，它能够在不额外创建 DOM 元素的情况下，让render返回多个元素 12345678render() { return ( &lt;React.Fragment&gt; Some text. &lt;h2&gt;A heading&lt;/h2&gt; &lt;/React.Fragment&gt; );} 4.组件4.1 类组件（有状态） 组件类的第一个名字必须大写 通过继承React.Component来实现类组件，需要实现一个render方法，该方法返回一个模板 12345678910class Clock React.Component { render () { return ( &lt;div onClick={this.clickFunc.bind(this)}&gt; // 将clickFunc内部this指向组件实例 &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}&lt;/h2&gt; &lt;/div&gt; ) }} 通过React.createClass生成一个组件类 12345678910var Clock = React.createClass({ render: function() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}&lt;/h2&gt; &lt;/div&gt; ) }}); 两种方式的区别是，前者不会自动绑定this 4.2 函数式组件（无状态）12345678910function Person (props) { const {name, age, sex} = props; return { &lt;ul&gt; &lt;li&gt;姓名：{name}&lt;/li&gt; &lt;li&gt;性别：{sex}&lt;/li&gt; &lt;li&gt;年龄：{age}&lt;/li&gt; &lt;/ul&gt; }} 5. State5.1 state初始化12345678910111213class Clock React.Component { // 第一种 直接在实例上定义state属性 state = { value: 6, } // 第二种 在构造器中设置state constructor () { this.state = { value: 6 } }} 5.2 state修改直接修改数据是不会触发视图更新的，只有使用setState来修改数据，会重新触发组件的render函数 setState第一个参数就是修改后的state对象，可以修改某一个值，setState是浅合并。 如果setState的第一个参数不是一个对象而是一个函数，这个函数在执行时会通过参数被传入prevState，也就是之前的状态，而返回值就会和state进行合并 1234567this.setState((prevState : any) =&gt; { return { num : prevState.num + 1 }}, () =&gt; { console.log(this.state.num)}) 但是setState有两个问题 setState对状态的修改，可能是异步执行的（如果改变状态的代码处于某个HTML元素的事件中，则其是异步的，否则是同步） React会对异步的setState进行优化，将多次setState进行合并（将多次状态改变完成后，再统一对state进行改变，然后触发render） 下面给出第一个问题的例子 123456789101112131415161718192021class Comp extends React.Component { state = { num: 0 } handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }) console.log(this.state.num) // 第一下点击输出 0 } render () { return ( &lt;React.Fragment&gt; &lt;p&gt;{this.state.num}&lt;/p&gt; &lt;button onClick={this.handleClick}&gt;点我&lt;/button&gt; &lt;/React.Fragment&gt; ) }} 在第一下点击按钮的时候，console.log输出 0，说明setState在DOM事件中是异步执行的。 解决方式：setState有第二个参数，来放置render执行后接着执行的回调函数 6. Props6.1 传递参数父组件在使用子组件的时候，通过给子组件元素设置属性的方式传递参数给子组件 12345678910111213141516171819202122232425262728// 父组件设置属性给子组件传参，这里属性名用value2用作区分class Board extends React.Component { render () { return ( &lt;Square value2={0}/&gt; ); }}// 类组件 通过 this.props.[属性] 来获取参数class Square extends React.Component { render() { return ( &lt;button className=&quot;square&quot;&gt; {this.props.value2} &lt;/button&gt; ); }}// 函数式组件通过 props.[属性] 来获取参数function Square (props) { return ( &lt;button className=&quot;square&quot;&gt; {props.value2} &lt;/button&gt; )} 6.2 props传递事件通过this.props.[事件名]调用 1234567891011121314151617class Board extends React.Component { render () { return ( &lt;Square click={() =&gt; {alert(&quot;click event&quot;)}}/&gt; ); }}class Square extends React.Component { render() { return ( &lt;button onClick={this.props.click} className=&quot;square&quot;&gt; button &lt;/button&gt; ); }} 6.3 props校验1.需要引入一个库prop-types.js cdn 1&lt;script src=&quot;https://unpkg.com/prop-types@15.6/prop-types.js&quot;&gt;&lt;/script&gt; npm 1npm install --save prop-types 2.使用方式 在组件上定义 PropTypes对象，键就是props的名，值就是限制。 1234567891011121314151617181920212223class Square extends React.Component { render() { // ... do things with the props } // 方式一 static propTypes = { value1: PropTypes.number.isRequired, value2: PropTypes.string } // 指定props默认值 static defaultProps = { value1: 666, value2: &quot;6&quot;, }}// 方式二Square.propTypes = { value1: PropTypes.number.isRequired, value2: PropTypes.string} 更多使用方式参考：https://github.com/facebook/prop-types 6.4 this.props.children 获取组件所有子节点 123456789101112131415161718192021class NotesList extends React.Component { render() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); }}ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example')); 没有子节点：undefined 一个子节点：object 多个子节点：array 可以用React.Children.map来遍历子节点，则不需要担心子元素个数 6.5 props传递组件React组件本质就是对象，当作props像其他数据一样传递也是可以的 7. React生命周期 感觉和vue差不多，直接简单带过把 componentWillMount()组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作 componentDidMount()组件已经被渲染到页面中后触发，可以通过this.getDOMNode()来进行访问DOM。 componentWillReceiveProps()在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。 shouldComponentUpdate()返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 12345// 该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。shouldComponentUpdate(newProps, newState) { if (newProps.number &lt; 5) return true; return false} 一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它旗下所有的子组件重新执行render()方法（即使没有使用父组件的state），形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染，还可以使用下面说了PureComponent componentWillUpdate()在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate()在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnMount()组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。 getDerivedStateFromError()这个生命周期方法在ErrorBoundary类中使用。实际上，如果使用这个生命周期方法，任何类都会变成ErrorBoundary。这用于在组件树中出现错误时呈现回退UI，而不是在屏幕上显示一些奇怪的错误。 componentDidCatch()这个生命周期方法在ErrorBoundary类中使用。实际上，如果使用这个生命周期方法，任何类都会变成ErrorBoundary。这用于在组件树中出现错误时记录错误。 8. Ref用来访问DOM元素或render中的react元素，Ref的使用规则如下 ref作用于内置的html组件时，得到的将是真实的dom对象 ref作用于类组件时，得到的将是类的实例 ref不能作用于函数组件（因为没有实例），但是函数组件内部可以 8.1 创建refref的可选值为 字符串（不建议） 原因：react ref注意事项 回调函数 触发时机：ref中的回调函数会在对应的普通组件（或元素）componentDidMount，ComponentDidUpdate之前，或者componentWillUnmount之后执行 注意：如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的 createRef 123456789101112131415161718class MyComponent extends React.Component { constructor(props) { super(props); this.textInput = React.createRef(); } focusTextInput() { // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点 this.textInput.current.focus(); } render() { return ( &lt;React.Fragment&gt; &lt;input type=&quot;text&quot; ref={this.textInput} /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.focusTextInput.bind(this)}/&gt; &lt;/React.Fragment&gt; ); }} 8.2 转发ref 用于获取组件内部的某个元素，有些高度复用的基础组件不可避免的需要在父组件获取，用以管理焦点等 React.forwardRef用以获取传递给它的ref，然后转发到渲染它的DOM。 对于函数式组件，React.forwardRef直接包裹函数就可以接收到ref 123456789const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref={ref} className=&quot;FancyButton&quot;&gt; {props.children} &lt;/button&gt;));// 你可以直接获取 DOM button 的 ref：const ref = React.createRef();&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;; 使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref 而对于类组件，需要使用HOC的形式，用React.forwardRef包裹返回的函数式组件 1234567891011121314151617function logProps(Component) { class LogProps extends React.Component { render() { const {forwardedRef, ...rest} = this.props; // 将自定义的 prop 属性 “forwardedRef” 定义为 ref return &lt;input ref={forwardedRef} {...rest} /&gt;; } } // 注意 React.forwardRef 回调的第二个参数 “ref”。 // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef” // 然后它就可以被挂载到被 LogProps 包裹的子组件上。 return React.forwardRef((props, ref) =&gt; { return &lt;LogProps {...props} forwardedRef={ref} /&gt;; });} 用React.forwardRef包裹的组件在DevTools中显示为”ForwardRef”，可以把包裹的函数用普通函数的形式命名，DevTools也将包含其名称（例如 “ForwardRef(myFunction)”），也可以设置函数的displayName属性来设置DevTools中显示的名字 9.Context 跨组件的通信方式，等同Vue的provide、inject 使用1.创建Context容器对象 12// 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效const xxxContext = React.createContext(defaultValue) 2.渲染子组时，外面包裹xxxContext.Provider，通过value属性给后代组件传递数据 123&lt;xxxContext.Provider value={数据}&gt; &lt;子组件&gt;&lt;/子组件&gt;&lt;/xxxContext.Provider&gt; ps：如果要传多个数据，需要套多层 3.后代组件获取数据 12345678// 第一种：仅适用于类组件static contextType = xxxContext // 声明接受contextthis.context; // 读取context中的value数据// 第二种：函数组件与类组件都可以&lt;xxxContext.Consumer&gt; {value}&lt;/xxxContext.Consumer&gt; 不建议使用该api，他提高了组件复用的难度 10.PureComponent 父组件setState会触发子组件render，PureComponent通过prop和state的浅比较来实现shouldComponentUpdate，算是一种语法糖，帮我们应该在shouldComponentUpdate中应该手动比较的给做了 如果是浅层state或prop没改变，那么不会触发视图更新，书写方式如下 123class IndexPage extends PureComponent { // ...} 由于是浅比较，所以直接修改对象内部的值是无法更新视图的 在函数式组件则是用React.memo包裹函数式组件来做到PureComponent的效果 参考React学习资源汇总React 入门实例教程react学习笔记2-react基本使用react学习笔记3-react其他使用技巧图解ES6中的React生命周期你要的 React 面试知识点，都在这了","link":"/2021/05/27/React/React%E5%85%A5%E9%97%A8/"},{"title":"js准确倒计时","text":"引入如果用最初始的setTimeout递归实现定时器，一秒执行一次回调，则代码如下 12345678910111213141516171819202122232425262728// 模拟执行大量代码setInterval(() =&gt; { let i = 0; while (i++ &lt; 100000000) { }}, 0);function countDown (fn, time) { let startTime = new Date().getTime(), count = 0, second = 1000; let timeCounter = null; return function interFunc () { let offset = new Date().getTime() - (startTime + count * second); console.log(&quot;误差：&quot; + offset + &quot;ms，下一次执行：&quot; + 1000 + &quot;ms后，离活动开始还有：&quot; + time + &quot;ms&quot;); time -= second; count++; if (time &lt; 0) { clearTimeout(timeCounter); } else { timeCounter = setTimeout(() =&gt; { fn.apply(this, arguments); interFunc(); }, 1000); } }}countDown(function () {}, 10000)(); // 测试代码 可以看到误差是会越来越多的。 解决核心思想就是通过计算 当前时间 - 应该到的时间 计算出时间偏移量，下一次延迟时间就是 1s - 偏移量 123456789101112131415161718192021222324252627282930313233// 模拟执行大量代码setInterval(() =&gt; { let i = 0; while (i++ &lt; 100000000) { }}, 0);// 倒计时function countDown (fn, time) { let startTime = new Date().getTime(), count = 0, second = 1000; let timeCounter = null; return function interFunc () { let offset = new Date().getTime() - (startTime + count * second); let nextTime = second - offset; if (nextTime &lt; 0) { nextTime = 0 } console.log(&quot;误差：&quot; + offset + &quot;ms，下一次执行：&quot; + nextTime + &quot;ms后，离活动开始还有：&quot; + time + &quot;ms&quot;); time -= second; count++; if (time &lt; 0) { clearTimeout(timeCounter); } else { timeCounter = setTimeout(() =&gt; { fn.apply(this, arguments); interFunc(); }, nextTime); } }}countDown(function () {}, 10000)(); // 测试代码 可以看到虽然仍有误差，但不会随着时间增大","link":"/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/"},{"title":"如何给对象设置默认值","text":"1.用 … 解构设置在看compressor.js的时候，他用一个文件来存默认值，然后导出，最后用解构的方式，后面的值覆盖前面的方式设置默认值。当然也可以用Object.assign都是一样的 123456789101112131415161718// defaults.jsexport default { maxWidth: Infinity, maxHeight: Infinity, // ... }// index.jsimport DEFAULTS from './defaults';export default class Compressor { constructor (option) { this.option = { ...DEFAULTS, ...option, } }} 上面的方法看着挺方便的，但是还有缺陷，解决不了下面的问题 123456789101112131415161718192021let user = { a: &quot;a1&quot;, b: { c: &quot;c1&quot; }}let defaults = { a: &quot;a2&quot;, b: { c: &quot;c2&quot;, d: &quot;d1&quot; // 丢失了 },}let option = { ...defaults, ...user}console.log(option) // { a: 'a1', b: { c: 'c1' } } 可以看到默认配置中 d丢失了，下面的方法可以解决这个问题 2.extend方法Mescroll.js实现的方法，适合多个方法都需要默认值的时候，并且可以深度匹配默认值，默认值作为第二个参数传入， 1234567891011MeScroll.extend = function (userOption, defaultOption) { if (!userOption) return defaultOption; for (var key in defaultOption) { if (userOption[key] == null) { // 如果用户没设置，则用默认值 userOption[key] = defaultOption[key]; } else if (typeof userOption[key] === 'object') { MeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配 } } return userOption;} 但是有些场景我们是需要有多个配置进行合并，我们可以参考jquery的extend实现方式 3.$.extend$.extend([deep,] [target,] object1 [,objectN]) deep: Boolen类型，可选，表示是否进行递归合并（深/浅复制），为true是为深复制；默认值为false，浅复制。target:扩展对象，可选，将接收新的属性。objectN:一个对象，包含额外的属性，扩展到目标对象（扩展对象）。 我们可以砍掉一个没必要的功能，就是$.extend如果参数中只有一个对象，则扩展jquery对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 此方法会改变原对象jQuery.extend = jQuery.fn.extend = function () { var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, // i表示从第几个参数开始向目标参数进行合并，默认从第2个参数开始向第1个参数进行合并 length = arguments.length, deep = false; // 默认为浅度拷贝 // 如果第一个参数是用来设置deep的boolean值，则将target设置为下一个参数 if (typeof target === &quot;boolean&quot;) { deep = target; target = arguments[i] || {}; i++; } // 判断目标参数的类型，若目标参数既不是object类型，也不是function类型，则为目标参数重新赋值 if (typeof target !== &quot;object&quot; &amp;&amp; typeof target !== &quot;function&quot;) { target = {}; } // 从第i个参数开始 for (; i &lt; length; i++) { // 获取第i个不为null或undefined的参数 if ((options = arguments[i]) != null) { for (name in options) { src = target[name]; copy = options[name]; // 防止循环引用 if (name === &quot;__proto__&quot; || target === copy) { continue; } // 若deep为true，且当前参数中name字段的值存在且为object类型或Array类型，则进行深合并 if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) { // 如果copy是数组类型，则判断目标参数中name字段的值是否存在，若存在则使用原来的，否则进行初始化 if (copyIsArray &amp;&amp; !Array.isArray(src)) { clone = []; } else if (!copyIsArray &amp;&amp; !isPlainObject(src)) { clone = {}; } else { clone = src; } copyIsArray = false; target[name] = merge(deep, clone, copy); // deep为false，表示浅拷贝，直接进行赋值 // 或者copy不为Object对象、数组，则直接赋值 } else if (copy !== undefined) { // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性 target[name] = copy; } } } } // 返回修改后的目标参数 return target;}; 附1：jquery重构了的一段代码123456789101112if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) { if (copyIsArray) { copyIsArray = false; clone = src &amp;&amp; Array.isArray(src) ? src : []; } else { clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {}; } target[name] = jQuery.extend(deep, clone, copy);} else if ( copy !== undefined ) { target[name] = copy;} 1234567891011121314if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) { if (copyIsArray &amp;&amp; !Array.isArray(src)) { clone = []; } else if (!copyIsArray &amp;&amp; !isPlainObject(src)) { clone = {}; } else { clone = src; } copyIsArray = false; target[name] = merge(deep, clone, copy);} else if (copy !== undefined) { target[name] = copy;} 代码明显下面好看了许多，可以学习一下这种重构方式 附2：isEmptyObject、isPlainObject1.isEmptyObject1234567891011isEmptyObject: function (obj) { var name; for (name in obj) { return false; } return true;}// 还可以利用JSON.stringifyJSON.stringify(obj) == &quot;{}&quot; 2.isPlainObject123456789101112function isPlainObject (target) { // 1.先排除明显不是Object的 if (!target || Object.prototype.toString.call(target) !== &quot;[object Object]&quot;) return false; // 2.判断是否有原型，没有原型的是简单对象 const proto = Object.getPrototypeOf(target); if (!proto) return true; // 3.判断其构造函数是否为 Object const ctor = proto.constructor; return typeof ctor === &quot;function&quot; &amp;&amp; ctor === Object;} 参考https://blog.csdn.net/weixin_33694172/article/details/89369987","link":"/2021/05/06/Js/%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC/"},{"title":"【源码解读】crossvent源码解读","text":"其实就是一个封装事件绑定的库，但是看到了一些技巧记录下来github地址：https://github.com/bevacqua/crossvent/blob/master/src/crossvent.js 从出口开始12345module.exports = { add: addEvent, remove: removeEvent, fabricate: fabricateEvent}; add和remove函数addEvent实际上就是判断window是否有addEventListener，如果没有就用attachEvent，remove同理 1234567891011121314151617181920212223242526var addEvent = addEventEasy;var removeEvent = removeEventEasy;if (!global.addEventListener) { addEvent = addEventHard; removeEvent = removeEventHard;}function addEventEasy (el, type, fn, capturing) { return el.addEventListener(type, fn, capturing); // capturing如果为true则在事件捕获阶段执行，默认为false}function addEventHard (el, type, fn) { return el.attachEvent('on' + type, wrap(el, type, fn));}function removeEventEasy (el, type, fn, capturing) { return el.removeEventListener(type, fn, capturing);}function removeEventHard (el, type, fn) { var listener = unwrap(el, type, fn); if (listener) { return el.detachEvent('on' + type, listener); }} 这里需要注意：在不支持addEventListener的时候，使用attachEvent和detachEvent事件回调函数多做了一层wrap和unwrap处理 wrap和unwrap1234567891011121314151617181920212223242526272829303132var hardCache = [];function wrap (el, type, fn) { // 如果已经注册过这个type的事件，则unwrap即从hardCache删除事件，并在下面重新添加到hardCache数组里 var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn); hardCache.push({ wrapper: wrapper, element: el, type: type, fn: fn }); return wrapper;}function unwrap (el, type, fn) { var i = find(el, type, fn); if (i) { var wrapper = hardCache[i].wrapper; hardCache.splice(i, 1); // free up a tad of memory return wrapper; }}function find (el, type, fn) { var i, item; for (i = 0; i &lt; hardCache.length; i++) { item = hardCache[i]; if (item.element === el &amp;&amp; item.type === type &amp;&amp; item.fn === fn) { return i; } }} 可以看到是利用一个数组存储事件回调，在绑定事件和解绑事件同时对hardCache数组进行操作，但是为啥要这样呢。可以看到在wrap函数的第一行var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn); ，实际上就是如果之前没有绑定这个type的事件，就调用wrapperFactory对fn进行二次封装，wrapperFactory这个封装主要是为了解决event参数内的属性的兼容性。 这就解释了刚才提出的疑问，就是因为多了这层解决浏览器兼容性的包装，在解绑事件的时候，如果只是传递原来的fn，则不能解绑事件，需要一个hardCache数组来存取事件回调。 wrapperFactory12345678910function wrapperFactory (el, type, fn) { return function wrapper (originalEvent) { var e = originalEvent || global.event; e.target = e.target || e.srcElement; e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; }; e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; }; e.which = e.which || e.keyCode; fn.call(el, e); };} 这层封装可以使event的各个属性在不同浏览器下行为一致。 add和revome就讲完了，我们来看看导出的最后一个函数fabricate fabricate123456789101112131415161718192021function fabricateEvent (el, type, model) { var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent(); // 判断事件类型 并 创建 if (el.dispatchEvent) { // 触发事件 el.dispatchEvent(e); } else { el.fireEvent('on' + type, e); } function makeClassicEvent () { // 创建原生事件 var e; if (doc.createEvent) { e = doc.createEvent('Event'); e.initEvent(type, true, true); } else if (doc.createEventObject) { e = doc.createEventObject(); } return e; } function makeCustomEvent () { // 创建自定义事件 return new customEvent(type, { detail: model }); }} eventmap是原生事件名的集合，如果没有在eventmap找到则创建一个自定义事件，否则创建一个原生事件，然后触发事件。 那么eventmap是怎么生成的呢，我们下面来看看 获取原生事件名集合1234567891011var eventmap = [];var eventname = '';var ron = /^on/;for (eventname in global) { if (ron.test(eventname)) { eventmap.push(eventname.slice(2)); }}module.exports = eventmap; 其实就是正则匹配window上的开头为on的属性名 总结看到了挺多浏览器兼容的处理方式，以及原生事件名获取的骚操作，不过仍有一些兼容方式没看懂是兼容哪些浏览器的。","link":"/2021/04/06/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/crossvent%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"title":"Koa洋葱原型源码解读","text":"版本：2.13.1 application.js构造函数12345constructor(options) { ... this.middleware = []; ...} 有一个middleware存函数 use方法12345use(fn) { ... this.middleware.push(fn); return this;} 每次使用app.use()就会吧回调函数push到middleware里 listen方法1234listen(...args) { const server = http.createServer(this.callback()); return server.listen(...args);} 创建一个服务，执行callback方法 callback和handleRequest方法1234567891011121314151617181920callback() { const fn = compose(this.middleware); if (!this.listenerCount('error')) this.on('error', this.onerror); const handleRequest = (req, res) =&gt; { const ctx = this.createContext(req, res); // node 原生的 req、res 对象把其中的属性挂载到 ctx 上 return this.handleRequest(ctx, fn); // 调用 }; return handleRequest;}handleRequest(ctx, fnMiddleware) { const res = ctx.res; const onerror = err =&gt; ctx.onerror(err); // 处理响应 const handleResponse = () =&gt; respond(ctx); return fnMiddleware(ctx).then(handleResponse).catch(onerror);} compse函数返回一个中间件函数，在handleRequest执行中间件函数，如果全部 resolve 了就可以调用 handleResponse 发送给客户端 本片博客的重点就是compose是怎么实现koa的洋葱模型的 koa-compose.js1234567891011app.use(async (ctx, next) =&gt; { console.log(&quot;1&quot;); await next(); console.log(&quot;4&quot;);});app.use(async (ctx, next) =&gt; { console.log(&quot;2&quot;); await next(); console.log(&quot;3&quot;);}); compose函数123456789101112131415161718192021222324252627function compose (middleware) { ... /** * @param {Object} context * @return {Promise} * @api public */ return function (context, next) { // last called middleware # let index = -1 return dispatch(0) function dispatch (i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try { return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err) } } }} compose函数接收middleware数组，dispatch(0)即开始分发一号中间件。 dispatch(0)内部，此时 fn 为一号中间件，会走到 try/catch 块，尝试执行Promise.resolve(fn(context, dispatch.bind(null, i + 1)))，即一号中间件此时获得入参context、dispatch(1)。 一号中间件开始执行，遇到 next()（即dispatch(1)），控制权移交，执行 dispatch(1)，此时二号中间件获得入参context、dispatch(2)。 二号中间件开始执行，执行到await next()时，再重复上述逻辑，dispatch(2)，但是这一次会停在这里： 123let fn = middleware[i];if (i === middleware.length) fn = next;if (!fn) return Promise.resolve(); fn = next，这里的 next 由于并没有值，所以会直接 return 一个立即 resolve 的 Promise。也就是说二号中间件内部的 await next()会立刻返回。 二号中间件做完自己的事后，相当于一号中间件内部的await next()返回了，因此控制权就归还给一号中间件。 如果中间件中的next()方法报错了怎么办。123456789101112131415ctx.onerror = function { this.app.emit('error', err, this);};listen(){ const fnMiddleware = compose(this.middleware); if (!this.listenerCount('error')) this.on('error', this.onerror); const onerror = err =&gt; ctx.onerror(err); fnMiddleware(ctx).then(handleResponse).catch(onerror);}onerror(err) { // 代码省略 // ...} 答：中间件链错误会由ctx.onerror捕获，该函数中会调用this.app.emit('error', err, this)（因为koa继承自Emitter，所以有emit和on等方法），可以使用app.on('error', (err) =&gt; {})，或者app.onerror = (err) =&gt; {}进行捕获。 参考文章https://juejin.cn/post/6844904088220467213#heading-16https://linbudu.top/posts/2020/02/25/koa%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB.html#new-%E4%B8%80%E4%B8%AA-koa-%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F","link":"/2021/02/28/node.js/Koa%E6%B4%8B%E8%91%B1%E5%8E%9F%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"title":"尤雨溪frontend Master课程笔记","text":"1.响应式目的实现一个神奇的函数auto，会在state.count改变后，自动运行里面的函数 12345autoRun(() =&gt; { document.getElementById(&quot;app&quot;).innerText = state.count;})state.count++; // 重新执行autoRun内的函数 第一步 getter和setter需要能监听到对象内属性的改变 实现效果12345const obj = { foo: 123 }observer(obj);obj.foo // 需要打印: 'getting key &quot;foo&quot;: 123'obj.foo = 234 // 需要打印: 'setting key &quot;foo&quot; to 234'obj.foo // 需要打印: 'getting key &quot;foo&quot;: 234' 实现方式12345678910111213141516function observer (obj) { Object.keys(obj).forEach(key =&gt; { // 保存属性初始值 let internalValue = obj[key] Object.defineProperty(obj, key, { get () { console.log(`getting key &quot;${key}&quot;: ${internalValue}`) return internalValue }, set (newValue) { console.log(`setting key &quot;${key}&quot; to: ${newValue}`) internalValue = newValue } }) })} 第二步 依赖收集 Dep实现效果即一个发布订阅模式 12345678910const dep = new Dep()autoRun(() =&gt; { dep.depend() console.log('updated')})// 打印: &quot;updated&quot;dep.notify()// 打印: &quot;updated&quot; 实现方式123456789101112131415161718192021222324252627class Dep { constructor() { this.subs = [] }; depend() { // 订阅函数 if (activeUpdate) { this.subs.push(activeUpdate); // 把全局变量activeUpdate存的函数放入订阅者列表 } } notify() { // 发布函数 this.subs.forEach(sub =&gt; sub()); }}let activeUpdate = null // 放置依赖函数function autoRun (update) { const wrappedUpdate = () =&gt; { activeUpdate = wrappedUpdate // 把wrappedUpdate存起来 update() // 在update内部调用dep.depend()收集依赖 activeUpdate = null } wrappedUpdate()} 第三步 整合一、二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Dep { constructor() { this.subs = [] }; depend() { if (activeUpdate) { this.subs.push(activeUpdate); } } notify() { this.subs.forEach(sub =&gt; sub()); }}export class Observer { constructor(obj) { this.dep = new Dep(); this.walk(obj); } walk(obj) { Object.keys(obj).forEach(key =&gt; { this.defineReactive(obj, key); }) } defineReactive(obj, key) { let that = this; let internalValue = obj[key]; Object.defineProperty(obj, key, { enumerable: false, configurable: false, get() { that.dep.depend(); return internalValue; }, set(newVal) { const isChanged = internalValue !== newVal; if (isChanged) { internalValue = newVal; that.dep.notify(); } } }) }}let activeUpdate = null;export function autoRun (update) { const wrappedUpdate = () =&gt; { activeUpdate = wrappedUpdate // 把wrappedUpdate存起来 update() // 在update内部调用dep.depend()收集依赖 activeUpdate = null } wrappedUpdate()} 2. 虚拟DOM2.1虚拟DOM和真实的DOM的差异1.资源消耗问题 使用javascript操作真实DOM是非常消耗资源的，虽然很多浏览器做了优化但是效果不大。你看到虚拟DOM是一个纯javascript对象。而DOM节点有70＋个属性，继承层级有6，7层（文本节点6层，元素节点7层）,访问一个属性，可能会追溯几重原型链。 2.执行效率问题 如果你要修改一个真实DOM，一般调用innerHTML方法，那浏览器会把旧的节点移除再添加新的节点，但是在虚拟DOM中，只需要修改一个对象的属性，再把虚拟DOM渲染到真实DOM上。很多人会误解虚拟DOM比真实DOM速度快，其实虚拟DOM只是把DOM变更的逻辑提取出来，使用javascript计算差异，减少了操作真实DOM的次数，只在最后一次才操作真实DOM，所以如果你的应用有复杂的DOM变更操作，虚拟DOM会比较快。 3.虚拟DOM还有其他好处 其实虚拟DOM还可以应用在其他地方，因为他们只是抽象节点，可以把它编译成其他平台，例如android、ios。市面上利用形同架构模式的应用有React Native，Weeks，Native script，就是利用虚拟DOM的特点实现的。 2.2 虚拟DOM在线查看使用Vue Template Explorer可以查看Vue是如何转换虚拟DOM的。 访问地址 3.template和jsx对比模版的优势：模版是一种更静态更具有约束的表现形态，它可以避免发明新语法，任何可以解析HTML的引擎都可以使用它，迁移成本更低；另外最重要的是静态模版可以在编译进行比较多的优化，而动态语言就没法实现了。 jsx的优势：更灵活，任何的js代码都可以放在jsx中执行实现你想要的效果，但是也由于他的灵活性导致在编译阶段优化比较困难，只能通过开发者自己优化。 4. 函数组件函数组件就是不包含state和props的组件，就像它的名字一样，你可以理解为他就是一个函数，在Vue中声明一个函数组件代码如下： 1234const foo = { functional: true, render: h =&gt; h('div', 'foo')} 特点 组件不支持实例化。 优化更优，因为在Vue中它的渲染函数比父级组件更早被调用，但是他并不会占用很多资源，因为它没有保存数据和属性，所以它常用于优化一个有很多节点的组件。 容易扩展，如果你的组件只是用来接收 prop然后显示数据，或者一个没有状态的按钮，建议使用函数组件。 函数组件没有this，获取prop可以通过render函数的第二参数得到render(h, context) 12345678910111213Vue.component('example', { functional: true, // 声明是函数组件 // 因为函数组件没有this,可以通过render第二参数获取相关信息 render(h, { props: { tags } }) { // context.slots() 通过slots方法获取子节点 // context.children 获取子组件 // context.parent 父组件，因为函数组件实挂载到根节点上，也就是&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; // context.props 组件属性，这里得到tags属性 // return h('div', this.tags.map((tag, i) =&gt; h(tag, i))) // 通过函数组件实现标签动态渲染 return h('div', tags.map((tag, i) =&gt; h(tag, i))) }}) 5.HOC 高阶组件 高阶组件是一个函数，接收一个组件，然后返回一个新的组件，类似装饰者模式 这里不展开说了，大概列一下写法，下面模拟了一个图片骨架 123456789101112131415161718192021222324252627282930313233343536373839// mock APIfunction fetchURL (username, cb) { setTimeout(() =&gt; { // hard coded, bonus: exercise: make it fetch from gravatar! cb('https://avatars3.githubusercontent.com/u/6128107?v=4&amp;s=200') }, 500)}const Avatar = { props: ['src'], template: `&lt;img :src=&quot;src&quot;&gt;`}function withAvatarURL (InnerComponent) { return { props: { attrs: this.$attrs, // 2.4 only username: String }, data () { return { url: 'http://via.placeholder.com/200x200' } }, created () { fetchURL(this.username, (url) =&gt; { this.url = url }) }, render (h) { return h(InnerComponent, { props: { src: this.url } }) } }}const SmartAvatar = withAvatarURL(Avatar)new Vue({ el: '#app', components: { SmartAvatar }}) 重用性：因为minxin对原组件具有侵入性，这会导致原来组件的可重用性降低，而高阶组件不会，高阶组件对原组件只是一个调用关系，并没有修改原来组件任何内容。 可测试性：因为高阶组件只是一个嵌套关系，在组件测试的时候，可以单独的测试原始组件和高阶组件。 层级问题：高阶组件也有他的弊端，如果你高阶组件嵌套层级太深，会导致出错的时候调试困难的问题，所以到底使用高阶组件和minxin需要看实际场景。 6. 路由实现根据路由匹配显示组件，并路由匹配参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 组件const Foo = { props: ['id'], template: `&lt;div&gt;foo with id: {{ id }}&lt;/div&gt;`}const Bar = { template: `&lt;div&gt;bar&lt;/div&gt;` }const NotFound = { template: `&lt;div&gt;not found!&lt;/div&gt;` }// 路由表const routeTable = { '/foo/:id': Foo, '/bar': Bar}// 将路由表的键通过 path-to-regexp库 进行正则封装// 下面这个数组储存：组件、正则对象、匹配的nameconst compiledRoutes = []Object.keys(routeTable).forEach(key =&gt; { const dynamicSegments = [] const regex = pathToRegexp(key, dynamicSegments) const component = routeTable[key] compiledRoutes.push({ component, regex, dynamicSegments })})// 监听hashchange，将改变的路由赋值给urlwindow.addEventListener('hashchange', () =&gt; { app.url = window.location.hash.slice(1)})const app = new Vue({ el: '#app', data: { url: window.location.hash.slice(1) }, render (h) { const path = '/' + this.url let componentToRender // 要渲染的组件 let props = {} // 路由匹配到的值 compiledRoutes.some(route =&gt; { const match = route.regex.exec(path) // 执行匹配 componentToRender = NotFound if (match) { componentToRender = route.component // 设置参数 route.dynamicSegments.forEach((segment, index) =&gt; { props[segment.name] = match[index + 1] }) return true } }) return h('div', [ h(componentToRender, { props }), h('a', { attrs: { href: '#foo/123' }}, 'foo 123'), ' | ', h('a', { attrs: { href: '#foo/234' }}, 'foo 234'), ' | ', h('a', { attrs: { href: '#bar' }}, 'bar'), ' | ', h('a', { attrs: { href: '#garbage' }}, 'garbage') ]) }})","link":"/2021/02/18/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AAfrontend%20Master%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"title":"MPA首屏加载速率优化实战","text":"背景​ 学校实验室的项目，因为学校只开放给我们一个端口，所以只能把后台管理和学生端合并成多页应用，我是做后台管理的，老师要求某个功能要加上代码高亮，在全局引入highlight.js后发现首屏加载速率不行了，记录一下发现更多问题并优化的过程。 有用的优化1. HighLight.js被放在首屏加载了首先用webpack-bundle-analyer进行构建分析 发现了两个巨大的包chunk-vendors.44cd6d2c.js有2.4MB，chunk-94715762.bb0c42f0.js有1.4MB，不幸的是c端需要在首屏同时下载两个大包（此处有误，后面讲解，正确的是左边这个包加入口）才开始渲染，而c端并没有用到highlight.js但是他也得等待下载。 然后把highlight.js放到封装的组件里引用，然后打包分析 发现就分离了，2.4MB的包变成了1.5MB 2. 两个应用使用的element组件没有分离但是又发现了新的问题——element-ui两个应用使用的组件被打包到了一起，即时c端没有使用到诸如el-upload、el-pagination等组件，但是也要首屏也要下载，想了想highlight.js被放到b端入口文件引入就被打进这个包里。 是不是两个入口使用了同一个element按需引入文件的原因，然后我给两个应用各开了自己的按需引入文件。打包分析没啥变化。 问了大哥，大哥甩手就是一个连接https://www.cnblogs.com/HYZhou2018/p/10419703.html 大概就是vue-cli3的脚手架配置自动分包的时候是针对单页应用的，下面是vue-cli3的配置项 splitChunks默认minChunks是1，但是我们是多页应用啊，所以两个应用使用的第三方库全被抽离到一个chunk-vendor.js了。 123456789101112config.optimization.splitChunks({ cacheGroups: { vendors: { name: 'chunk-vendors', minChunks: 2, // 设置为2，两个应用同时使用才抽离 test: /node_modules/, priority: -10, chunks: 'initial' }, common: {} }}); 再次打包分析 不仅分离了一些组件，还把一些使用到的第三方库给分离了，这个2.4MB的打包到此为止就变成了1.2MB的包。 2021/9/2 更新在上图可以看到，一些node_modules里的第三方库被打包到业务代码中了，这就导致了我们就算只是更新业务代码，但是用户也需要重新下载当前组件引用到的第三方库，我们可以设置更细粒度的分包，在cacheGroups中添加如下配置 123456789101112131415161718teacher: { name: &quot;chunk-teacher&quot;, test: /node_modules/, minChunks: 1, chunks(chunk) { return chunk.name === &quot;teacher&quot;; }, priority: -1,},student: { name: &quot;chunk-student&quot;, test: /node_modules/, minChunks: 1, chunks(chunk) { return chunk.name === &quot;student&quot;; }, priority: -1,}, 可以看到红框圈起来的就是新分出来的包，里面只有被引次数为1的第三方库，保证了业务和依赖的抽离 走过的坑1.怎么coding包还是在首屏下载了已经使用了路由懒加载，为什么coding包还是在首屏下载了，我曾一度以为是没有syntax-dynamic-import这个插件的原因，还装过了试了下，但是并没有什么用，而且webpack已经使用动态import来做到懒加载了。 查阅文章发现 原来 vue-cli3 默认会把所有通过import()按需加载的javascript文件加上 prefetch 。 prefetch是什么？在打包后的文件中，查看index.html我们会发现类似这个 。会在页面加载完成后，利用空闲时间提前加载获取用户未来可能会访问的内容。 prefetch链接会消耗宽带，如果是在移动端，而且存在大量的chunk，那么可以关掉 prefetch 链接，手动选择要提前获取的代码区块。 12//手动选定要提前获取的代码import(webpackPrefetch: true, './someAsyncComponent.vue') 关闭prefetch: (官网示例) 123456789101112131415// vue.config.jsmodule.exports = { chainWebpack: config =&gt; { // 移除 prefetch 插件 config.plugins.delete('prefetch') // 或者 // 修改它的选项： config.plugin('prefetch').tap(options =&gt; { options[0].fileBlacklist = options[0].fileBlacklist || [] options[0].fileBlacklist.push(/myasyncRoute(.)+?\\.js$/) return options }) }} 2. 第三方库怎么这么多重复的bn.js 可以看到有8个重复的bn.js，一个40KB，gzip后10KB，离谱。 但是大小是不一样的，可能用的版本不同，目前没有好的方法抽离。。 其实可以用cdn来搞，但是第三方的cdn不稳定，就没搞。 3. 打包后mini-css-extract-plugin警告Conflicting order对应的issus：https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250 是由于组件使用顺序不一致导致的。","link":"/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"},{"title":"适配器模式","text":"适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 适配器的别名是包装器(wrapper)，这是一个相对简单的模式 在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。 故事背景现在使用 谷歌地图 和 百度地图 在页面展现地图 1234567891011121314151617let googleMap = { show: function () { console.log(&quot;开始渲染谷歌地图&quot;); },};let baiduMap = { show: function () { console.log(&quot;开始渲染百度地图&quot;); },};let renderMap = function (map) { if (map.show instanceof Function) { map.show(); }};renderMap(googleMap); // 输出:开始渲染谷歌地图renderMap(baiduMap); // 输出:开始渲染百度地图 上面的代码能够运行成功是因为两个第三方均为show方法，如果两个接口提供调用的方式不一样，那么就不能运行了 重构1234567891011121314151617181920212223let googleMap = { show: function () { console.log(&quot;开始渲染谷歌地图&quot;); },};let baiduMap = { display: function () { console.log(&quot;开始渲染百度地图&quot;); },};let baiduMapAdapter = { show: function () { return baiduMap.display(); },};let renderMap = function (map) { if (map.show instanceof Function) { map.show(); }};renderMap(googleMap); // 输出:开始渲染谷歌地图renderMap(baiduMapAdapter); // 输出:开始渲染百度地图 总结 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。 装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。 外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。 参考《javascript设计模式与开发实践》","link":"/2021/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"状态模式","text":"允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变 故事背景我们来想象这样一个场景：有一个电灯，电灯上面只有一个开关。当电灯开着的时候，此时 按下开关，电灯会切换到关闭状态;再按一次开关，电灯又将被打开。同一个开关按钮，在不同 的状态下，表现出来的行为是不一样的 未使用状态模式123456789101112131415161718192021222324252627let Light = function () { this.state = &quot;off&quot;; // 给电灯设置初始状态 off this.button = null;// 电灯开关按钮};Light.prototype.init = function () { let button = document.createElement(&quot;button&quot;), self = this; button.innerHTML = &quot;开关&quot;; this.button = document.body.appendChild(button); this.button.onclick = function () { self.buttonWasPressed(); };};Light.prototype.buttonWasPressed = function () { if (this.state === &quot;off&quot;) { console.log(&quot;开灯&quot;); this.state = &quot;on&quot;; } else if (this.state === &quot;on&quot;) { console.log(&quot;关灯&quot;); this.state = &quot;off&quot;; }};let light = new Light();light.init(); 但是如果需要在新增状态，那么就得直接在buttonWasPressed里修改，不符合开闭原则。 状态模式重构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let OffLightState = function (light) { this.light = light;};OffLightState.prototype.buttonWasPressed = function () { console.log(&quot;弱光&quot;); // offLightState 对应的行为 this.light.setState(this.light.weakLightState);// 切换状态到 weakLightState};let WeakLightState = function (light) { this.light = light;};WeakLightState.prototype.buttonWasPressed = function () { console.log(&quot;强光&quot;); // weakLightState 对应的行为 this.light.setState(this.light.strongLightState); //切换状态到 strongLightState};let StrongLightState = function (light) { this.light = light;};StrongLightState.prototype.buttonWasPressed = function () { console.log(&quot;关灯&quot;); // strongLightState 对应的行为 this.light.setState(this.light.offLightState); // 切换状态到 offLightState};// 改写 Light 类，使用状态对象记录当前的状态let Light = function () { this.offLightState = new OffLightState(this); this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.button = null;};// 提供一个 方法来切换 light 对象的状态Light.prototype.init = function () { let button = document.createElement(&quot;button&quot;), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = &quot;开关&quot;; this.currState = this.offLightState; this.button.onclick = function () { self.currState.buttonWasPressed(); };};Light.prototype.setState = function (newState) { this.currState = newState;};let light = new Light();light.init(); 它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。 状态之间的切换都被分布在状态类内部，这使得我们无需编写过多的 if、else 条件 分支语言来控制状态之间的转换 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。 参考《javascript设计模式与开发实践》","link":"/2021/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"装饰者模式","text":"在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活， 还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的， 在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式 故事背景假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。 传统面向对象实现123456789101112131415161718192021222324252627let Plane = function () {};Plane.prototype.fire = function () { console.log(&quot;发射普通子弹&quot;);};// 导弹类let MissileDecorator = function (plane) { this.plane = plane;};MissileDecorator.prototype.fire = function () { this.plane.fire(); console.log(&quot;发射导弹&quot;);};// 原子弹类let AtomDecorator = function (plane) { this.plane = plane;};AtomDecorator.prototype.fire = function () { this.plane.fire(); console.log(&quot;发射原子弹&quot;);};let plane = new Plane();plane = new MissileDecorator(plane);plane = new AtomDecorator(plane);plane.fire(); 装饰者对象和它所装饰的对象拥有一致的接口，通过传入被装饰对象，调用其对应方法，并添加职责形成聚合对象。 动态语言实现1234567891011121314151617181920212223242526let plane = { fire: function () { console.log(&quot;发射普通子弹&quot;); },};let missileDecorator = function () { console.log(&quot;发射导弹&quot;);};let atomDecorator = function () { console.log(&quot;发射原子弹&quot;);};let fire1 = plane.fire;plane.fire = function () { fire1(); missileDecorator();};let fire2 = plane.fire;plane.fire = function () { fire2(); atomDecorator();};plane.fire(); 因为js可以直接修改对象或者对象的某个方法，那么可以通过一个变量a暂存被装饰函数，然后替换旧方法，在新方法内通过a调用旧方法。 但是直接替换有this指向问题。 AOP实现12345678910111213141516Function.prototype.before = function (beforefn) { let _self = this; // 保存原函数的引用 return function () { // 返回包含了原函数和新函数的&quot;代理&quot;函数 beforefn.apply(this, arguments); // 执行新函数，且保证 this 不被劫持，新函数接受的参数 // 也会被原封不动地传入原函数，新函数在原函数之前执行 return _self.apply(this, arguments); // 执行原函数并返回原函数的执行结果， // 并且保证 this 不被劫持 };};Function.prototype.after = function (afterfn) { let _self = this; return function () { let ret = _self.apply(this, arguments); afterfn.apply(this, arguments); return ret; };}; 缺点 通过AOP实际上放回的是新函数，在原函数上保存的属性则会丢失 叠加了作用域，如果装饰的链条过长，性能上会受到影响 与代理模式的区别代理模式的目的：当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。 装饰者模式的作用：为对象动态的加入行为。 换句话说，代理模式的关系一开始就可以被确定，而装饰者模式用于一开始不能确定对象的全部功能时 参考《javascript设计模式与开发实践》","link":"/2021/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"中介者模式","text":"中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系 故事背景假如在玩泡泡堂的游戏，使用泡泡击败对方所有玩家才能获得胜利。现在将队伍分成两个组进行游戏 代码实现(未使用中介者模式)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 玩家function Player(name, teamColor) { this.partners = []; // 队友列表 this.enemies = []; // 敌人列表 this.state = &quot;live&quot;; // 玩家状态 this.name = name; // 角色名字 this.teamColor = teamColor; // 队伍颜色}Player.prototype.win = function () { // 玩家团队胜利 console.log(&quot;winner: &quot; + this.name);};Player.prototype.lose = function () { // 玩家团队失败 console.log(&quot;loser: &quot; + this.name);};// 玩家死亡的方法Player.prototype.die = function () { // 玩家死亡 let all_dead = true; this.state = &quot;dead&quot;; // 设置玩家状态为死亡 for (let i = 0, partner; partner = this.partners[i++];) { // 遍历队友列表 if (partner.state !== &quot;dead&quot;) { // 如果还有一个队友没有死亡，则游戏还未失败 all_dead = false; break; } } if (all_dead === true) { // 如果队友全部死亡 this.lose(); // 通知自己游戏失败 for (let i = 0, partner; partner = this.partners[i++];) { partner.lose(); } for (let i = 0, enemy; enemy = this.enemies[i++];) { enemy.win(); } }};// 定义一个工厂来创建玩家let playerFactory = function (name, teamColor) { let newPlayer = new Player(name, teamColor); for (let i = 0, player; player = players[i++];) { // 通知所有的玩家，有新角色加入 if (player.teamColor === newPlayer.teamColor) { // 如果是同一队的玩家 player.partners.push(newPlayer); // 相互添加到队友列表 newPlayer.partners.push(player); } else { player.enemies.push(newPlayer); // 相互添加到敌人列表 newPlayer.enemies.push(player); } } players.push(newPlayer); return newPlayer;};let players = [];//红队:let player1 = playerFactory(&quot;皮蛋&quot;, &quot;red&quot;), player2 = playerFactory(&quot;小乖&quot;, &quot;red&quot;), player3 = playerFactory(&quot;宝宝&quot;, &quot;red&quot;), player4 = playerFactory(&quot;小强&quot;, &quot;red&quot;);//蓝队:let player5 = playerFactory(&quot;黑妞&quot;, &quot;blue&quot;), player6 = playerFactory(&quot;葱头&quot;, &quot;blue&quot;), player7 = playerFactory(&quot;胖墩&quot;, &quot;blue&quot;), player8 = playerFactory(&quot;海盗&quot;, &quot;blue&quot;);// 让红队玩家全部死亡:player1.die();player2.die();player4.die();player3.die(); 每个玩家添加或者死亡，都必须修改所有其他玩家内部的队友列表和敌人列表。耦合度很高。 代码重构(使用中介者模式)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 玩家function Player(name, teamColor) { this.state = &quot;live&quot;; // 玩家状态 this.name = name; // 角色名字 this.teamColor = teamColor; // 队伍颜色}Player.prototype.win = function(){ console.log( this.name + ' won ' );};Player.prototype.lose = function(){ console.log( this.name +' lost' );};/*******************玩家死亡*****************/Player.prototype.die = function () { this.state = &quot;dead&quot;; playerDirector.receiveMessage(&quot;playerDead&quot;, this);// 给中介者发送消息，玩家死亡};/*******************移除玩家*****************/Player.prototype.remove = function () { // 给中介者发送消息，移除一个玩家 playerDirector.receiveMessage(&quot;removePlayer&quot;, this);};/*******************玩家换队*****************/Player.prototype.changeTeam = function (color) { playerDirector.receiveMessage(&quot;changeTeam&quot;, this, color); // 给中介者发送消息，玩家换队};/*******************定义中介者对象*****************/let playerDirector = (function () { let players = {}, // 保存所有玩家 operations = {}; // 中介者可以执行的操作 /****************新增一个玩家***************************/ operations.addPlayer = function (player) { let teamColor = player.teamColor; // 玩家的队伍颜色 players[teamColor] = players[teamColor] || []; // 如果该颜色的玩家还没有成立队伍，则新成立一个队伍 players[teamColor].push(player); // 添加玩家进队伍 }; /****************移除一个玩家***************************/ operations.removePlayer = function (player) { let teamColor = player.teamColor, // 玩家的队伍颜色 teamPlayers = players[teamColor] || []; // 该队伍所有成员 for (let i = teamPlayers.length - 1; i &gt;= 0; i--) { // 遍历删除 if (teamPlayers[i] === player) { teamPlayers.splice(i, 1); } } }; /****************玩家换队***************************/ operations.changeTeam = function (player, newTeamColor) { // 玩家换队 operations.removePlayer(player); // 从原队伍中删除 player.teamColor = newTeamColor; // 改变队伍颜色 operations.addPlayer(player);// 增加到新队伍中 }; /****************玩家死亡***************************/ operations.playerDead = function (player) { // 玩家死亡 let teamColor = player.teamColor, teamPlayers = players[teamColor]; // 玩家所在队伍 let all_dead = true; for (let i = 0, player; player = teamPlayers[i++];) { if (player.state !== &quot;dead&quot;) { all_dead = false; break; } } if (all_dead === true) {// 全部死亡 for (let i = 0, player; player = teamPlayers[i++];) { player.lose(); // 本队所有玩家 lose } for (let color in players) { if (color !== teamColor) { let teamPlayers = players[color]; // 其他队伍的玩家 for (let i = 0, player; player = teamPlayers[i++];) { player.win(); // 其他队伍所有玩家 win } } } } }; let receiveMessage = function () { let message = Array.prototype.shift.call(arguments); operations[message].apply(this, arguments); }; return { receiveMessage: receiveMessage, };})();/*******************设置工厂函数*****************/let playerFactory = function (name, teamColor) { let newPlayer = new Player(name, teamColor); // 创造一个新的玩家对象 playerDirector.receiveMessage(&quot;addPlayer&quot;, newPlayer); // 给中介者发送消息，新增玩家 return newPlayer;};//红队let player1 = playerFactory(&quot;皮蛋&quot;, &quot;red&quot;), player2 = playerFactory(&quot;小乖&quot;, &quot;red&quot;), player3 = playerFactory(&quot;宝宝&quot;, &quot;red&quot;), player4 = playerFactory(&quot;小强&quot;, &quot;red&quot;);// 蓝队:let player5 = playerFactory(&quot;黑妞&quot;, &quot;blue&quot;), player6 = playerFactory(&quot;葱头&quot;, &quot;blue&quot;), player7 = playerFactory(&quot;胖墩&quot;, &quot;blue&quot;), player8 = playerFactory(&quot;海盗&quot;, &quot;blue&quot;);player1.die();player2.die();player3.die();player4.die(); 现在玩家与玩家之间的耦合消除了，所有操作逻辑在中介者对象中实现，玩家只需要向中介者发生消息，中介者会把处理结果反馈给其他玩家对象。 使用时机中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说， 如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。 小结中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象，而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。 中介者模式也存在一些缺点。其中最大的缺点是系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。 参考《javascript设计模式与开发实践》","link":"/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"职责链模式","text":"职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对 象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点 场景​ 假设我们负责一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。 ​ 在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。 orderType：订单类型 pay：用户是否已经支付定金 stock：用于普通用户，普通购买的手机库存数量 代码实现（未使用职责链模式）123456789101112131415161718192021222324252627282930let order = function (orderType, pay, stock) { if (orderType === 1) { // 500 元定金购买模式 if (pay === true) { // 已支付定金 console.log(&quot;500 元定金预购, 得到 100 优惠券&quot;); } else { // 未支付定金，降级到普通购买模式 if (stock &gt; 0) { // 用于普通购买的手机还有库存 console.log(&quot;普通购买, 无优惠券&quot;); } else { console.log(&quot;手机库存不足&quot;); } } } else if (orderType === 2) { if (pay === true) { // 200 元定金购买模式 console.log(&quot;200 元定金预购, 得到 50 优惠券&quot;); } else { if (stock &gt; 0) { console.log(&quot;普通购买, 无优惠券&quot;); } else { console.log(&quot;手机库存不足&quot;); } } } else if (orderType === 3) { if (stock &gt; 0) { console.log(&quot;普通购买, 无优惠券&quot;); } else { console.log(&quot;手机库存不足&quot;); } }};order(1, true, 500); // 输出: 500 元定金预购, 得到 100 优惠券 用职责链模式重构代码​ 先把 500 元订单、200 元订单以及普通购买分成 3 个函数。 ​ 接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let order500 = function (orderType, pay, stock) { if (orderType === 1 &amp;&amp; pay === true) { console.log(&quot;500 元定金预购，得到 100 优惠券&quot;); } else { return &quot;nextSuccessor&quot;; // 我不知道下一个节点是谁，反正把请求往后面传递 }};let order200 = function (orderType, pay, stock) { if (orderType === 2 &amp;&amp; pay === true) { console.log(&quot;200 元定金预购，得到 50 优惠券&quot;); } else { return &quot;nextSuccessor&quot;; // 我不知道下一个节点是谁，反正把请求往后面传递 }};let orderNormal = function (orderType, pay, stock) { if (stock &gt; 0) { console.log(&quot;普通购买，无优惠券&quot;); } else { console.log(&quot;手机库存不足&quot;); }};// Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点let Chain = function (fn) { this.fn = fn; this.successor = null;};Chain.prototype.setNextSuccessor = function (successor) { return this.successor = successor;};Chain.prototype.passRequest = function () { let ret = this.fn.apply(this, arguments); if (ret === &quot;nextSuccessor&quot;) { return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments); } return ret;};let chainOrder500 = new Chain(order500);let chainOrder200 = new Chain(order200);let chainOrderNormal = new Chain(orderNormal);chainOrder500.setNextSuccessor(chainOrder200);chainOrder200.setNextSuccessor(chainOrderNormal);chainOrder500.passRequest(1, true, 500); // 输出:500 元定金预购，得到 100 优惠券chainOrder500.passRequest(2, true, 500); // 输出:200 元定金预购，得到 50 优惠券chainOrder500.passRequest(3, true, 500); // 输出:普通购买，无优惠券chainOrder500.passRequest(1, false, 0); // 输出:手机库存不足 异步的职责链​ 在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个 ajax 异步请求，异步请求返回的结果才能决定是否继续在职责链中 passRequest。 这时候让节点函数同步返回 “nextSuccessor” 已经没有意义了，所以要给 Chain 类再增加一个原型方法 Chain.prototype.next，表示手动传递请求给职责链中的下一个节点 1234567891011121314151617181920212223Chain.prototype.next = function () { return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments);};// 异步职责链let fn1 = new Chain(function () { console.log(1); return &quot;nextSuccessor&quot;;});let fn2 = new Chain(function () { console.log(2); let self = this; setTimeout(function () { self.next(); }, 1000);});let fn3 = new Chain(function () { console.log(3);});fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);fn1.passRequest(); 现在我们得到了一个特殊的链条，请求在链中的节点里传递，但节点有权利决定什么时候把 请求交给下一个节点。可以想象，异步的职责链加上命令模式(把 ajax 请求封装成命令对象)，我们可以很方便地创建一个异步 ajax 队列库。 AOP实现职责链123456789101112131415Function.prototype.after = function (fn) { let self = this; return function () { let ret = self.apply(this, arguments); if (ret === &quot;nextSuccessor&quot;) { return fn.apply(this, arguments); } return ret; };};let order = order500.after(order200).after(orderNormal);order(1, true, 500); // 输出:500 元定金预购，得到 100 优惠券order(2, true, 500); // 输出:200 元定金预购，得到 50 优惠券order(1, false, 500); // 输出:普通购买，无优惠券 缺点但是职责链模式并不能保证某个请求一定会被链中的节点处理，而是径直的从链尾离开，这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。 并且职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链 参考《javascript设计模式与开发实践》","link":"/2021/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"title":"享元模式","text":"享元(flyweight)模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为“蝇量级”。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。 故事背景​ 假设有个内衣工厂，目前的产品有 50 种男式内衣和 50 种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。 正常情况下需要 50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照。 代码实现(未使用享元模式)1234567891011121314151617181920class Model { constructor(sex, underwear) { this.sex = sex; this.underwear = underwear; } takePhoto() { console.log('sex= ' + this.sex + ' underwear=' + this.underwear); };}for (let i = 1; i &lt;= 50; i++) { let maleModel = new Model('male', 'underwear' + i); maleModel.takePhoto();}for (let j = 1; j &lt;= 50; j++) { let femaleModel = new Model('female', 'underwear' + j); femaleModel.takePhoto();} 思考：真的需要如此多数量的对象吗？​ 如上所述，现在一共有 50 种男内 衣和 50 种女内衣，所以一共会产生 100 个对象。如果将来生产了 10000 种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。 下面我们来考虑一下如何优化这个场景。虽然有 100 种内衣，但很显然并不需要 50 个男模特和 50 个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照。 代码重构(享元模式)123456789101112131415161718192021222324252627// 只需要区别男女模特// 那我们先把 underwear 参数从构造函数中 移除，构造函数只接收 sex 参数class Model { constructor(sex) { this.sex = sex; } takePhoto() { console.log('sex= ' + this.sex + ' underwear=' + this.underwear); };}// 分别创建一个男模特对象和一个女模特对象let maleModel = new Model('male'), femaleModel = new Model('female');// 给男模特依次穿上所有的男装，并进行拍照for (let i = 1; i &lt;= 50; i++) { maleModel.underwear = 'underwear' + i; // 设置外部状态 maleModel.takePhoto();}// 给女模特依次穿上所有的女装，并进行拍照for (let j = 1; j &lt;= 50; j++) { femaleModel.underwear = 'underwear' + j; // 设置外部状态 femaleModel.takePhoto();} 只需要两个对象便完成了同样的功能 如何使用享元模式享元模式要求将对象的属性划分为内部状态与外部状态(状态在这里通常指属性)。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引 内部状态可以被一些对象共享 内部状态独立于具体的场景，通常不会改变 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享 在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要 2 个对象。 享元模式的通用结构问题引入 我们通过构造函数显示new出了男女两个model对象，在其他系统中，也许并不是一开始就需要所有的共享对象 给model对象手动设置了underwear外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能相当复杂，它们与共享对象的联系会变得困难 解决方案第一个问题可以用工厂模式解决，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象 第二个问题可以用一个管理器记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来 享元模式的替代方案 —— 对象池​ 对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。 通用的对象池实现123456789101112131415// 通用的对象池let objectPoolFactory = function (createObjFn) { let objectPool = []; return { create: function () { return objectPool.length === 0 ? createObjFn.apply(this, arguments) : objectPool.shift(); }, recover: function (obj) { objectPool.push(obj); }, };}; 现在利用objectPoolFactory来创建一个装载一些 iframe 的对象池 1234567891011121314151617181920let iframeFactory = objectPoolFactory(function () { let iframe = document.createElement(&quot;iframe&quot;); document.body.appendChild(iframe); iframe.onload = function () { iframe.onload = null; // 防止 iframe 重复加载的 bug iframeFactory.recover(iframe);// iframe 加载完成之后回收节点 }; return iframe;});let iframe1 = iframeFactory.create();iframe1.src = &quot;http:// baidu.com&quot;;let iframe2 = iframeFactory.create();iframe2.src = &quot;http:// QQ.com&quot;;setTimeout(function () { let iframe3 = iframeFactory.create(); iframe3.src = &quot;http:// 163.com&quot;;}, 3000); 对象池的应用非常广泛，HTTP连接池和数据库连接池都是其代表应用，也可以用在dom的重复利用上。 参考《javascript设计模式与开发实践》","link":"/2021/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"title":"模板方法模式","text":"在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行 Coffee or Tea我们现在需要冲泡一杯咖啡和一壶茶，它们的操作步骤基本上是一样的，如下所示 泡咖啡 泡茶 把水煮沸 把水煮沸 用沸水冲泡咖啡 用沸水浸泡茶叶 把咖啡倒进杯子 把茶水倒进杯子 加糖和牛奶 加柠檬 基本的步骤是一样的，我们可以使用抽象类的形式，把步骤框架抽象出来，Coffee类和Tea类继承这个抽象类，再各自实现抽象父类上的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 创建一个抽象父类来表示泡一杯饮料的整个过程。// 不论是 Coffee,还是 Tea,都被我们用Beverage来表示class Beverage { boilWater() { console.log('把水煮沸'); }; brew() { throw new Error('子类必须重写 brew 方法'); }; pourInCup() { throw new Error('子类必须重写 pourInCup 方法'); }; addCondiments() { throw new Error('子类必须重写 addCondiments 方法'); }; init() { // 模板方法 this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); };}// 创建Coffee类class Coffee extends Beverage { brew() { console.log('用沸水冲泡咖啡'); }; pourInCup() { console.log('把咖啡倒进杯子'); }; addCondiments() { console.log('加糖和牛奶'); };}let coffee = new Coffee();coffee.init();// 把水煮沸// 用沸水冲泡咖啡// 把咖啡倒进杯子// 加糖和牛奶// 创建Tea类class Tea extends Beverage { brew() { console.log('用沸水浸泡茶叶'); }; pourInCup() { console.log('把茶倒进杯子'); }; addCondiments() { console.log('加柠檬'); };}let tea = new Tea();tea.init();// 把水煮沸// 用沸水浸泡茶叶// 把茶倒进杯子// 加柠檬 上面代码中，Beverage父类里的init方法即为模板方法，init封装了子类的算法框架，作为算法的模板，指导子类以何种顺序去执行哪些方法。 好莱坞原则​ 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。” 在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对 待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。​ 比如发布订阅模式和回调函数 是否真的需要继承在JavaScript这种灵活的语言中，我们是否真的需要使用继承这种重武器呢。在好莱坞原则的指导下，我们可以重构上面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Beverage = function (param) { let boilWater = function () { console.log('把水煮沸'); }; let brew = param.brew || function () { throw new Error('必须传递 brew 方法'); }; let pourInCup = param.pourInCup || function () { throw new Error('必须传递 pourInCup 方法'); }; let addCondiments = param.addCondiments || function () { throw new Error('必须传递 addCondiments 方法'); }; let F = function () {}; F.prototype.init = function () { boilWater(); brew(); pourInCup(); addCondiments(); }; return F;};let Coffee = Beverage({ brew() { console.log('用沸水冲泡咖啡'); }, pourInCup() { console.log('把咖啡倒进杯子'); }, addCondiments() { console.log('加糖和牛奶'); }});let Tea = Beverage({ brew() { console.log('用沸水浸泡茶叶'); }, pourInCup() { console.log('把茶倒进杯子'); }, addCondiments() { console.log('加柠檬'); }}); 总结​ 模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的。 参考《javascript设计模式与开发实践》","link":"/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"组合模式","text":"组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。 除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性 ​ 在组合模式中，请求在树中传递的过程总是遵循一种逻辑。请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象(普通子命令)，叶对象自身会对请求作出相应的处理，如果当前处理请求的对象是组合对象(宏命令)， 组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。 组合模式下更为强大的宏命令​ 目前的万能遥控器，包含了关门、开电脑、登录 QQ 这 3 个命令。现在我们需要一个“超级万能遥控器”，可以控制家里所有的电器，这个遥控器拥有以下功能 打开空调 打开电视和音响 关门、开电脑、登录 QQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465let MacroCommand = function () { return { commandsList: [], add: function (command) { this.commandsList.push(command); }, execute: function () { for (let i = 0, command; command = this.commandsList[i++];) { command.execute(); } } }};let openAcCommand = { execute: function () { console.log('打开空调'); }};// 家里的电视和音响是连接在一起的，所以可以用一个宏命令来组合打开电视和打开音响的命令let openTvCommand = { execute: function () { console.log('打开电视'); }};let openSoundCommand = { execute: function () { console.log('打开音响'); }};let macroCommand1 = MacroCommand();macroCommand1.add(openTvCommand);macroCommand1.add(openSoundCommand);// 关门、打开电脑和打登录 QQ 的命令let closeDoorCommand = { execute: function () { console.log('关门'); }};let openPcCommand = { execute: function () { console.log('开电脑'); }};let openQQCommand = { execute: function () { console.log('登录 QQ'); }};let macroCommand2 = MacroCommand();macroCommand2.add(closeDoorCommand);macroCommand2.add(openPcCommand);macroCommand2.add(openQQCommand);// 现在把所有的命令组合成一个“超级命令”let macroCommand = MacroCommand();macroCommand.add(openAcCommand);macroCommand.add(macroCommand1);macroCommand.add(macroCommand2);// 最后给遥控器绑定“超级命令”let setCommand = (function (command) { document.getElementById('button').onclick = function () { command.execute(); }})(macroCommand); ​ 不管是宏命令对象，还是子命令对象，都有一个execute方法负责执行命令。​ 这在静态类型语言中实现显的尤为便利，比如在JAVA中，Composite类和Leaf类都必须继承自一个Compenent抽象类，这个Compenent抽象即表示组合对象，又代表叶对象，它也能保证两者均有execute方法，从而做出反馈。 ​ 但是在JavaScript这种动态语言中实现组合模式，由于鸭子类型，我们并不需要有一个Compenent抽象类，但是这也导致了一定的严谨性。 透明性带来的安全问题我们可以给叶子节点也增加add方法，并在调用的时候，抛出一个异常来提醒客户。比如上面的打开电视的命令对象： 12345678let openTvCommand = { execute: function () { console.log('打开电视'); }, add: function () { // 同样的添加add方法 throw new Error(&quot;叶对象不能添加子节点&quot;); }}; 应用场景 — 扫描文件夹​ 文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树 当使用用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。 注意组合模式不是父子关系​ 组合模式是一种HAS-A（聚合）的关系，而不是IS-A；Leaf并不是Composite的子类。 对叶对象操作的一致性​ 组合模式除了要求组合对象和叶子对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作的一致性。 ​ 比如公司要给全体员工发元旦的过节费1000元，这个场景可以运用组合模式，但如果公司要给今天过生日的员工发送一封生日祝福的邮件，组合模式就做不到了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每一个叶子对象的时候，才适合使用组合模式。 双向映射关系​ 发放过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但某些员工可能隶属于多个组织，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该员工可能收到多份过节费。 ​ 这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。 用职责链模式提高组合模式性能​ 在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现的不够理想，我们可以借助职责链模式避免遍历整棵树。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象位置。 引用父对象在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递 在文件系统中，当我们删除某个文件夹的时候，实际上是从这个文件夹所在的上层文件夹中删除改文件的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Folder { constructor(name) { this.name = name; this.parent = null; // 增加 this.parent 属性 this.files = []; } add(file) { file.parent = this; // 设置父对象 this.files.push(file); } scan() { console.log('开始扫描文件夹: ' + this.name); for (let i = 0, file, files = this.files; file = files[i++];) { file.scan(); } }; remove() { if (!this.parent) { // 根节点或者树外的游离节点 return; } for (let files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) { // 从父目录下搜索删除当前文件或文件夹 let file = files[l]; if (file === this) { files.splice(l, 1); } } };}class File { constructor(name) { this.name = name; this.parent = null; } add() { throw new Error('不能添加在文件下面'); } scan() { console.log('开始扫描文件: ' + this.name); } remove() { if (!this.parent) { //根节点或者树外的游离节点 return; } for (let files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) { let file = files[l]; if (file === this) { files.splice(l, 1); } } };} 何时使用组合模式 表示对象的部分-整体层次结构。组合模式可以方便的构造一棵树来表示对象的部分-整体结构。特别是我们不确定该树到底存在多少层次的时候 用户希望以统一的方式对待树中的所有对象 缺点​ 组合模式并不是完美的，它可能会产生一个这样的系统:系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。此外,如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。 参考《javascript设计模式与开发实践》","link":"/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"title":"命令模式","text":"将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作 应用场景​ 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 菜单案例场景 假设我们正在编写一个用户界面程序，该用户界面上至少有数十个 Button 按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。 在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个 按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定onclick 事件呢? 我们很快可以找到在这里运用命令模式的理由:点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。 代码实现1234567891011121314let RefreshMenuBarCommand = function (receiver) { return { execute: function () { receiver.refresh(); } }};let setCommand = function (button, command) { button.onclick = function () { command.execute(); }};let refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);setCommand(button1, refreshMenuBarCommand); 撤销和重做命令场景 命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。现在页面上有游戏需要对已经进行的操作进行回放 1234567891011121314151617181920212223242526272829303132333435363738394041424344let Ryu = { attack() { console.log(&quot;攻击&quot;); }, defense() { console.log(&quot;防御&quot;); }, jump() { console.log(&quot;跳跃&quot;); }, crouch() { console.log(&quot;蹲下&quot;); },}let makeCommand = function (receiver, state) { return receiver[state];}let commands = { &quot;119&quot;: &quot;jump&quot;, // w &quot;115&quot;: &quot;crouch&quot;, // s &quot;97&quot;: &quot;defense&quot;, // a &quot;100&quot;: &quot;attack&quot;, // d}let commandStack = []; // 保存命令的堆栈document.onkeypress = function (e) { let keyCode = e.keyCode; let command = makeCommand(Ryu, commands[keyCode]); if (command) { command(); commandStack.push(command); }}document.getElementById(&quot;replay&quot;).onclick = function () { // 点击播放录像 let command; while (command = commandStack.shift()) { // 从堆栈获取此前的命令并执行 command(); }} 《javascript设计模式与开发实践》书上的这个例子写的更像是策略模式，书上为了和策略模式区分还把receiver[state]()用一个匿名函数给包起来，被我给删了，不要为了用设计模式而用设计模式。其实策略模式是对一系列算法的封装，使他们互相可替换，但命令模式是对一系列命令对象的封装，使接受者和发送者解耦。 宏命令​ 宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，它就会帮我们关上房间门，顺便打开电脑并登录 QQ。 1234567891011121314151617181920212223242526272829303132333435let closeDoorCommand = { execute: function () { console.log('关门'); }};let openPcCommand = { execute: function () { console.log('开电脑'); }};let openQQCommand = { execute: function () { console.log('登录 QQ'); }};let MacroCommand = function () { return { commandsList: [], add: function (command) { // 给宏命令添加指令 this.commandsList.push(command); }, execute: function () { // 执行宏命令 for (let i = 0, command; command = this.commandsList[i++];) { command.execute(); } } }};let macroCommand = MacroCommand();macroCommand.add(closeDoorCommand); macroCommand.add(openPcCommand);macroCommand.add(openQQCommand);macroCommand.execute(); 智能命令与傻瓜命令​ 上一个例子的命令没用包含任何receiver的信息，它本身就包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个receiver是矛盾的。 ​ 一般来说，命令模式都会在command对象中保存一个接受者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接受者来执行，这种模式的好处是请求的发起者和请求的接受者之间尽可能的解耦。 ​ “聪明”的命令对象可以直接实现请求，这样一来就不需要接收者的存在，和策略模式非常接近，但命令模式解决的问题更具发散性。 ​ 命令模式还可以完成撤销、排队等功能 参考《javascript设计模式与开发实践》","link":"/2021/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"title":"发布-订阅模式","text":"又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知 在js中，有一种很简单发布订阅模式，也就是DOM事件，addEventListener就可以实现订阅dom节点上的事件，触发事件后就执行回调 1. 自定义事件实现发布订阅的步骤 指定好发布者 为发布者添加一个缓存列表，用以存放回调函数以通知订阅者 发布消息的时候，发布者会遍历这个缓存列表，依次触发订阅者回调函数。 下面用代码实现一下发布-订阅模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 订阅者回调函数interface Observers { [event: string]: Array&lt;Function&gt;}// 发布者let publisher = { observers: &lt;Observers&gt;{}, // 存放订阅者回调函数 // 增加订阅者 add(event, fn) { if (!this.observers[event]) { this.observers[event] = []; } this.observers[event].push(fn); // 添加订阅者到缓存列表 }, // 移除订阅者 remove(event, fn) { let fns = this.observers[event]; if (!fns) { // 如果该事件没有订阅者，则返回 return false; } if (!fn) { // 如果没有传入订阅者回调函数，则表示取消该事件的所有订阅者 fns &amp;&amp; (fns.length = 0); } else { for (let l = fns.length - 1; l &gt;= 0; l--) { if (fns[l] === fn) { fns.splice(l, 1); } } } }, // 发布消息，通知所有订阅者 trigger(event, ...args) { let fns = this.observers[event]; if (!fns || fns.length === 0) { // 如果没有订阅者，返回false return false; } for (let i = 0, fn; fn = fns[i++];) { fn.apply(this, args); // 触发订阅者回调函数 } },} 如果要实现一个通用的发布-订阅模式 12345let installEvent = function(obj) { for (let i in publisher) { obj[i] = publisher[i]; }} 接下来我们来尝试使用一下 123456789101112131415let salesOffices: any = {};installEvent(salesOffices);salesOffices.add('squareMeter88', function(price) { console.log('小美') console.log('价格=' + price);})salesOffices.add('squareMeter100', function (price) { console.log('小明') console.log('价格=' + price);})salesOffices.trigger('squareMeter88', 20000); // 小明 20000salesOffices.trigger('squareMeter100', 30000); // 小美 30000 但是这样salesOffices对象依旧具有耦合度，订阅者必须知道发布者的名字，才能订阅到事件，可以使用全局的发布者Event对象进行发布，就像vue中的eventBus，这样做虽然减少了耦合度，但是消息来自哪个模块，以及会流向哪个模块都是不直观的，容易带来维护性上的问题，并且通过全局的来订阅发布消息，容易造成命名冲突。 2.发布-订阅模式的两种模型 推模型：当一个事件发生后将通知所有订阅者，并把所有的新数据传给他们 拉模型：当一个事件发生后将通知所有订阅者，每个订阅者将拉取自己需要的数据 可以让订阅者按需获取 但有可能让发布者变成一个“门户大开”的对象，同时增加代码量和复杂度 参考《javascript设计模式与开发实践》","link":"/2021/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"title":"迭代器模式","text":"是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 js有许多迭代器模式实现，比如说forEach，es6的yield 1. 内部迭代器和外部迭代器1.1 内部迭代器 内部定义好迭代规则，外部只需要一次初始调用 比如说jquery的$.each，以及js的for...of 1.2 外部迭代器 显示的请求迭代下一个元素，迭代流程由外部控制 比如说es6的迭代器yield 2. 实现一个$.each的迭代器可以遍历类数组对象以及字面量对象 12345678910111213141516171819202122232425262728function each(obj, callback) { let length, i = 0; // 判断是否为类数组对象 if (isArrayLike(obj)) { length = obj.length; for (; i &lt; length; i++) { // 如果回调函数放回false，中断迭代器 if (callback.call(obj[i], i, obj[i]) === false) { break; } } } else { for (i in obj) { if (callback.call(obj[i], i, obj[i]) === false) { break; } } } return obj}let data = { 0: &quot;a&quot;, 1: &quot;b&quot;, length: 2 }each(data, (key, val) =&gt; { console.log(key, val); // 0 a // 1 b}); 3. 手动实现es6的简易迭代器12345678910111213141516171819202122// 定义生成器函数，入参是任意集合function iteratorGenerator(list) { // idx记录当前访问的索引 let idx = 0; // len记录传入集合的长度 const len = list.length; return { // 自定义next方法 next: function() { // 如果索引还没有超出集合长度，done 为 false const done = idx &gt;= len; // 如果done为false，则可以继续取值 const value = !done ? list[idx++] : undefined; // 将当前值与遍历是否完毕（done）返回 return { done: done, value: value } } }} 参考《javascript设计模式与开发实践》《JavaScript 设计模式核⼼原理与应⽤实践》","link":"/2021/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"代理模式","text":"为其他对象提供一种代理以控制对这个对象的访问 特点如下 代理对象可预先处理请求，再决定是否转交给本体； 代理和本体对外显示接口保持一致性 代理对象仅对本体做一次包装 1. 模式细分 虚拟代理（将开销大的运算交给代理，延迟到需要时执行） 缓存代理（为开销大的运算结果提供缓存） 保护代理（用于对象应该有不同的访问权限） 防火墙代理（控制网络资源的访问） 远程代理（为一个对象在不同的地址控件提供局部代表） 智能引用代理（访问对象执行一些附加操作） 写时复制代理（延迟对象复制过程，对象需要真正修改时才进行） 2. 虚拟代理实现图片预加载在所需图片未加载前，用loading图片占位，然后用异步的方式加载图片，等图片加载好了，替换掉loading，下面先不用代理模式实现 12345678910111213141516let MyImage = (function() { let imgNode = document.createElement('img'); document.body.appendChild(imgNode); let img = new Image; img.onload = function () { imgNode.src = img.src; // 图片加载完成后替换loading }; return { setSrc: function (src) { imgNode.src = &quot;file://loading.gif&quot;; // 先显示loading图片 img.src = src; // 虚拟dom结构加载图片 } }}) 违背了单一职责原则，在这种高耦合的情况下，如果不需要loading效果，那么只能在MyImage下动刀。 接下来我们用虚拟代理重构一下这段代码 123456789101112131415161718192021222324252627// 加载图片let myImage = (function () { let imgNode = document.createElement('img'); document.body.appendChild(imgNode); return { setSrc: function (src) { imgNode.src = src; } }})();// 虚拟代理let proxyImage = (function () { let img = new Image; img.onload = function () { myImage.setSrc(this.src); }; return { setSrc: function (src) { myImage.setSrc(&quot;file://loading.gif&quot;); img.src = src; } }})();proxyImage.setSrc( 'http://www.lll.com/photo/true.jpg' ); 这样就解耦了 3. 虚拟代理在惰性加载中的应用实现一个等用户按F2唤出控制台的时候，再开始加载miniConsole.js代码，并在加载完成后执行cache中的log函数 1234567891011121314151617181920212223242526272829let miniConsole = (function () { let cache = []; let handler = function (e) { if (e.keyCode === 113) { let script = document.createElement(&quot;script&quot;); script.onload = function () { for (let i = 0, fn; fn = cache[i++];) { fn(); } }; script.src = &quot;miniConsole.js&quot;; document.getElementsByClassName(&quot;head&quot;)[0].appendChild(script); document.body.removeEventListener(&quot;keydown&quot;, handler); // 只加载一次miniConsole.js } } document.body.addEventListener(&quot;keydown&quot;, handler, false); return { log: function () { let args = arguments; cache.push(function () { return miniConsole().log.apply(miniConsole().args); }) } }})();miniConsole.log(11); 4. 缓存代理计算乘积123456789101112131415161718192021let mult = function () { let a = 1; for (let i = 0; i &lt; arguments.length; i++) { a *= arguments[i]; } return a;}let proxyMult = (function () { let cache = {}; return function () { let args = Array.prototype.join.call(arguments, ','); if (args in cache) { return cache[args]; } return cache[args] = mult.apply(this, arguments); }})();proxyMult(1, 2, 3) // 6proxyMult(1, 2, 3) // 不会重复计算 5. ES6中的Proxy ES6 的 Proxy语法：let proxyObj = new Proxy(target, handler); target: 本体，要代理的对象 handler: 自定义操作方法集合 proxyObj: 返回的代理对象，拥有本体的方法，不过会被 handler 预处理 可以拦截并控制对对象的访问，下面是用Proxy实现的代理工厂 1234567891011121314const getCacheProxy = (fn, cache = new Map()) =&gt; { return new Proxy(fn, { apply(target, context, args) { const argsString = args.join(','); if (cache.has(argsString)) { // 如果有缓存，直接返回缓存数据 console.log(`输出${args}的缓存结果: ${cache.get(argsString)}`); return cache.get(argsString); } const result = fn(...args); cache.set(argsString, result); return result; } })} 参考《javascript设计模式与开发实践》https://segmentfault.com/a/1190000019574843","link":"/2021/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"title":"策略模式","text":"定义一系列算法，把他们一个个封装起来，并且使它们互相可替换 1. 创建1.1 利用对象封装实现1234567891011121314151617// 将算法的实现与算法的使用分离，strategies是一个策略类let strategies = { &quot;boss&quot;: function (salary) { return salary * 4; }, &quot;rookie&quot;: function (salary) { return salary * 3; }, &quot;liang&quot;: function (salary) { return salary * 2; }}// 需要调用计算类，只需要提供名字，解决了if else的问题let calculateBonus = function (level, salary) { return strategies[level](salary);} 1.2 利用传递函数实现123456789101112131415function boss(salary) { return salary * 4;}function rookie(salary) { return salary * 3;}function liang (salary) { return salary * 2;}let calculateBonus2 = function (func, salary) { return func(salary);}console.log(calculateBonus2(rookie, 10000)); // 30000 2. 优点 有效避免多重条件选择语句 契合了开放封闭原则，易于扩展 策略类封装的算法可复用 参考《javascript设计模式与开发实践》","link":"/2021/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"单例模式","text":"保证一个类仅有一个实例，并提供一个访问它的全局访问点比如vuex、window对象、线程池 1. 实现单例模式1.1 基于闭包实现12345678910111213141516171819202122function Singleton (name) { this.name = name;}Singleton.prototype.getName = function () { console.log(this.name);}Singleton.getInstance = (function () { let instance = null; return function (name) { if (!instance) { instance = new Singleton(name); } return instance; }})();let a = Singleton.getInstance('liang1');let b = Singleton.getInstance('liang2');console.log(a === b); // true 1.2 利用代理模式1234567891011121314let ProxySingleton = (function () { let instance; return function (name) { if (!instance) { instance = new Singleton(name); } return instance; }})();let c = new ProxySingleton('liang1');let d = new ProxySingleton('liang2');console.log(c === d); // true 利用代理模式来解耦管理单例的逻辑 1.3 通用的惰性单例123456function getSingle (fn) { let result; return function () { return result || (result = fn.apply(this, arguments)); }} 只需要给getSingle传递一个创建实例的fn就能创建单例模式 2. 弹窗实例12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;打开弹窗&lt;/button&gt;&lt;script&gt; // 通用的创建惰性单例模式 function getSingle(fn) { let result; return function () { return result || (result = fn.apply(this, arguments)); } } // 创建弹窗并添加到body下，并用getSingle创建单例模式 let createDialog = getSingle(function () { let div = document.createElement('div'); div.className = &quot;message-box&quot;; div.innerHTML = ` &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;dialog-bd&quot;&gt;这是一个弹窗哦&lt;/div&gt; &lt;div class=&quot;dialog-ft&quot;&gt; &lt;a href=&quot;javascript:&quot; class=&quot;dialog-btn&quot;&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; `.trim(); div.style.display = &quot;none&quot;; document.body.appendChild(div); return div; }) document.getElementById(&quot;btn&quot;).onclick = function () { let dialog = createDialog(); dialog.style.display = &quot;block&quot;; } // 为弹窗按钮绑定关闭事件 document.addEventListener(&quot;click&quot;, function (event) { if (event.target.className === &quot;dialog-btn&quot;) { let dialog = createDialog(); dialog.style.display = &quot;none&quot;; } })&lt;/script&gt;&lt;/body&gt; getSingle函数通过变量result保存弹窗实例，如果已经存在则直接返回该实例，否则创建弹窗实例，保证了弹窗的唯一性 参考《JavaScript设计模式与开发实战》","link":"/2021/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"惰性加载函数","text":"场景写一个各浏览器兼容事件绑定函数 12345678let addEvent = function (elem, type, handler) { if (window.addEventListener) { return elem.addEventListener(type, handler, false); } if (window.attachEvent) { return elem.attachEvent('on' + type, handler); }} 缺点：每一次调用都必须执行一次if判断 方案一在该代码被加载时，利用立即执行函数做一次判断，然后返回给addEvent正确的事件绑定函数 123456789101112let addEvent = (function (){ if (window.addEventListener) { return function (elem, type, handler) { elem.addEventListener(type, handler, false); } } if (window.attachEvent) { return function (elem, type, handler) { elem.attachEvent('on' + type, handler); } }})() 缺点：如果addEvent绑定事件函数一直都没有被调用，那么就白白做了一次浏览器嗅探 方案二：惰性载入函数1234567891011121314let addEvent = function(elem, type, handler) { if (window.addEventListener) { addEvent = function (elem, type, handler) { elem.addEventListener(type, handler, false); } } if (window.attachEvent) { addEvent = function (elem, type, handler) { elem.attachEvent('on' + type, handler); } } addEvent(elem, type, handler);} 缺点：首次调用较慢 参考《Javascript设计模式与开发实践》","link":"/2021/01/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"title":"Leetcode459. 重复的子字符串","text":"题目链接: https://leetcode-cn.com/problems/repeated-substring-pattern/ 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 俺愚蠢的暴力解法12345678910var repeatedSubstringPattern = function(s) { for (let i = 1; i &lt;= s.length / 2 &amp;&amp; i &lt; 10000; i++) { let str = s.slice(0, i); let repeatNum = s.length / str.length; if (Number.isInteger(repeatNum) &amp;&amp; str.repeat(repeatNum) === s) { return true; } } return false}; 方法二：字符串匹配 牛啊，官方题解的证明方式没看懂，之后有时间回来看看 算法 用两个s首尾相连得到一个新的字符串ss; 去掉ss的首尾两个字符； 如果在剩下来的字符串中能找到s那么返回True，否则False 123var repeatedSubstringPattern = function(s) { return (s+s).slice(1, -1).indexOf(s) !== -1;}; 证明方式https://blog.csdn.net/qq_23997101/article/details/78804826 方法三：正则表达式123var repeatedSubstringPattern = function(s) { return /^([a-z]+)\\1+$/.test(s)}; 不解释，草。","link":"/2021/01/23/Leetcode/Leetcode459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"减少使用setInterval","text":"setInterval很少使用在生成环境下，因为有如下几个缺点 缺点一：setInterval无视代码错误setInterval执行的代码即使代码报错，它还会持续不断（不管不顾）地调用该代码 缺点二：setInterval无视网络延迟假设你每隔一段时间就通过Ajax轮询一次服务器，看看有没有新数据（注意：如果你真的这么做了，那恐怕你做错了；建议使用“补偿性轮询”（backoff polling））。而由于某些原因（服务器过载、临时断网、流量剧增、用户带宽受限，等等），你的请求要花的时间远比你想象的要长。但setInterval不在乎。它仍然会按定时持续不断地触发请求，最终你的客户端网络队列会塞满Ajax调用。 缺点三：setInterval不保证按时执行原因一：执行时间被前面任务阻塞setInterval只是按时把时间推送到任务队列，因为js是单线程，所以如果前面的任务耗时较久，那么定时器的执行时间和我们预定的时间不一致 原因二：推送被忽略setInterval在推送到任务队列前，会检查上一次的任务是否仍在队列中，如果有则不填加，setTimeout则会直接添加 用setTimeout模拟setInterval12345678910function interval(func, wait) { let timer = null; function interfunc() { func.call(null); timer = setTimeout(interfunc, wait); }; timer = setTimeout(interfunc, wait); return timer;}","link":"/2021/01/22/Js/%E5%87%8F%E5%B0%91%E4%BD%BF%E7%94%A8setInterval/"},{"title":"CJS、ESM、UMD模块化标准","text":"1. CommonJS node.js的实现中采用了CommonJS标准的一部分，并在其基础上进行了一些调整 使用方式使用require和exports或者module.exports进行模块的导入导出 12345678910// node.js为了简化操作，有var exports = module.exports// 两者一致，那就说明，我可以使用任意一方来导出内部成员console.log(exports === module.exports) // true// 导出的对象近似于此种形式，exports相当于module.exports的引用// var module = {// exports: {// foo: 'bar',// }// } 特点1.CJS 模块输出的是值的拷贝 2.一个文件就是一个模块，name.js中的作用域是影响不到index.js的。 1234567// name.jslet name = 'name.js';// index.jslet name = 'index.js';require('./name');console.log(name); // index.js 原因 12345// 当node在执行模块中的代码时，它会首先在代码的最顶部，添加如下代码function (exports, require, module, __filename, __dirname) {// 在代码的最底部，，添加如下代码}// 所以可以理解一个文件就是一个模块 3.以同步的方式加载模块，模块加载顺序即在代码中的顺序，每个require语句会短暂阻塞代码的运行，知道模块加载完毕。不过这个加载不是通过网络加载，而是从内存或者文件系统中加载，所以这个过程很快。也导致CJS不适合浏览器 4.有缓存机制，已经被引入过的模块，不会再一次引入 12345678910// 由使用方式小节可知，其实模块会有一个module对象，而这个module对象会存放模块的信息// 其中有一个属性loaded用于记录该模块是否被加载过，默认为false，第一次加载后设为true，之后如果该属性为true，则不会再次执行改模块的代码// cache.jslet a = 1;console.log(a++);// index.jsrequire('./cache'); // 输出1require('./cache'); // 由于缓存机制，无输出 5.循环引用下的行为 将上文练习的b.js文件修改成下面这样： 123456789const a = require('./a.js');console.log(a, 'b中拿到的a');module.exports = { b1: '111', b2: '222', b3: '333', ba: a,}; a.js文件内容如下: 12const b = require('./b.js');console.log(b, 'a中拿到的b'); 执行node a.js，打印出 12{} b中拿到的a{ b1: '111', b2: '222', b3: '333', ba: {} } a中拿到的b 首先执行a.js，a中引用了b，所以b开始执行，b中又引用了a，此时a没有任何导出内容，所以b拿到的a是一个空对象。 修改a.js文件内容如下： 123456exports.a1 = '111';const b = require('./b.js');console.log(b, 'a中拿到的b');exports.a2 = '222'; 可以看见在导入b之前先导出了a1，执行node a.js，打印的内容是： 12{ a1: '111' } b中拿到的a{ b1: '111', b2: '222', b3: '333', ba: { a1: '111' } } a中拿到的b 说明在b中导入a的时候的拿到的是那个时刻a中已经导出的内容，如果没有导出，就会拿到一个空对象。 exports 是动态执行的，具体 require 能获取到的值，取决于模块的运行情况 2.AMD Asynchronous Module Definition（异步模块规范），最老的方式之一，专为浏览器而设计，RequireJS实现了AMD API 使用方式用define方法定义模块，用require导出模块 12345678910111213define( '模块名', ['依赖数组']， function([依赖数组]){ //工厂函数 ... }); require(['jquery']， function($){ //回调函数 ... }); 特点 可以定义具名模块，也可以定义匿名模块。具名模块通过开发者定义的名字加载，匿名模块隐式的以文件名加载 require调用会发送一个请求来下载模块 异步加载，只有在回调函数里才能获取新拿到的API 可以在代码的任何地方使用require加载另一个模块 3. ESM 与CJS和AMD不同，es6的模块是静态的， 使用方式用import和import()进行导入，用export、export default进行导出 特点1.ES6 模块输出的是值的引用 1234567891011// lib.jsexport let counter = 3;export function incCounter() { counter++;}// main.jsimport { counter, incCounter } from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 2.会动态的从被加载的模块中取值 12345678// m1.jsexport var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500);// m2.jsimport {foo} from './m1.js';console.log(foo); // barsetTimeout(() =&gt; console.log(foo), 500); // baz 3.导入的模块变量是只读的，如果修改就会报错 1234567// lib.jsexport let obj = {};// main.jsimport { obj } from './lib';obj.prop = 123; // OKobj = {}; // TypeError 4.循环引用下的行为 1234567891011// a.mjsimport {bar} from './b';console.log('a.mjs');console.log(bar);export let foo = 'foo';// b.mjsimport {foo} from './a';console.log('b.mjs');console.log(foo); // ReferenceError: foo is not definedexport let bar = 'bar'; 执行a.mjs，在a.mjs中引擎发现它加载了b.mjs，因此会优先执行b.mjs，在b.mjs中发现它又加载了a.mjs，形成循环引用，已知a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行，执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。 与CJS不同的是，ESM可以利用函数提升来解决上述问题，在b.mjs运行的时候，已经有foo的定义了 让我们看另一个例子 1234567891011// a.mjsexport let a_done = false;import { b_done } from './b';console.log('a.js: b.done = %j', b_done);console.log('a.js执行完毕');// b.mjsimport { a_done } from './a';console.log('b.js: a.done = %j', a_done); // 此处报错export let b_done = true;console.log('b.js执行完毕'); 执行a.mjs，因为import具有提升效果，所以在b.mjs中的第二行就会报ReferenceError: Cannot access 'a_done' before initialization的错误，同样的例子CJS由于没有提升，则可以获取到a_done为false ps：babel编译过后上述例子不会报错 4.UMD UMD：Universal Module Definition（通用模块规范）是由社区想出来的一种整合了CommonJS和AMD两个模块定义规范的方法。 UMD模块的顶端通常都会有如下的代码，用来判断模块加载器环境。 1234567891011121314(function (root, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(['jquery'], factory); } else if (typeof exports === 'object') { // CommonJS module.exports = factory(require('jquery')); } else { // 全局变量 root.returnExports = factory(root.jQuery); }}(this, function ($) { // ...})); 参考《深入浅出Webpack》https://es6.ruanyifeng.com/#docs/module-loaderhttps://juejin.cn/post/6870141103958589454https://juejin.cn/post/6844903861166014478","link":"/2021/01/19/Js/CJS%E3%80%81ESM%E3%80%81UMD%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A0%87%E5%87%86/"},{"title":"Leetcode239. 滑动窗口最大值","text":"题目链接: https://leetcode-cn.com/problems/sliding-window-maximum/主要是记录一下分块做法，没想懂为什么比双向单调队列快，想懂了回来补充 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例 1： 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2： 12输入：nums = [1], k = 1输出：[1] 示例 3： 12输入：nums = [1,-1], k = 1输出：[1,-1] 示例 4： 12输入：nums = [9,11], k = 2输出：[11] 示例 5： 12输入：nums = [4,-2], k = 2输出：[4] 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 题解一：双端单调队列维护一个双端单调队列，队尾存最大值的索引，如果当前遍历的数比队尾大，则一直弹出直到队列重新满足单调队列的性质，则滑动窗口的最大值为队尾元素，然后因为需要的只是当前窗口的最大值，所以每次循环需要判断队头是不是在当前窗口上，如果不是则弹出队头 12345678910111213141516171819202122232425var maxSlidingWindow = function(nums, k) { if(nums == null || nums.length &lt; 2) return nums; // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序 let queue = []; // 结果数组 let result = []; // 遍历nums数组 for(let i = 0; i &lt; nums.length; i++){ // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求 while(queue.length !== 0 &amp;&amp; nums[queue[queue.length - 1]] &lt;= nums[i]){ queue.pop(); } // 添加当前值对应的数组下标 queue.push(i); // 判断当前队列中队首的值是否有效 if(queue[0] &lt;= i - k){ queue.shift(); } // 当窗口长度为k时 保存当前窗口中最大值 if(i + 1 &gt;= k){ result[i+1-k] = nums[queue[0]]; } } return result;}; 题解二：优先队列和单调队列基本一个道理，不过键是索引，值是映射到正向区间的nums[i]，优先队列的队头是最大值，当最大值的索引不属于当前的滑动窗口时，则出队。 1234567891011var maxSlidingWindow = function(nums, k) { let q = new MaxPriorityQueue, r = new Int16Array(nums.length - k + 1), i = -1 while (++i &lt; k) q.enqueue(i, nums[i] + 10001) r[0] = q.front().priority - 10001, i-- while (++i &lt; nums.length) { q.enqueue(i, nums[i] + 10001) while (q.front().element &lt;= i - k) q.dequeue() r[i - k + 1] = q.front().priority - 10001 } return r;}; 题解三：分块将数组分成k块 指针j→ 统计每块内从块开头到j最大值指针i← 统计每块内从块结尾到i最大值滑动区间[i, i + k - 1]最大值 = 某块结尾到i最大值 与 某块开头到i + k - 1最大值 取大 12345678910var maxSlidingWindow = function(nums, k) { let n = nums.length, p = new Int16Array(n), s = new Int16Array(n), r = new Int16Array(n - k + 1), i = n, j = -1; while (i--) { p[++j] = j % k ? Math.max(p[j - 1], nums[j]) : nums[j] s[i] = i % k ? Math.max(s[i + 1], nums[i]) : nums[i] } while (i++ &lt; n - k) r[i] = Math.max(s[i], p[i + k - 1]) return r}; ps：离谱，为什么这个比双端队列要快的","link":"/2021/01/04/Leetcode/Leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"webstorm识别webpack别名","text":"webstorm识别webpack别名 重装webstorm发现之前配置过的别名识别无了，跳转也跳转不了，在此记录一下 你是否烦恼于设置别名后，webstorm警告并且无法跳转的问题 步骤 首先创建一个文件webstorm.config.js 1234567891011121314'use strict'const path = require('path')module.exports = { context: path.resolve(__dirname, './'), resolve: { extensions: ['.js', '.vue', '.json'], alias: { '@': path.resolve('src'), '@assets': path.resolve(__dirname, 'src/assets'), &quot;@components&quot;: path.resolve(&quot;src/components&quot;), } }} 然后进入webstorm设置 然后我们就可以愉快的进行跳转了","link":"/2020/12/16/%E7%BC%96%E8%AF%91%E5%99%A8/webstorm%E8%AF%86%E5%88%ABwebpack%E5%88%AB%E5%90%8D/"},{"title":"Webpack 模块热替换","text":"让代码在网页不刷新的前提下得到最新的改动，这就是Hot Module Replacement，HMR 1. 开启HMR配置文件 12345678910const webpack = require('webpack')module.exports = { plugins: [ new webpack.HotModuleReplacementPlugin() ], devServer: { hot: true, },} 然后在应用的入口index.js下调用HMR API，这样HMR对于index.js及其依赖的所有模块都会生效 1234// index.jsif (module.hot) { module.hot.accept();} 2. 原理 在本地开发环境下，浏览器是我们的客户端，webpack-dev-server（WDS）相当于我们的服务端，核心就是客户端从服务端（WDS）拉取更新后的资源（HMR拉取的不是整个资源文件，而是chunk diff，即chunk需要更新的部分） 实际上WDS与浏览器之间建立了一个websorket，当本地资源发生变化时WDS会向浏览器推送更新事件，并带上这次构建的hash，让客户端与上一次资源进行比对可以防止冗余更新的出现。 现在客户端根据hash比对后知道新的构建结构和当前的有了差别，就会向WDS发起一个请求来获取更改文件的列表，通常这个请求的名字为[hash].hot-update.json 该返回结构告诉客户端，需要更新的chunk为18，版本为（构建hash）2ef4d1d91c537e43ce76。这样客户端就可以再借助这些信息继续向WDS获取该chunk的增量更新。 现在客户端已经获取到chunk的更新，现在还有一个问题，客户端获取到这些增量更新之后如何处理，这就不属于webpack的工作了，但是HMR提供了相关的api。官方api文档：https://www.webpackjs.com/api/hot-module-replacement/ 可以看到HMR是使用了webpackHotUpdate来处理的，执行 webpackHotUpdate 时如发现模块代码实现了 HMR 接口，就会执行相应的回调或者方法，从而达到应用更新时，模块可以自行管理自己所需要额外做的工作。 这里还有一个问题是，webpack 如何保证 HMR 接口中的引用是最新的模块代码？我们看一个简单的例子： 1234567891011import './index.css'import hello from './bar'hello()if (module.hot) { module.hot.accept('./bar', () =&gt; { // console.log('Accepting the updated bar module!') hello() })} 从代码上看，hello 都是同一个，这样的话并没有办法引用最新的模块代码，但是我们看一下上述代码在 webpack 构建后的结果： 12345678910if (true) { module.hot.accept(&quot;./src/bar.js&quot;, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ __WEBPACK_IMPORTED_MODULE_1__bar__ = __webpack_require__(&quot;./src/bar.js&quot;); (() =&gt; { // console.log('Accepting the updated bar module!') Object(__WEBPACK_IMPORTED_MODULE_1__bar__[&quot;default&quot;])() })(__WEBPACK_OUTDATED_DEPENDENCIES__); })} 其他代码比较杂，我们集中看 module.hot 的处理部分。这里可以发现，我们的 hello 已经重新使用 __webpack_require__ 来引用了，所以可以确保它是最新的模块代码。 参考《Webpack实战》掘金小册：《使用 webpack 定制前端开发环境》","link":"/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/"},{"title":"Webpack Tree Shaking","text":"由Rollup提出，为了消除无用的JavaScript代码而被引入的，对于es模块依赖关系确定的，就可以进行静态分析，CJS不可以 1. 作用对象 不会被执行、不可到达的代码 代码执行的结果不会被用到 代码只会影响死变量（只写不读） 2. 作用方式 tree shaking 只会对满足上述条件的代码进行注释标记，由UglifyJSPlugin清除 webpack 负责对代码进行标记，把import&amp;export标记为 3 类： 所有import标记为/* harmony import */ 被使用过的export标记为/* harmony export ([type]) */，其中[type]和 webpack 内部有关，可能是binding, immutable等等。 没被使用过的export标记为/* unused harmony export [FuncName] */，其中 [FuncName]为export的方法名称 3. 不会清除类和IIFE下面摘取了rollup核心贡献者的的一些回答： rollup只处理函数和顶层的import/export变量，不能把没用到的类的方法消除掉 javascript动态语言的特性使得静态分析比较困难 下部分的代码就是副作用的一个例子，如果静态分析的时候删除里run或者jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行 下面这篇文章介绍了Babel编译类文件导致副作用，以及UglifyJs贡献者对处理有副作用代码的态度https://juejin.cn/post/6844903549290151949 (你的Tree-Shaking并没什么卵用) 4. 对于IIFE返回的函数，如果未被使用则会清除12345678910111213141516171819//App.jsimport { cube } from './utils.js';console.log(cube(2));//utils.jsvar square = function(x) { console.log('square'); return x * x;}();function getSquare() { console.log('getSquare'); square();}export function cube(x) { console.log('cube'); return x * x * x;} 结果 123456789function(e, t, n) { &quot;use strict&quot;; n.r(t); console.log(&quot;square&quot;); // square这个IIFE内部的代码还在 console.log(function(e) { return console.log(&quot;cube&quot;), e * e * e // square这个IIFEreturn的方法因为getSquare未被调用而被删除 }(2))} 5.Tree shaking结合第三方包使用1234567891011//App.jsimport { getLast } from './utils.js';console.log(getLast('abcdefg'));//utils.jsimport _ from 'lodash'; // 这里的引用方式不同，会造成bundle的不同结果export function getLast(string) { console.log('getLast'); return _.last(string);} 结果 1234567891011import _ from 'lodash'; Asset Size bundle.js 70.5 KiBimport { last } from 'lodash'; Asset Sizebundle.js 70.5 KiBimport last from 'lodash/last'; // 这种引用方式明显降低了打包后的大小 Asset Sizebundle.js 1.14 KiB 6. tree shaking结合第三方包使用12345678910111213141516//App.jsimport { Add } from './utils'Add(1 + 2);//utils.jsimport { isArray } from 'lodash-es';export function array(array) { console.log('isArray'); return isArray(array);}export function Add(a, b) { console.log('Add'); return a + b} 1这个`array`函数未被使用，但是lodash-es这个包的部分代码还是会被build到bundle.js中 可以使用这个插件webpack-deep-scope-analysis-plugin解决 参考https://juejin.cn/post/6844903544756109319#heading-0https://juejin.cn/post/6844903774192926728https://juejin.cn/post/6844903687412776974#heading-8","link":"/2020/12/11/Webpack/Webpack-Tree-Shaking/"},{"title":"webpack loader","text":"关于loader的作用和配置方法，在 初识webpack 这篇文章中已经讲过，本篇文章会讲常用的一些loader，并自己实现一个loader函数。 1. 转义es6安装1npm i @babel/core babel-loader @babel/preset-env -D babel-loader：它是使babel与webpack协同工作的模块 @babel/core：是babel编译器的核心模块 @babel/preset-env：官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译es6代码 配置12345678910111213141516rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', // 配置选项里的presets // 包含ES6还有之后的版本和那些仅仅是草案的内容 options: { cacheDirectory: true, // 启动缓存机制，在重复打包未改变过的模块时防止二次编译，加快打包速度 presets: ['@babel/preset-env'] } } include: /src/, // 只转化src目录下的js exclude: /node_modules/ // 排除掉node_modules，优化打包速度 }] 2. 转义Ts安装1npm i ts-loader typescript 配置12345rules: [ { test: /\\.ts$/, use: 'ts-loader',] 与寻常loader不同的是，ts配置项是在工程目录下的tsconfig.json中 3. html-loader用于将HTML文件转化为字符串并进行格式化，这使得外面可以把一个HTML片段通过js加载进来。 安装1npm i html-loader 配置12345rules: [ { test: /\\.html$/, use: 'html-loader',] 4. file-loader用于打包文件类型的资源，并返回其publicPath 安装1npm i file-loader 配置12345rules: [ { test: /\\.(jpe?g|png|gif)$/, use: 'file-loader',] 5. url-loader安装1npm i url-loader 配置123456789101112rules: [ { test: /\\.(jpe?g|png|gif)$/, use: { loader: 'url-loader', options: { limit: 10240, // 如果小于该配置大小，则返回文件的base64形式 name: '[name].[ext]', publicPath: './assets-path/', // 会覆盖webpack配置的publicPath }, },] 6. 加载样式安装1npm i style-loader css-loader less-loader -D 配置12345678910rules: [ { test: /.less$/, use: [ 'style-loader', // 将样式通过&lt;style&gt;标签插入到head中 'css-loader', // 用于加载.css文件，并转化成commonjs对象 'less-loader' // 将less转化成css ] },] 7. 自定义loader我们将实现一个loader，它会为所有JS文件开启严格模式，也就是说它会在文件头部加上如下代码 1'user strict' force-strict-loader.js 12345678910111213141516171819202122232425262728// 提供一些帮助函数，这里用于获取options中的配置项var loaderUtils = require(&quot;loader-utils&quot;);var SourceNode = require('source-map').SourceNode;var SourceMapConsumer = require('source-map').SourceMapConsumer;module.exports = function (content, sourceMap) { var useStrictPrefix = '\\'use strict\\';\\n\\n'; // 开启缓存，如果文件输入和其依赖没有发生变化时，应该让loader直接使用缓存，提高webpack打包的速度 if (this.cacheable) { this.cacheable(); } // 开启source-map可以便于实际开发者在浏览器控制台查看源代码 // 如果没有处理，最终无法生成正确的map文件，在dev tool中可能看到错乱的源码 var options = loaderUtils.getOptions(this) || {}; // 只有在从配置中获取sourceMap或者从上一个loader中传递下来才会继续处理 if (options.sourceMap &amp;&amp; sourceMap) { var currentReguest = loaderUtils.getCurrentRequest(this); var node = SourceNode.formStringWithSourceMap( content, new SourceMapConsumer(sourceMap) ); node.prepend(useStrictPrefix); var result = node.toStringWithSourceMap({ file: currentReguest}); var callback = this.async(); callback(null, result.code, result.map.toJSON()); } return useStrictPrefix + content;} 上面的插件提供了source-map的配置选项，source-map是一个信息文件，里面储存着位置信息，在debug的时候就会显示原文件的信息和位置，而不是转化后的信息。 使用方法 123456use: { loader: 'force-strict-loader', options: { sourceMap: true, }} 参考《Webpack实战入门、进阶与调优》https://juejin.cn/post/6844903599080734728#heading-14http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html","link":"/2020/11/27/Webpack/webpack%20loader/"},{"title":"webpack文件指纹","text":"打包后的文件后缀，通常用于做版本管理，文件被修改后打包出来的文件指纹不同，浏览器只会下载这些不同的文件，没被修改的文件从缓存读取，加快浏览速度 1. 三种文件指纹的策略 文件指纹 策略 hash 只要有文件被修改，每一次构建过程生成唯一hash，所有文件共用 chunkhash 基于chunk内容生成，不同的entry会生成不同的chunkhash值 contenthash 根据文件内容来定义hash，文件内容不变，则contenthash不变 chunkhash的问题：如果在js中引入了style文件，之后只修改了style文件，但打包后js的文件指纹也一起修改了 2. 文件指纹的设置2.1 js的文件指纹设置 js使用chunkhash型的文件指纹 12345678910module.exports = { entry: { app: './src/app.js', search: './src/search.js' }, output: { filename: '[name][chunkhash:8].js', // 取chunkhash的前8位 path: __dirname + '/dist' }}; 2.2 css的文件指纹设置1234567891011121314151617module.exports = { entry: { app: './src/app.js', search: './src/search.js' }, output: { filename: '[name][chunkhash:8].js', path: __dirname + '/dist' }, plugins: [ // 如果使用style-loader设置解析样式，做不到各自独立的css文件 // 所以使用 MiniCssExtractPlugin 插件抽离出各个独立的css文件 new MiniCssExtractPlugin({ filename: `[name][contenthash:8].css` }); ]}; 2.3 图片的文件指纹123456789101112131415161718192021const path = require('path');module.exports = { entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.(png|svg|jpg|gif)$/, use: [{ loader: 'file-loader’, options: { name: 'img/[name][hash:8].[ext]' } }] } ] }};","link":"/2020/11/22/Webpack/webpack%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9/"},{"title":"初识webpack","text":"1. 安装1npm install webpack webpack-cli --save-dev webpack是核心模块，webpack-cli则是命令行工具 然后在根目录下创建webpack.config.js来配置webpack 2. 配置资源入口在配置入口的时候，实际上是做了两件事： 确定入口模块的位置，告诉webpack从那里开始打包 定义chunk name，如果只有一个入口，默认chunk name为“main”，如果为多入口，则需要为每一个入口定义chunk name作为其唯一标识 2.1 context entry路径前缀 1234module.exports = { context: path.join(__dirname, './src'), // 资源入口前缀（为了让entry编写的更简洁 entry: './index.js', // string | object | array | function}; 2.2 entry支持四种类型的值 字符串类型 直接传入文件路径（绝对路径 | 相对路径） 数组类型 作用是将多个资源预先合并 123module.exports = { entry: [&quot;babel-polyfill&quot;, &quot;./src/index.js&quot;], // 最后的文件作为入口}; 对象类型 想要定义多入口，则必须使用对象的形式 12345678module.exports = { entry: { // chunk name为index，入口路径为./src/index.js index: [&quot;babel-polyfill&quot;, &quot;./src/index.js&quot;], // chunk name为lib1，入口路径为./src/lib.js lib1: './src/lib.js', }}; 函数类型 可以动态设置文件路口，甚至加上异步逻辑 1234567module.exports = { entry: () =&gt; new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('./src/index.js'); }, 1000) })}; 2.3 vender 一般是把工程所使用的库、框架等第三方模块集中打包而产生的bundle，可以使用CommonsChunkPlugin将app与vendor这两个chunk中的公共模块提取处理，使app.js产生的bundle将只包含业务模块。 123456module.exports = { entry: { app: './src/app.js', vendor: ['vue'], }}; 3. 配置资源出口3.1 filename作用是控制输出资源的文件名，也可以为相对路径 和 模板变量（用于控制客户端缓存，下一篇博客将会讲文件指纹） 123456module.exports = { entry: './src/app.js', output: { filename: &quot;bundle.js&quot; }}; 3.2 path可以指定资源输出的位置，要求值必须为绝对路径 1234567module.exports = { entry: './src/app.js', output: { filename: &quot;bundle.js&quot;, path: path.join(__dirname, 'dist'), }}; 3.3 publicPathpath用来指定资源输出位置，而publicPath用来指定资源请求位置 123// 假设当前地址为 https://example.com/app/index.html// 异步加载的资源名为 0.chunk.jspublicPath: &quot;./js&quot; // 实际路径 https://example.com/app/js/0.chunk.js 4. loaderwebpack 开箱即用只支持 JS 和 JSON 两种文件类型，通过 Loader 去支持其它文件类型并且把它们转化成有效的模块，并且可以添加到依赖图中。 12345678910111213141516module.exports = { // ... module: { rules: [{ enforce: normal // pre: 在所有loader之前调用 | normal | post: 在所有loader之后调用 test: /\\.css$/, // 可以接受正则表达式或者正则数组 use: ['css-loader', 'less-loader'], // 可以接收一个数组，包含匹配项所使用loader，从右向左处理 exclude: /src\\/lib/, // 排除目录 include: /src/, // 包含目录，exclude和include同时存在时-exclude优先级更高 issuer: { // 上面是对被加载者的配置，这是加载者的配置 test: /\\.js$/, // 该配置的意思为只有 /src/pages目录下的js可以引用css include: /src/pages/, } }] }}; 5.plugins对webpack loader的扩展，作用于构建的整个过程 123plugins: [ new HtmlWebpackPlugin({template: './src/index.html'})] 6. mode 选项 描述 development 设置process.env.NODE_ENV的值为development开启NamedChunksPlugin和NamedModulesPlugin production 设置process.env.NODE_ENV的值为production开启FlagDependencyUsagePlugin，FlagInc ludedChunksPlugin， ModuleConcatenationPlugin，NoEmitOnErrorsPlugin，OccurrenceOrderPlugin， SideEffectsFlagPlugin和TerserPlugin none 不开启任何优化选项","link":"/2020/11/22/Webpack/%E5%88%9D%E8%AF%86webpack/"},{"title":"Jest自动化测试入门","text":"1. 环境搭建1npm install --save-dev jest 然后在项目根目录下，控制台执行如下命令，就会初始化jest配置 jest.config.js 1npx jest --init 生成代码覆盖率 1npx jest --coverage 2.简单测试首先有两个文件 liang.js 123456789101112function foo(money) { return money &gt; 10000 ? '有钱哩' : '难受';}function bar(money) { return money &gt; 1000 ? '吃大餐' : '吃空气';}module.exports = { foo, bar} liang.test.js 12345678910const { foo, bar } = require('./liang');test('foo方法-5000', () =&gt; { // toBe ~= === expect(foo(5000)).toBe('难受')})test('bar方法-2000', () =&gt; { expect(bar(2000)).toBe('吃大餐')}) 把待测试函数包在expect中，用匹配器（这里是toBe）进行检查输出 然后在package.json中添加运行指令 12345{ &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot; // 想要有监视功能就加上 --watchAll }} 然后npm run test就能运行我们第一个jest测试了 3.常用匹配器 匹配器 功能 toBe === toEqual 递归比较对象所有属性的值（深度相等） toBeNull 只匹配 null toBeUndefined 只匹配 undefined toBeDefined 不为undefined toBeTruthy 匹配任何 if 语句为真 toBeFalsy 匹配任何 if 语句为假 可以在上述匹配器前加个not表示取反，比如.not.toBe表示不严格等于 有关匹配器的完整列表，请查阅 参考文档 4. 测试异步方法4.1 引入文件fetchData.js 12345import axios from 'axios'export function fetchData () { return axios.get('http://localhost:3000/');} fetchData.test.js 123456789import { fetchData } from './fetchData'test('fetchData 方法测试1', () =&gt; { fetchData().then(response =&gt; { expect(response.data).toEqual({ success: true, }) })}) 无论怎么样都会测试成功，因为jest测试一旦执行到末尾就会完成所以问题再与一旦fetchData执行结束，此测试就在没用调用回调函数前结束 4.2 解决方法12345678test('fetchData 方法测试2', (done) =&gt; { fetchData().then(response =&gt; { expect(response.data).toEqual({ success: true, }) done(); // Jest会等 done 回调函数执行结束后，结束测试，所以会 })}) 4.3 export数量断言下面一段代码的功能：检查接口是否存在，如果不存在就测试成功 1234567test('fetchData catch方法测试', () =&gt; { expect.assertions(1) // 断言，必须执行一次export，如果不执行则报错 // 如果不加断言，那么如果没有错误被catch到，则测试不会被执行，显示不出报错 fetchData().catch(err =&gt; { expect(err.toString().indexOf('404') &gt; -1).toBe(true); })}) 4.4 async和await的测试方法如果是用await进行测试的话，可以使用export的resolves和rejects 1234567test('fetchData async方法', async () =&gt; { await expect(fetchData()).resolves.toMatchObject({ data: { success: true, } })}) 5. 钩子函数5.1 功能描述像vue-router的导航守卫一样的，jest也有四个钩子函数 钩子函数 功能 beforeAll 在所有测试用例之前执行 afterAll 在所有测试用例之后执行 beforeEach 在每一个测试用例之前执行 afterEach 在每一个测试用例之后执行 5.2 作用域默认情况下before 和 after 的块可以应用到文件中的每个测试，可以使用describe声明一个作用域，这些钩子函数在describe声明 的作用域内调用，则只会作用在该作用域内。 123456789101112131415161718192021222324import { foo, bar } from '../simpleDemo/liang'beforeAll(() =&gt; { console.log(&quot;我是在外面的beforeAll&quot;)})beforeEach(() =&gt; { console.log(&quot;我是在外面的beforeEach&quot;)})describe('describe inner', () =&gt; { beforeAll(() =&gt; { console.log(&quot;我是在里面的beforeAll&quot;) }) test('foo方法-5000', () =&gt; { // toBe ~= === expect(foo(5000)).toBe('难受') }) test('bar方法-2000', () =&gt; { expect(bar(2000)).toBe('吃大餐') })}) 5.3 钩子函数的作用规则由上面截图的执行顺序，可以引出以下三条规则 钩子函数在父级分组可作用于子集 钩子函数同级分组作用域互不干扰，各起作用 先执行外部的钩子函数，再执行内部的钩子函数","link":"/2020/11/17/%E6%B5%8B%E8%AF%95/Jest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"},{"title":"深拷贝、浅拷贝","text":"1. 区别 浅拷贝：复制基本类型和引用类型 深拷贝：引用类型所指向的内存空间也完全拷贝 2. 浅拷贝的实现方式2.1 Object.assign(target, …sources)把对象的可枚举属性拷贝给目标对象 2.2 展开运算符…与Object.assign相同 2.3 Array.prototype.concat()2.4 Array.prototype.slice()3. 深拷贝的实现方式3.1.JSON.parse(JSON.stringify())12let arr = [1, 3, { username: 'liangliang' }];JSON.parse(JSON.stringify(arr)); // 深拷贝，会为对象开辟新的栈空间 优点 可以解决对象内部循环引用的问题，JSON.stringify内部做了循环引用的检测 缺点 会抛弃对象的constructor，无论原本的构造函数是什么，在此之后都会变成Object 但是这样对正则表达式处理后会变成空对象，数组或者对象中的函数变为null 3.2 jQuery.extend1jQuery.extend( [deep], target, object1 [, objectN ] ) 3.3 MessageChannel [2021.3.2]12345678910111213function deepCopy(obj) { return new Promise((resolve) =&gt; { const {port1, port2} = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); });}deepCopy(obj).then((copy) =&gt; { // 请记住`MessageChannel`是异步的这个前提！ let copyObj = copy; console.log(copyObj, obj) console.log(copyObj == obj)}); 可以拷贝undefined和循环引用的对象，但是有函数的对象还是报错 参考https://juejin.im/post/6844904197595332622https://github.com/mqyqingfeng/Blog/issues/33（内含jQuery的实现）https://segmentfault.com/a/1190000016672263（内含循环深拷贝）","link":"/2020/10/31/Js/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"圣杯布局、双飞翼布局","text":"1. 问题场景三列布局中，如果想要将主要内容main优先加载优化，则DOM如下所示 12345&lt;div class=&quot;g-container&quot;&gt; &lt;div class=&quot;g-main&quot;&gt;我是主列&lt;/div&gt; &lt;div class=&quot;g-left&quot;&gt;我是左列&lt;/div&gt; &lt;div class=&quot;g-right&quot;&gt;我是右列&lt;/div&gt;&lt;/div&gt; 但又想将主要内容在中间位置显示，便有如下css 123456789101112131415161718192021222324252627.g-container { float: left; width: 100%; &amp; &gt; div { width: 190px; min-height: 30px; }}.g-container .g-main { float: left; width: 100%; background: #cc6630;}.g-left { float: left; margin-left: -100%; background: #f00;}.g-right { float: left; margin-left: -190px; background: #00f;} 下面逐行分析一下：第1行：grid-s5m0e5 是一个布局框的名称，我们为其定义了宽度100%（在IE6一不定义100%时，有点小问题，亲们自己可以一试） 第2行：col-main 【主列】：浮动左侧，宽度100%（宽度全让它给占了，左右两侧的层该怎么办？） 第3行：col-sub 【子列】：浮动左侧，宽度190，左边界为-100%（此处是关键：浮动情况下，负边界值会导致DIV上移，而使用-100%可以确实它移动到最左侧。） 第4行：col-extra 【附加列】：左浮动，宽度190，左边界为-190px（道理同上，注意的是，负左边界一定要大于或等于该DIV的宽度，才能靠到上一行去） 让我们看看效果 但这样布局后发现主列中的文字不见了，经过DOM分析发现，原来是被col-sub挡住了，那么如何给main正确的定位呢。 1.圣杯布局(margin+position) 左右两列通过margin-left与left和right准确定位，中间列用width:100%撑开圣杯布局的关键点父元素需要设置paddingmargin-left取值为百分比时，是以其父元素的宽度为基准的 12345678910111213141516171819202122232425262728293031.g-container { position: relative; padding: 0 190px; &amp; &gt; div { float: left; min-height: 30px; }}.g-main { position: relative; width: 100%; background: #cc6630;}.g-left { position: relative; width: 190px; margin-left: -100%; left: -190px; background: #ffcc00;}.g-right { position: relative; width: 190px; margin-left: -190px; right: -190px; background: pink;} 2. 圣杯布局(flex) 利用flex的order属性调整位置 12345678910111213141516171819202122232425262728.g-container { width: 100%; display: flex; flex-direction: row; flex-wrap: nowrap; &amp; &gt; div { min-height: 30px; }}.g-main { order: 2; flex: auto 1 0; background: #cc6630;}.g-left { order: 1; flex: 200px 0 0; background: #ffcc00;}.g-right { order: 3; flex: 200px 0 0; background: pink;} 这种写法更加简洁，但是兼容性不太好 3.双飞翼布局(margin) 利用margin-left属性将左右两列放置到准确的位置，通过控制 main列 的margin空出左右两列 下面是淘宝的做法： 1、DOM结构的改变：在.col-main下再次添加一个 .main-wrap 2、利用CSS调整.main-wrap的位置。【这里很简单，就是把左右被挡住的部分，设置为main-wrap的左 右边界即可】 123456789&lt;div class=&quot;g-container&quot;&gt; &lt;div class=&quot;g-main&quot;&gt; &lt;div class=&quot;main-wrap&quot;&gt; 我是主列，出来吧！ &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;g-left&quot;&gt;我是左列&lt;/div&gt; &lt;div class=&quot;g-right&quot;&gt;我是右列&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031.g-container { float: left; width: 100%; &amp; &gt; div { float: left; width: 190px; min-height: 30px; }}.g-container .g-main { width: 100%; background: #cc6630; .main-wrap { margin-left: 200px; /*与g-left产生10像素距离*/ margin-right: 200px; /*与g-right产生10像素距离*/ background: #0f0; }}.g-left { margin-left: -100%; background: #f00;}.g-right { margin-left: -190px; background: #00f;} 最终效果 优点 实现了内容与布局的分离，即Eric提到的Any-Order Columns. main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。 任何一栏都可以是最高栏，不会出问题。 需要的hack非常少（就一个针对ie6的清除浮动hack:_zoom: 1;） 在浏览器上的兼容性非常好，IE5.5以上都支持。 不足 main需要添加一个额外的包裹层。","link":"/2020/10/30/Css/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"},{"title":"css预处理器：Less","text":"1.注释 以 // 开头的注释，不会被编译到css文件中 以 /**/ 包裹的注释会被编译到css文件中 2.变量2.1普通变量less中使用@定义一个变量，再以@开头调用 12345@zero: 0;* { margin: @zero; padding: @zero;} 2.2变量作为选择器、属性名或者url使用@{selector/property/url}调用 12345678@selector: wrap;@url: &quot;../img/1.jpg&quot;;@w: width;@{selector}{ @{w}: 100px; background: url(&quot;@{url}&quot;);} 2.3变量的延迟加载 less中的加载是有延迟的 它会在当前作用域样式未加载之前先加载变量，而且是由内而外，先寻找作用域内的变量，如果没有再寻找作用域外的变量 less机制是先加载完声明变量再赋值到样式中去 12345678910@var: 0;.class {@var: 1; .brass { @var: 2; three: @var; //3 @var: 3; } one: @var; //1} 3.嵌套规则123456789#list{ list-style: none; a{ float: left; /*&amp;代表父级*/ &amp;:hover{color: red;} } span{float: right;}} &amp;的使用（&amp;代表父级）如果想写串联选择器，而不是写后代选择器，就可以用到&amp;了.这点对伪类尤其有用如 :hover 和 :focus 4.混合 混合就是一种将一系列属性从一个规则集引入（“混合”）到另一个规则集的方式。 4.1普通混合会将混合内容输出到css文件中 12345678.font_hn{ color: red; font-family: microsoft yahei, &quot;黑体&quot;, Arial, Simsun, &quot;Arial Unicode MS&quot;, Mingliu, Helvetica;}h1{ font-size: 28px; .font_hn;} 4.2不带输出的混合 加()后就不会在css中输出混合内容了 ，即输出的css文件中无font_hn 12345678.font_hn(){ color: red; font-family: microsoft yahei, &quot;黑体&quot;, Arial, Simsun, &quot;Arial Unicode MS&quot;, Mingliu, Helvetica;}h1{ font-size: 28px; .font_hn;} 4.3带参数的混合类似函数的调用方式，参数名开头为@ 1234567891011121314151617181920212223.border(@color){ border: 1px solid @color;}h1{ &amp;:hover{ .border(green); }}h2{ &amp;:hover{ .border(#000); }}其css文件为：h1:hover { border: 1px solid #008000; border: 21px #008000 #ff0000;}h2:hover { border: 1px solid #000000; border: 21px #000000 #ff0000;} 4.4带参数且有默认值的混合使用 : 为参数添加默认值， 有了默认值，我们可以不用设置属性值也能被调用 1234567891011121314151617181920212223.border_you(@color:red){ border: 1px solid @color; }h1{ &amp;:hover{ .border_you(); }}h2{ &amp;:hover{ .border_you(yellow); }}其编译后的css文件如下：/*带参数并且有默认值的混合*/h1:hover { border: 1px solid #ff0000;}h2:hover { border: 1px solid #ffff00;} 4.5命名参数（传实参时可以指定值给的是哪个参数） 引用mixin时可以通过参数名称而不是参数的位置来为mixin提供参数值。任何参数都以用过它的名称来使用，这样就不必按照任意特定的顺序来使用参数 123456789101112131415161718192021222324.mixin(@color: black; @margin: 10px; @padding: 20px) { color: @color; margin: @margin; padding: @padding;}.class1 { .mixin(@margin: 20px; @color: #33acfe);}.class2 { .mixin(#efca44; @padding: 40px);}其编译后的css文件如下:.class1 { color: #33acfe; margin: 20px; padding: 20px;}.class2 { color: #efca44; margin: 10px; padding: 40px;} 4.6匹配模式 根据传入的参数来改变混合的默认呈现 123456789101112131415161718192021222324252627282930.border(all,@w: 5px){ border-radius: @w;}.border(t_l,@w:5px){ border-top-left-radius: @w;}.border(t_r,@w:5px){ border-top-right-radius: @w;}.border(b-l,@w:5px){ border-bottom-left-radius: @w;}.border(b-r,@w:5px){ border-bottom-right-radius: @w;}footer{ .border(t_l,10px); .border(b-r,10px); background: #33acfe;}其编译后的css文件如下：footer { border: 21px t_l 10px; border-top-left-radius: 10px; border: 21px b-r 10px; border-bottom-right-radius: 10px; background: #33acfe;} 4.7@arguments变量 @arguments代表所有的可变参数 注意事项： @arguments代表所有可变参数，参数的先后顺序就是你的（）括号内的参数的先后顺序 在使用的赋值，值的位置和个数也是一一对应的，只有一个值，把值赋值给第一个，两个值，赋值给第一个和第二个，三个值赋值给第三个……以此类推，但是需要注意的是假如我想给第一个和第三个赋值，你不能写（值1，，值3），必须把原来的默认值写上去！ 1234567891011.border(@x:solid,@c:red){ border: 21px @arguments;}.div1{ .border(solid);}其编译后的css文件为：.div1 { border: 21px solid #ff0000;} 4.8混合的返回值12345678910111213141516.average(@x, @y) { @average: ((@x + @y) / 2); @he: (@x + @y);}div { .average(16px, 50px); padding: @average; margin: @he;}其编译后的css文件如下：div { padding: 33px; margin: 66px;} 5.运算5.1数值运算 只需要在其中的一个数值上加上单位，其他单位由less自动加上 1234.wp{ width: 450px + 450; height: 400 + 400px;} 5.2颜色运算 Less在运算时，先将颜色值转换为rgb模式，然后再转换为16进制的颜色值并且返回 1234.content{ Background:#000000 + 21; }Css文件编译结果.content{ background:#212121; } 6.函数6.1RGB函数1234.bgcolor{ background:rgb(0,133,0); }Css结果：.bgcolor{ background:#008500; } 6.2Convert函数1234body{ width:convert(20cm,px); } Css文件如下:body{ width:755.90551181px; } 7.命名空间多人协作时，避免选择器重名问题，引入命名空间的概念，以#开头代表命名空间，#namespace&gt;.selector即可调用 1234567891011121314151617181920212223242526272829303132#mynamespace() { background: #ffffff; .a{ &amp;:hover{ color: #ff6600; } .b{ background: #ff0000; } }}.bgcolor{ #mynamespace&gt;.a;}.bgcolor2{ #mynamespace&gt;.a&gt;.b;}编译后css文件.bgcolor { color: #888888;}.bgcolor:hover { color: #ff6600;}.bgcolor .b { background: #ff0000;}.bgcolor2 { background: #ff0000;} 8.避免编译将要避免编译的值用 “” 包裹起来，并在前面加~ 1234567.class { filter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;}Css文件如下:.class { filter: ms:alwaysHasItsOwnSyntax.For.Stuff();} 9.继承(extent)性能比混合高继承不支持带参数，灵活度比混合低 他将所放置它的选择器与匹配引用的选择器进行合并。 12345678910111213141516171819a { // a 所放置它的选择器 background-color: #fff; &amp;:extend(.b); // .b匹配引用的选择器 border-bottom: 2px;}.b { font-weight: 700; color: yellow;}编译后css文件a { background-color: #fff; border-bottom: 2px;}.b, a { font-weight: 700; color: yellow;} 还可以在选择器后加 :extend(.selector, .selector 可选值all)表示继承，在括号内用逗号分隔多个继承元素，若有all可选值，hover等伪类也会继承 10.条件表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。为了尽可能地保留CSS的可声明性，LESS通过导引混合而非if/else语句来实现条件判断，因为前者已在@media query特性中被定义。以此例做为开始：.mixin (@a) when (lightness(@a) &gt;= 50%) { background-color: black;}.mixin (@a) when (lightness(@a) &lt; 50%) { background-color: white;}.mixin (@a) { color: @a;}when关键字用以定义一个导引序列(此例只有一个导引)。接下来我们运行下列代码：.class1 { .mixin(#ddd) }.class2 { .mixin(#555) }就会得到：.class1 { background-color: black; color: #ddd;}.class2 { background-color: white; color: #555;}导引中可用的全部比较运算有： &gt; &gt;= = =&lt; &lt;。此外，关键字true只表示布尔真值，下面两个混合是相同的：.truth (@a) when (@a) { ... }.truth (@a) when (@a = true) { ... }除去关键字true以外的值都被视示布尔假：.class { .truth(40); // Will not match any of the above definitions.}导引序列使用逗号‘,’—分割，当且仅当所有条件都符合时，才会被视为匹配成功。.mixin (@a) when (@a &gt; 10), (@a &lt; -10) { ... }导引可以无参数，也可以对参数进行比较运算：@media: mobile;.mixin (@a) when (@media = mobile) { ... }.mixin (@a) when (@media = desktop) { ... }.max (@a, @b) when (@a &gt; @b) { width: @a }.max (@a, @b) when (@a &lt; @b) { width: @b }最后，如果想基于值的类型进行匹配，我们就可以使用is*函式：.mixin (@a, @b: 0) when (isnumber(@b)) { ... }.mixin (@a, @b: black) when (iscolor(@b)) { ... }下面就是常见的检测函式： iscolor isnumber isstring iskeyword isurl如果你想判断一个值是纯数字，还是某个单位量，可以使用下列函式： ispixel ispercentage isem最后再补充一点，在导引序列中可以使用and关键字实现与条件：.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) { ... }使用not关键字实现或条件.mixin (@b) when not (@b &gt; 0) { ... }","link":"/2020/10/30/Css/css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9ALess/"},{"title":"重绘与回流","text":"回流 指改变几何属性的渲染 重绘 指改变外观属性而不影响几何属性的渲染 属性分类 几何属性：包括布局、尺寸等可用数学几何衡量的属性 布局：display、float、position、list、table、flex、columns、grid等 尺寸：margin、padding、border、width、height等 外观属性：包括界面、文字等可用状态向量描述的属性 界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip等 文字：text、font、word等 PS：推荐一个属性渲染状态可视化的网站CssTriggers，可查看每个属性在渲染时产生的影响。 浏览器的渲染过程![Snipaste_2020-10-03_17-43-05](D:\\OneDrive - mail2.gdut.edu.cn\\typora_img\\重绘与回流\\Snipaste_2020-10-03_17-43-05.png) 在页面加载时，浏览器渲染过程如下： 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层） 为了构建渲染树，浏览器主要完成了以下工作： 从DOM树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 渲染树中只会包含可见节点。不可见节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。如display:none。 注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算 可见，如果触发回流那么必然会触发重绘 浏览器如何处理每句JS操作都去回流重绘的话，浏览器可能就会受不了。 浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop/Left/Width/Height clientTop/Left/Width/Height width,height 请求了getComputedStyle(), 或者 IE的 currentStyle 当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。引擎会重新渲染来确保获取的值 是实时的 利用合成层性能优化：Composite 可以利用chrome开发者工具的Layers查看合成层 提升为合成层简单说来有以下几点好处： 合成层的位图，会交由 GPU 合成，比 CPU 处理要快 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 对于 transform 和 opacity 效果，不会触发 layout 和 paint 提升合成层的最好方式是使用 CSS 的 will-change 属性。而 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。 12345678#target { will-change: transform; //兼容性不好}//对于那些目前还不支持 will-change 属性的浏览器//目前常用的是使用一个 3D transform 属性来强制提升为合成层#target { transform: translateZ(0);} 层合成的过程会产生内存消耗，所以不要盲目开启层合成 参考https://juejin.im/post/6844904161868251149https://juejin.im/post/6844903859719143437#heading-1","link":"/2020/10/04/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"},{"title":"防抖和节流","text":"上图是对鼠标进行监听，事件执行的很频繁，如果执行的事件是对接口的请求，那么会在短时间内发起大量重复请求，所以我们需要防抖或者节流进行解决。 防抖 防抖即为事件触发n秒后才执行事件，如果在n秒内又触发事件则重新计时 1. 手写版123456789function debounce(func, wait) { let timer = null; return () =&gt; { clearTimeout(timer); timer = setTimeout(()=&gt; { func.apply(this, arguments) }, wait); }} 移动完n秒后才执行事件 2. 可立即执行版触发事件立即执行，停止n秒后才可以重新触发 1234567891011121314151617181920function debounce(func, wait, immediate = true) { let timer; return () =&gt; { if (timer) clearTimeout(timer); if (immediate) { // 如果已经执行过，不再执行 var callNow = !timer; timer = setTimeout(() =&gt; { timer = null; }, wait) if (callNow) func.apply(this, arguments); } else { timer = setTimeout(() =&gt; { func.apply(this, arguments); }, wait); } }} 节流 节流即为连续触发事件但是在n秒中只执行一次函数 1. 时间戳版1234567891011function throttle(func, wait) { var previous = 0; return () =&gt; { var now = new Date(); if (now - previous &gt; wait) { func.apply(this, arguments); previous = now; } }} 当鼠标移入的时候，事件立刻执行，每过1s会执行一次，如果在2.2s停止触发，之后不会再执行事件。 2. 定时器版12345678910111213function throttle(func, wait) { var timeout; var previous = 0; return () =&gt; { if (!timeout) { timeout = setTimeout(() =&gt; { timeout = null; func.apply(this, arguments) }, wait) } }} 可以看到使用定时器版本的节流函数，鼠标移入并不会立即执行，此后每移动1秒执行一次函数，在3.2秒左右移出鼠标，但是仍会在4秒时执行函数 参考https://github.com/mqyqingfeng/Blog/issues/22https://github.com/mqyqingfeng/Blog/issues/26","link":"/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"},{"title":"Typescript语法篇","text":"1.typescript的原始类型 boolean number string void（只有null和undefined可以赋给void） undefined 和 null（是所有类型的子类型，严格模式下只能赋值给对应的类型或者any） symbol bigint 2.Typescript 中其他常见类型 any（为任意类型） 变量如果在声明的时候，未指定其类型或者初始化，那么它会被识别为any类型 unknown 较any类型更安全s 该类型变量被确定为某一类型前，不能进行任何操作 123456let value: unknown; value.foo.bar; // ERRORvalue(); // ERRORnew value(); // ERRORvalue[0][1]; // ERROR never 永不存在值的类型 是任何类型的子类型，可以赋值给任何类型 没有类型是 never 的子类型，任意类型都不能赋值给never类型（包括any） 常用在 抛出异常的函数 和 空数组且永远为空数组 数组类型(array) 1234// 有两种定义方式const list: Array&lt;number&gt; = [1, 2, 3] // 泛型const list: number[] = [1, 2, 3] 元组(tuple) 已知元素数量及类型的数组1let x: [string, number]; // 两个元素，类型顺序也不能变 ts允许元组使用数组的push方法，但我们访问新加入的元素时会报错 1234const tuple: [string, number] = ['a', 1];tuple.push(2); // okconsole.log(tuple); // [&quot;a&quot;, 1, 2] -&gt; 正常打印出来console.log(tuple[2]); // Tuple type '[string, number]' of length '2' has no element at index '2' object 3.枚举类型123456enum Direction { Up, // 0 Down = 2, // 2 Left, // 3 Right, // 4} 不带初始化的枚举 要么放在第一个位置， 要么在被数字常量或其它常量初始化的枚举后面，否则会报错 3.1 枚举的本质枚举类型被编译为 JavaScript的形式如下所示，是具有双向映射的特性（字符串类型除外） 1234567var Direction;(function (Direction) { Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;; Direction[Direction[&quot;Down&quot;] = 2] = &quot;Down&quot;; Direction[Direction[&quot;Left&quot;] = 3] = &quot;Left&quot;; Direction[Direction[&quot;Right&quot;] = 4] = &quot;Right&quot;;})(Direction || (Direction = {})); 3.2 const声明的枚举1const a = Direction.Up; 会被编译为 1var a = 0; 3.2 联合枚举与枚举成员的类型如果枚举成员均有字面量类型组成，那么枚举的每个成员和枚举值本身都可以作为类型来使用 任何字符串字面量（例如： &quot;foo&quot;， &quot;bar&quot;， &quot;baz&quot;） 任何数字字面量（例如： 1, 100） 应用了一元 -符号的数字字面量（例如： -1, -100） 123456789declare let a: Directionenum Animal { Dog, Cat}a = Direction.Up // oka = Animal.Dog // 不能将类型“Animal.Dog”分配给类型“Direction” 3.3 枚举合并如果基于之前的Direction再定义了一个枚举类型的Direction，会合并成一整个 123enum Direction { Center = 1} 5.接口(interface)5.1 属性修饰符12345interface User { name: string age?: number readonly isMale: boolean} ?：可选属性 readonly：只读属性 5.2 属性检查下面这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的 1234567891011interface Config { color?: string; width?: number;}function createSquare(config: Config): { color: string; area: number } { // ...}// error: 'colour' not expected in type 'Config'let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 }); 注意我们传入的参数是 colour，并不是 color 官方文档给了三种方式绕过这种检查 第一种使用类型断言： 1let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 } as Config); 第二种添加字符串索引签名： 12345interface Config { color?: string; width?: number; [propName: string]: any;} 这样Config可以有任意数量的属性，并且只要不是width或color，那么就无所谓他们的类型是什么了。 第三种将字面量赋值给另外一个变量： 12let options: any = { widdth: 5 };let mySquare = CalculateAreas(options); 5.3 可索引类型​ TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用&quot;100&quot;（一个string）去索引，因此两者需要保持一致。 123456789101112class Animal { name: string;}class Dog extends Animal { breed: string;}// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!interface NotOkay { [x: number]: Animal; [x: string]: Dog;} 索引类型查询操作符keyof，即索引类型查询操作符，我们可以用 keyof 作用于泛型T上来获取泛型T上的所有 public 属性名构成联合类型。举个例子，有一个Images类，包含src和alt两个public属性，我们用keyof取属性名： 1234567class Images { public src: string = 'https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png' public alt: string = '谷歌' public width: number = 500}type propsNames = keyof Images 效果如下：![2019-06-26-06-17-29](D:\\OneDrive - mail2.gdut.edu.cn\\typora_img\\Typescript语法篇\\16dbb13efd03fd86)keyof 正是赋予了开发者查询索引类型的能力。 映射类型映射类型的语法是[K in Keys]如果我们要把所有的属性成员变为可选类型，那么需要T[K]取出相应的属性值，最后我们重新生成一个可选的新类型{ [K in keyof T]?: T[K] }。 用类型别名表示就是： 1type partial&lt;T&gt; = { [K in keyof T]?: T[K] } 5.4 继承接口123interface VIPUser extends User { broadcast: () =&gt; void} VIPUser具有User所有的属性 6.类(Class)6.1抽象类 通常作为派生类的基类使用，与接口不同的是抽象类可以包含成员的实现 下面定义了一个Animal抽象类 123456abstract class Animal { abstract makeSound(): void; move(): void { console.log('roaming the earch...'); }} 如果直接实例化Animal抽象类则会报错，我们可以创建子类继承基类，然后实例化子类 1234567891011class Cat extends Animal { makeSound() { console.log('miao miao') }}const cat = new Cat()cat.makeSound() // miao miaocat.move() // roaming the earch... 6.2 访问限定符 public 类的成员默认为public 可被外部访问 private 只能类内部访问 protected 只能被类的内部以及类的子类访问 6.3 存取器属性具有get和set修饰符，只带有get不带有set的存取器自动被推断为readonly 7. 函数(Function)7.1 函数类型在小括号后面声明返回值类型 123function add(x: number, y: number): number { return x + y;} 用接口定义函数的形状我们也可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc { (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) { return source.search(subString) !== -1;} 采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。 7.2 可选参数利用?或则默认值设置可选参数，？可选参数必须放最后，默认值没必要放最后，但是不放最后必须使用undefined显式获取默认值 123function add(x: number, y?: number): number { return x + y;} 7.3 剩余参数剩余参数与JavaScript种的语法类似，需要用...来表示剩余参数，而剩余参数rest则是一个由number组成的数组，在本函数中用 reduce 进行了累加求和。 1const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a) 7.4 this参数如果直接使用this进行一些操作,typescript会进行报错，可以提供一个显式的this参数,该参数是假的,但是可以使重用变得清晰 12345678910111213interface Deck { suits: string[]; createCardPicker(this: Deck): () =&gt; string[];}let deck: Deck = { suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], // 注意:这个函数现在显式地指定它的被调用者必须是Deck类型 createCardPicker: function(this: Deck) { return () =&gt; { return this.suits; } }} 7.5 重载(Overload)函数根据传入不同的参数而返回不同类型的数据查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个 下面的assigned只能传递1、2、4个参数,用重载可以很好的对不同的参数列表进行检测 123456789101112131415161718192021222324252627282930// 重载interface Direction { top: number, bottom?: number, left?: number, right?: number}function assigned(all: number): Directionfunction assigned(topAndBottom: number, leftAndRight: number): Directionfunction assigned(top: number, right: number, bottom: number, left: number): Directionfunction assigned (a: number, b?: number, c?: number, d?: number) { if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) { b = c = d = a } else if (c === undefined &amp;&amp; d === undefined) { c = a d = b } return { top: a, right: b, bottom: c, left: d }}assigned(1)assigned(1,2)assigned(1,2,3) // 报错assigned(1,2,3,4) 8. 泛型(generic)下图T为一种类型变量，用于表示一种类型而不是值，我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number）。之后我们再次使用了T当做返回值类型，现在我们知道identity的参数类型和放回置类型是相同的了。 123function identity&lt;T&gt;(arg: T): T { return arg;} 8.1 泛型接口下图的T为整个接口的一个参数，而再使用GenericIdentityFn时，还得传入一个类型参数来指定泛型类型（这里是：number） 123456789interface GenericIdentityFn&lt;T&gt; { (arg: T): T;}function identity&lt;T&gt;(arg: T): T { return arg;}let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 8.2 泛型类与接口一样，直接把泛型类型放在类后面 123456class GenericNumber&lt;T&gt; { zeroValue: T; add: (x: T, y: T) =&gt; T;}let myGenericNumber = new GenericNumber&lt;number&gt;(); 8.3 泛型约束下面例子想要访问arg.length属性，但是是编译器并不能证明每种类型都有length属性，所以就报错了 1234function loggingIdentity&lt;T&gt;(arg: T): T { console.log(arg.length); // Error: T doesn't have .length return arg;} 我们可以定义一个接口来描述约束条件，然后需要传入符合约束类型的值，必须包含必须的属性 1234567891011interface Lengthwise { length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length); // Now we know it has a .length property, so no more error return arg;}loggingIdentity(3); // Error, number doesn't have a .length propertyloggingIdentity({length: 10, value: 3}); // right 8.4 多重类型进行泛型约束用交叉类型&amp;进行多重约束 12345678910111213141516interface FirstInterface { doSomething(): number}interface SecondInterface { doSomethingElse(): string}class Demo&lt;T extends FirstInterface &amp; SecondInterface&gt; { private genericProperty: T useT() { this.genericProperty.doSomething() // right this.genericProperty.doSomethingElse() // right }} 8.5 泛型里使用类类型我们假设需要声明一个泛型拥有构造函数，比如： 123function create&lt;T&gt;(type: T): T { return new type() // This expression is not constructable.} 但是这样会报错，因为我们没有声明T是构造函数，我们需要显式的用new来声明这个泛型T是构造函数 123function create&lt;T&gt;(type: {new(): T}): T { return new type();} 参数type的类型{new(): T}就表示此泛型T是可被构造的，在被实例化后的类型是泛型T 一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。 1234567891011121314151617181920212223242526class BeeKeeper { hasMask: boolean;}class ZooKeeper { nametag: string;}class Animal { numLegs: number;}class Bee extends Animal { keeper: BeeKeeper;}class Lion extends Animal { keeper: ZooKeeper;}function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A { return new c();}createInstance(Lion).keeper.nametag; // typechecks!createInstance(Bee).keeper.hasMask; // typechecks! 9. 类型兼容性Ts结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性，编译器会检查x中的每个属性，看是否能在y中也找到对应属性 10. 高级类型10.1 交叉类型用&amp;可以将多个类型合并为一个类型 10.2 联合类型用|表示一个值可为几种类型之一 12345678function formatCommandline(command: string[] | string) { let line = ''; if (typeof command === 'string') { line = command.trim(); } else { line = command.join(' ').trim(); }} 10.3 类型别名type虽然看起来和interface一样，但是可以用在原始类型、联合类型、元组等需要手写的类型，类型别名也可以是泛型 12345type some = boolean | stringconst b: some = true // okconst c: some = 'hello' // okconst d: some = 123 // 不能将类型“123”分配给类型“some” 类型别名和接口的区别 类型别名不能被extends和implements（自己也不能extends和implements其它类型） interface 可以实现接口合并声明 10.4 条件类型1T extends U ? X : Y 上面的代码可以理解为: 若 T 能够赋值给 U，那么类型是 X，否则为 Y,有点类似于JavaScript中的三元条件运算符 11. 类型保护和类型断言11.1 ！ 类型检查器认为 null与 undefined可以赋值给任何类型 可以使用--strictNullChecks来使变量不自动的包含null或 undefined，但是开启后可选参数会被自动地加上| undefined。 如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加!后缀： identifier!从 identifier的类型里去除了 null和 undefined 123456789101112131415function broken(name: string | null): string { function postfix(epithet: string) { return name.charAt(0) + '. the ' + epithet; // error, 'name' is possibly null } name = name || &quot;Bob&quot;; return postfix(&quot;great&quot;);}function fixed(name: string | null): string { function postfix(epithet: string) { return name!.charAt(0) + '. the ' + epithet; // ok } name = name || &quot;Bob&quot;; return postfix(&quot;great&quot;);} 11.2 is进行类型保护is之后的类型必须是参数类型中的一个，在后续调用改参数时，ts会将变量缩减为那个具体的类型 123456789101112function isString(test: any): test is string{ return typeof test === 'string';}function example(foo: number | string){ if(isString(foo)){ console.log('it is a string' + foo); // 如果上面没写test is string，foo.length将会报错 console.log(foo.length); // string function }}example('hello world'); 参考https://www.tslang.cn/docs/handbookhttps://ts.xcatliu.com/basics/type-of-function.html","link":"/2020/09/25/Ts/Typescript%E8%AF%AD%E6%B3%95%E7%AF%87/"},{"title":"学习css的网站","text":"codepen：https://codepen.io/css常见布局：https://csslayout.io/patterns/常见加载动画：https://tobiasahlin.com/spinkit/常见css效果：https://emilkowalski.github.io/css-effects-snippets/css灵感：https://chokcoco.github.io/CSS-Inspiration/#/自定义css组件：https://animista.net/","link":"/2020/09/20/Css/%E5%AD%A6%E4%B9%A0css%E7%9A%84%E7%BD%91%E7%AB%99/"},{"title":"EventBus的一种使用场景","text":"所谓事件总线，就是实例化Vue对象，在该实例上通过$on绑定事件、$emit触发事件、$off解绑事件，进行组件通信。 一、使用实例化Vue对象，并挂载到Vue.prototype 1Vue.prototype.$bus = new Vue(); 二、场景 在多个页面复用一个组件时，每个页面需要有点击按钮后，触发不同的事件 当然可以监听路由进行判断调用不同的函数，但是这样会在一个组件内写上很多其他组件应该触发的事件。 我们利用EventBus可以做到组件间的解耦 三、使用方法1.我们在各个页面上写好事件触发后调用的函数，然后在mounted（如果用keep-alive则是在activated，否则只挂载一次）this.$bus.$on上绑定该事件，在beforeDestory（如果用keep-alive则是在deactived，否则无法解绑事件）上用this.$bus.$off解绑事件。 1234567891011mounted() { this.$bus.$on(&quot;save&quot;, this.save);}beforeDestory() { this.$bus.$off(&quot;save&quot;, this.save);}save() { console.log(&quot;我没有写在复用组件上哦！&quot;)} 2.然后在复用的组件上触发事件 1this.$bus.$emit('save'); 也算是第一次尝试使用EventBus把，很好的降低了组件间的耦合度","link":"/2020/09/17/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/EventBus%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"title":"对于点歌台总结vuex持久化处理的补充","text":"针对刷新时vuex数据丢失，使用了vuex-persistedstate对vuex进行持久化处理官方github：https://github.com/robinvdvleuten/vuex-persistedstate 本文主要是对官网不够详细的案例进行补充，官网只讲了对vuex完全存储和对vuex模块的完全存储。但是我想对某一模块内部一些变量进行存储，谷歌了好多都没找到写法，自己试出来了。 首先引入vuex-persistedstate 1import createPersistedState from &quot;vuex-persistedstate&quot;; 利用官网给的reducer减少持久化的数据 1234567891011121314151617181920const store = new Vuex.Store({ state, getters, mutations, actions, modules: { projectDetail }, // @ts-ignore plugins: [createPersistedState({ reducer(val) { return { staffId: val.staffId, projectDetail: { curPjId: val.projectDetail.curPjId, } } } })]}) 可以看到该vuex结构具有projectDetail模块，我想对该模块内的curPjId进行单独存储，在reducer放回的对象的键设为模块名，里面写着想要持久化的变量，就可以了。 会在localstorage存储为如下所示","link":"/2020/09/16/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%AF%B9%E4%BA%8E%E7%82%B9%E6%AD%8C%E5%8F%B0%E6%80%BB%E7%BB%93vuex%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86%E7%9A%84%E8%A1%A5%E5%85%85/"},{"title":"element的表单验证效果替换","text":"在做项目的时候看到了这个需求，需要用图片替换默认的文字显示 f12可以看到出错了的表单项会在div.el-form-item__content下有个div.el-form-item__error 于是就对div.el-form-item__error进行操作 12345678910111213141516171819202122232425/deep/ .el-form-item__content { display: flex; // 使错误信息显示在同一行 margin-right: 20px; // 修改错误显示 /deep/ .el-form-item__error { position: relative; top: 0; right: 0; font-size: 0; // 把默认文字取消 // 用伪元素插入背景图片 &amp;:after { content: &quot;&quot;; display: block; width: 20px; height: 20px; position: absolute; right: -10px; top: 10px; background: url(&quot;~@/assets/img/error.png&quot;) 0 0 no-repeat; background-size: 20px 20px; } }}","link":"/2020/09/15/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/element%E7%9A%84%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E6%95%88%E6%9E%9C%E6%9B%BF%E6%8D%A2/"},{"title":"微信网页授权","text":"照着官方教程设置好JS接口安全域名并且把文件放到服务器后 首先需要引入weixin-js-sdk 然后创建一个文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172export default function weixinShare() { return axios .get(`${base.BASE_URL}/share`, { params: { url: location.href.split(&quot;#&quot;)[0] }, }) .then((res) =&gt; { const { data: { code, data }, } = res; if (code === 200) { wx.config({ // 获取微信接口的权限 appId: appId, // 必填，企业号的唯一标识，此处填写企业号corpid timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature, // 必填，签名，见附录1 jsApiList: [ &quot;updateAppMessageShareData&quot;, &quot;onMenuShareTimeline&quot;, &quot;onMenuShareAppMessage&quot;, ], // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 }); let imgUrl = &quot;imgUrl&quot;; let title = &quot;title&quot;; let desc = &quot;&quot;; axios.get(`${base.BASE_URL}/random_link`).then((res) =&gt; { const { data: { data, code }, } = res; if (code === 200) { if (data.linkImage) { imgUrl = data.linkImage; } if (data.linkTittle) { title = data.linkTittle; } if (data.linkContent) { desc = data.linkContent } } //需在用户可能点击分享按钮前就先调用 wx.ready(function() { // 分享给朋友 及 分享到QQ wx.updateAppMessageShareData({ title: title, // 分享标题，（必填，否则失效） desc: desc, // 分享描述 link: link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: imgUrl, // 分享图标（必填，否则失效） success: function() { console.log(&quot;success&quot;); }, fail: function(err) { console.log(JSON.stringify(err)); }, }); // 分享到朋友圈 wx.onMenuShareTimeline({ title: data.linkTittle, // 分享标题 link: link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: imgUrl, // 分享图标 success: function() { console.log(&quot;success&quot;); }, fail: function(err) { console.log(JSON.stringify(err)); }, }); }); }); } });} 12345678beforeEnter(to, from, next) { weixinShare().then(() =&gt; { next(); }).catch(res=&gt;{ console.log('res: ', res); next(); });} 然后在进入页面前调用该接口","link":"/2020/08/18/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83/"},{"title":"点歌台项目总结","text":"1. img标签src为空的异常样式根据用户性别来显示不同的图标，但是如果获取失败，导致img的src为空从而显示异常处理 12345// 解决src为空的异常样式img[src=&quot;&quot;],img:not([src]) { opacity: 0;} 2.Safari碰到的问题2.1 伪类active失效在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态 1document.body.addEventListener('touchstart', function () {}); 2.2 input和textarea有上内阴影1-webkit-appearance: none; 3.移动端布局 1234567&lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt;&lt;div&gt;6&lt;/div&gt;&lt;div&gt;7&lt;/div&gt;&lt;div&gt;8&lt;/div&gt;&lt;div&gt;9&lt;/div&gt;&lt;div&gt;10&lt;/div&gt;&lt;div&gt;11&lt;/div&gt;&lt;div&gt;12&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526.page { // 整体flex竖式布局 display: flex; flex-direction: column; height: 100vh; overflow: hidden;}.content { // 内容容器 flex: 1; overflow-y: scroll; -webkit-overflow-scrolling: touch; // 移动回弹 &amp;::-webkit-scrollbar { display: none; } div { // 具体内容 margin: 10px 0; height: 50px; background-color: #999; }}.footer { height: 60px;} 4. textarea把icon图片显示在输入前 1234567textarea { text-indent: 23px; &amp;::placeholder { text-indent: 23px; }} 利用text-indent来使输入光标后置，然后图片用定位设置在指定位置 5. ios弹键盘 上移布局且不恢复1&lt;input @blur.prevent=&quot;checkValue&quot; type=&quot;text&quot; /&gt; 12345678910111213141516checkValue () { inputBlur() this.$emit('checkValue')}inputBlur() { let u = navigator.userAgent; let isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); if (isIOS) { setTimeout(() =&gt; { const scrollHeight = document.documentElement.scrollTop || document.body.scrollTop || 0; window.scrollTo(0, Math.max(scrollHeight - 1, 0)); }, 200); }} 6.滑块样式 1&lt;input type=&quot;checkbox&quot; class=&quot;slide-btn&quot;/&gt; 12345678910111213141516171819202122232425262728293031.slide-btn { position: relative; -webkit-appearance: none; width: 50px; height: 23px; border: 1px solid #e9e9e9; border-radius: 30px; outline: none;}.slide-btn:before { content: &quot;&quot;; position: absolute; top: 50%; transform: translateY(-50%); left: 1px; width: 18px; height: 18px; border-radius: 50%; background: #e9ddd8; transition: all 0.2s linear;}.slide-btn:checked { background: #fff4f0; border: 1px solid #fff4f0;}.slide-btn:checked:before { left: 29px; background-color: #ff935f; transition: all 0.2s linear;} 7. 背景颜色和背景图片同时设置前面的背景会叠在之后的背景之上，所以背景色通常都定义在最后一组上，避免背景色将图像盖住 8. 文字超出处理8.1 一行超出省略123white-space: nowrap; // 不换行overflow: hidden;text-overflow: ellipsis; // 省略号 触发text-overflow需要 overflow为非visible 显式或隐式定义width值 white-space为非nowrap值 8.2 最多两行，超出利用展开收起兼容性不太好 12345678910111213.show2line { display: -webkit-box; overflow: hidden; -webkit-line-clamp: 2; /* 限制在一个块元素显示的文本的行数 */ -webkit-box-orient: vertical; /* 垂直排列 */ text-overflow: ellipsis;}.showAll { display: block; overflow: auto; height: auto;} 9. 部分机型设置透明度0.x会完全透明10. 刷新会导致vuex丢失一段时间目前的解决方案是存localstorage或者从router.query获取，还看到有用vuex-persistedstate。","link":"/2020/08/18/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%82%B9%E6%AD%8C%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"js中的变量声明","text":"一、 es5和es6中变量声明的区别 变量提升 块级作用域 重复声明 var 会 无 能 let、const 不会 有 不能 二、各种变量声明的特点1. var当var被作用于全局作用域时，他会把变量作为全局对象（浏览器环境中的window对象）的属性 由于没有块级作用域，所以任何位置的变量的声明在js引擎扫描代码的时候，将其提升至所在作用域的顶部 123456789function getValue(condition) { if (condition) { var value = &quot;blue&quot;; return value; } else { // 此处可访问变量value，其值为undefined return null; }} 被js引擎解析成如下所示 1234567891011function getValue(condition) { var value; // value的生命提升到所在作用域的顶部 if (condition) { value = &quot;blue&quot;; return value; } else { // 此处可访问变量value，其值为undefined return null; }} 2. let/const的共同特点2.1 具有块级作用域存在于 函数内部 块中（字符 { 和 } 之间的区域） 循环中的块级作用域绑定var声明使得变量到循环外仍能访问 1234567891011var funcs = [];for (var i = 0; i &lt; 10; i++) { funcs.push(function() { console.log(i); });}funcs.forEach(function(func) { func(); // 输出10次数字10}); 为了解决这个问题，可以使用立即执行函数（IIFE），为接受的每一个参数i都创建了一个副本并储存为变量value 12345678// 循环修改成for (var i = 0; i &lt; 10; i++) { funcs.push((function(value) { return function() { console.log(value); } }(i)));} 而在es6中的let简化了这个过程，每次迭代循环都会创建一个新变量，并以之前迭代中同名变量的值将其初始化 特别的如果在for循环中用const替换了let，则const声明的变量不能在后续的循环中被修改，而在for-in或for-of循环中使用const时的行为与使用let一致，因为每次迭代是创建一个新绑定 2.2 禁止重复声明​ 会报 Identifier ‘变量’ has already been declared 的错 2.3 暂时性死区（Temporal Dead Zone）js引擎在扫描代码的时候发现let或者const声明的变量，会将他放到TDZ，访问TDZ中的变量会触发运行时错误，只有执行过变量声明语句后，才会把变量从TDZ中移除 由于块级作用域，所以在声明的变量的作用域外使用则不会报错 12345console.log(typeof value); // undefinedif (condition) { let value = &quot;blue&quot;;} 三、函数声明123456789101112// 函数表达式var f = function() { console.log(1); }// 直接声明function f (){ console.log(2);}// 如果两种声明方式声明同一个函数名，最终执行的是 函数表达式f(); // 1 第一种方式：函数只能在声明之后调用，因为这种函数声明是在函数运行的阶段才赋值给变量 f 的 第二种方式：函数可以在声明函数的作用域内任一地方调用。因为这种方式，是在函数解析阶段赋值给标识符 f . 函数声明提升优先于变量提升，且不会被变量声明覆盖，但是会被变量赋值覆盖 123456console.log(foo); // [Function: foo]function foo(){ console.log(&quot;函数变量&quot;);}var foo = &quot;变量&quot;;console.log(typeof foo) //string 下面来看一段代码 123456789{ function test(a) { console.log(typeof test); // function test = a; // 1 } test(1); console.log(typeof test); // number}console.log(typeof test); // function 由于函数提升，会提升到块级作用域外，所以输出外层的test的类型为function，由于块级作用域，变量重写只能在块内生效 2021.2.10 块级作用域以及TDZ的新理解代码执行的第一步是编译并创建执行上下文，如下图所示，var声明的变量在变量环境中，let和const在词法环境中，词法环境其实 是维护了一个小型栈结构，栈底是最外层的变量 第二步再执行代码，当作用域执行完成后，该作用域的信息就会从词法环境中弹出。 而变量经历了 创建、初始化、赋值，创建和初始化是在编译阶段完成的，变量就会放置到对应的环境，但是初始化要看变量的声明方式。 var的创建和初始化被提升，赋值不会被提升 let、const的创建被提升，初始化和赋值不会被提升 function的创建、初始化和赋值均会被提升 我们看如下的代码 12345let myname = 'liang1'{ console.log(myname) let myname = 'liang2' // 在该块上部形成了暂时性死区} 代码出现错误ReferenceError: Cannot access 'myname' before initialization，因为在块内访问myname的时候，在词法环境内已经有该块内创建的myname变量，在初始化前访问就报错了。 参考文章https://zhuanlan.zhihu.com/p/126237126https://www.cnblogs.com/miacara94/p/9173843.html《深入理解ES6》 第一种方式：函数只能在声明之后调用，因为这种函数声明是在函数运行的阶段才赋值给变量 f 的 第二种方式：函数可以在声明函数的作用域内任一地方调用。因为这种方式，是在函数解析阶段赋值给标识符 f . 函数声明提升优先于变量提升，且不会被变量声明覆盖，但是会被变量赋值覆盖 123456console.log(foo); // [Function: foo]function foo(){ console.log(&quot;函数变量&quot;);}var foo = &quot;变量&quot;;console.log(typeof foo) //string 下面来看一段代码 12345678{ function test(a) { test = a; // 1 } test(1); console.log(typeof test); // number}console.log(typeof test); // function 由于函数提升，会提升到块级作用域外，所以输出外层的test的类型为function，由于块级作用域，变量重写只能在块内生效 参考文章https://zhuanlan.zhihu.com/p/126237126https://www.cnblogs.com/miacara94/p/9173843.html《深入理解ES6》","link":"/2020/07/31/Js/js%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"},{"title":"事件 Event","text":"事件是您在编程时系统内发生的动作或者发生的事情——系统会在事件出现的时候触发某种信号并且会提供一个自动加载某种动作，列举一些可能发生的事件。 用户在某个元素上点击鼠标或悬停光标。 用户在键盘中按下某个按键。 用户调整浏览器的大小或者关闭浏览器窗口。 一个网页停止加载。 提交表单。 播放、暂停、关闭视频。 发生错误。 1.事件处理器可以为每一个事件绑定一个事件处理器(事件监听器)，用以事件被激发时做出的回应，有三种事件处理器。 1.1 事件处理器属性（DOM0级）12var btn = document.querySelector('button');btn.onclick = function(event){alert('Hello world');}; 该函数在定义时，可以传入一个 event 形式的参数，该方式的问题在于一次只能绑定一个。 除了onclick还有一些常见的事件处理器属性 事件处理器属性 备注 btn.onfocus 当前元素获得键盘焦点时会触发focus事件 btn.onblur 当一个元素失去焦点时会触发blur事件 btn.ondblclick 当前元素上双击鼠标左键会触发dblclick事件 window.onkeypress 当用户在键盘上按下任意键时，应当会触发 keypress 事件 window.onkeydown 当用户按下键盘上的按键时会触发keydown事件 window.onkeyup 在当前元素上释放键盘按键时会触发keyup事件 btn.onmouseover 当鼠标移动到一个元素上时,会在这个元素上触发mouseover事件 btn.onmouseout 当鼠标离开一个元素时,会在这个元素上触发mouseout事件 1.2 行内事件处理器 - 请勿使用1&lt;button onclick=&quot;alert('Hello World');&quot;&gt;Press me&lt;/button&gt; 我们应该避免使用这种方式。因为它会使标记数量变大，而可读性却较差。 内容/结构 和 行为之间没有很好的分离，使得在处理bug时非常困难。 1.3 addEventListener()（DOM2级）12var btn = document.querySelector('button');btn.addEventListener('click', function(){alert('Hello world');}, false); addEventListener()参数 参数名 传入参数 type 表示监听事件类型的字符串。 listener 实现了Event接口的对象或者函数 options 可选 一个指定有关 listener属性的可选参数对象 useCapture 可选 Boolean，默认为false，在事件冒泡阶段调用事件处理程序，反之为捕获 addEventListener()返回值undefined 在DOM2级可以给同一个监听器注册多个处理器，而DOM0级不能实现这一点： 12myElement.onclick = functionA;myElement.onclick = functionB; 第二行会覆盖第一行，但是下面这种方式就会正常工作了： 12myElement.addEventListener('click', functionA);myElement.addEventListener('click', functionB); 当元素被点击时两个函数都会工作 注意：通过addEventListener()添加的事件处理程序只能用removeEventListener()来移除，并且移除时传入的参数必须与添加时传入的参数一样。 1.4 IE事件处理器IE用了attachEvent()，detachEvent()，接收两个参数，事件名称、事件处理程序，通过 attachEvent() 添加的事件处理程序都会被添加到冒泡阶段,所以平时为了兼容更多的浏览器最好将事件添加到事件冒泡阶段,IE8及以前只支持事件冒泡; 例子： 12345var btn = document.getElementById('btn');var handlers = function(){ console.log(this === window); //true,注意attachEvent()添加的事件处理程序运行在全局作用域中;};btn.attachEvent('onclick', handlers); 跨浏览器事件处理程序12345678910111213141516171819202122//创建的方法是addHandlers(),removeHandlers(),这两个方法属于一个叫EventUtil的对象;但是这个没有考虑到IE中作用域的问题，不过就添加和移除事件还是足够的。 var EventUtil = { addHandlers: function (element, type, handlers) { if (element.addEventListener) { element.addEventListener(type, handlers, false); } else if (element.attachEvent) { element.attachEvent(on + type, handlers); } else { element['on' + type] = handlers; } }, removeHandlers: function (element, type, handlers) { if (element.removeEventListener) { element.removeEventListener(type, handlers, false); } else if (element.detachEvent) { element.detachEvent(on + type, handlers); } else { element['on' + type] = null; } }}; 例子： 123456var btn = document.getElementById('btn');var handlers = function() { console.log('123')};EventUtil.addHandlers(btn, 'click', handlers);EventUtil.removeHandlers(btn, 'click', handlers); 在同一个对象上注册事件，并不一定按照注册顺序执行，冒泡或捕获模式会影响其被触发的顺序 2.事件冒泡及捕获当一个事件发生在具有父元素的元素上，现代浏览器运行两个不同的阶段——捕获阶段和冒泡阶段。 2.1捕获阶段 浏览器检查元素的最外层祖先&lt;html&gt;，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。 然后，它移动到&lt;html&gt;中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。 2.2冒泡阶段 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个onclick事件处理程序，如果是，则运行它 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达&lt;html&gt;元素。 2.3用stopPropagation()修复问题当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在冒泡链上进一步扩大，因此将不会有更多事件处理器被运行(不会向上冒泡)。 3.事件对象 eventevent，evt或简单的e。 这被称为事件对象，它被自动传递给事件处理函数，以提供额外的功能和信息，比如： 123456function bgChange(e) { var rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')'; e.target.style.backgroundColor = rndCol; console.log(e);} btn.addEventListener('click', bgChange); 事件对象 e 的target属性始终是事件刚刚发生的元素的引用。 跨浏览器的事件对象虽然DOM和IE中对象不同，但是两者event中的全部信息和方法都是类似的只是实现方式不同，可以用前面提到过的EventUtil对象来求同存异。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var EventUtil = { addHandler: function (element, type, handler) { if (element.addEventListener) { element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(on + type, handler); } else { element['on' + type] = handler; } }, getEvent: function (event) { return event ? event : window.event; }, getTarget: function (event) { return event.target || event.srcElement; }, preventDefault: function (event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, stopPropagation: function (event) { if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } }, removeHandler: function (element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(on + type, handler); } else { element['on' + type] = null } }}; 4.事件委托4.1 问题初现给100个按钮绑定事件，传统的做法就是：通过DOM操作获取每一个按钮元素分别绑定事件处理函数。 但在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间。 而每一个函数都是一个对象，所以都会占用内存，内存占用的越多性能毋庸置疑的会变得越差。 4.2 解决方案——事件委托事件委托就是利用事件冒泡，即：利用冒泡机制将一类事件触发尽可能高的委托给其父节点或祖先节点来触发事件处理函数，这样只需要定义一个函数，访问一次DOM对象，减少了内存的占用以及访问DOM元素的时间，降低了性能的消耗。 例子：点击某一个 Li 标签时，将 Li 的背景色显示在 P 标签内，并将 P 标签中的文字颜色设置成 Li 的背景色，下面是html 123456789101112&lt;ul class=&quot;palette&quot;&gt; &lt;li style=&quot;background-color:crimson&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:bisque&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:blueviolet&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:coral&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:chartreuse&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:darkolivegreen&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:cyan&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#194738&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;color-picker&quot;&gt;&lt;/p&gt; 实现方法 1234567891011const list = document.querySelector(&quot;.palette&quot;);list.onclick = function(e) { e = e || window.event; const t = e.target || e.srcElement; const p = document.getElementsByClassName('color-picker')[0]; if (t.nodeName.toLowerCase() === 'li') { p.innerHTML = t.style.backgroundColor; p.style.color = t.style.backgroundColor; }} 适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress。 参考文章https://www.cnblogs.com/lazychen/p/5664788.html","link":"/2020/07/31/Js/%E4%BA%8B%E4%BB%B6-Event/"},{"title":"定位与层级","text":"1. 定位 position1.1 静态定位 static每个元素的默认值，将元素放入它在文档布局流中的正常位置。 1.2 相对定位 relative开启定位后，可以使用top、right、bottom，left四个属性设置偏移量。选择一个垂直方向和竖直方向上的偏移量即可为一个元素定位。 要点 相对定位的元素不会脱离文档流 开启相对定位后，如果不设置偏移量，元素不会发生任何变化 相对定位是相对于元素在文档流中原来的位置进行定位 相对定位会使元素提升一个层级 相对定位不会改变元素的性质 1.3 绝对定位 absolute定位方式同上 要点 绝对定位的元素会脱离文档流 开启绝对定位后，如果不设置偏移量，元素不会发生任何变化 绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位） - 如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位 绝对定位会使元素提升一个层级 绝对定位会改变元素的性质 - 内联元素变块元素 - 块元素的宽度和高度默认都被内容撑开 1.4 固定定位 fixed​ 定位方式同上 要点固定定位也是一种绝对定位，大部分特点与绝对定位一致，不同的是 固定定位永远都会相对于浏览器窗口进行定位 固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动 IE6不支持固定定位 2.层级 z-index要点 如果定位元素的层级是一样，则下边的元素会盖住上边的 层级越高，越优先显示 对于没有开启定位的元素不能使用z-index 定位的元素都具有z-index为auto，实际上为0","link":"/2020/07/31/Css/%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%B1%82%E7%BA%A7/"},{"title":"浮动与BFC","text":"1. 浮动的工作原理浮动会脱离正常的文档流，并吸附到其父容器左边，正常布局中位于浮动元素下的内容会围绕着浮动元素 2.可选值 值 效果 none 默认值，元素默认在文档流中排列 left 元素会立即脱离文档流，向页面的左侧浮动 right 元素会立即脱离文档流，向页面的右侧浮动 3.浮动的规则内联元素变块元素当为一个元素设置浮动以后（float属性是一个非none的值），元素会立即脱离文档流，元素脱离文档流以后，它下边的元素会立即向上移动，元素浮动以后，会尽量向页面的左上或这是右上漂浮，直到遇到父元素的边框或者其他的浮动元素如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过块元素，浮动的元素不会超过他上边的兄弟元素，最多最多一边齐。 4.浮动的包裹性指的是元素尺寸刚好容纳内容, 表现得就像diaplay:inline-block 一样具有包裹性的其他属性: 123display:inline-blockposition:absolute/fixed/stickyoverflow:hidden/scroll 5. 浮动的破坏性会使父元素高度塌陷——为了实现文字环绕效果 具有破坏性的其他属性: 12display:noneposition:absolute/fixed/sticky 6.清除浮动 clear清除掉其他元素浮动对当前元素产生的影响 可选值 值 效果 none 默认值，不清除浮动 left 清除左侧浮动元素对当前元素的影响 right 清除右侧浮动元素对当前元素的影响 both 清除两侧浮动元素对当前元素的影响 7.解决高度塌陷7.1 BFC根据W3C的标准，在页面中元素都一个隐含的属性叫做块级格式化上下文(Block Formatting Context)，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域，可以设置打开或者关闭，默认是为关闭的。 BFC打开方式 设置父元素元素浮动 - 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失。 - 而且使用这种方式也会导致下边的元素上移，不能解决问题。 设置元素绝对定位 设置元素为flex-box，grid 或 display: table-cell / table-caption / inline-block - 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 将元素的overflow设置为一个非visible的值 - 此为副作用最小的方式 BFC特性 创建了BFC的元素中，子浮动元素也会参与高度计算，即父元素的垂直外边距不会和子元素重叠。 开启BFC的元素是一个独立的容器，子元素不会影响外面的元素，反之亦然——可以解决外边距合并的问题 开启BFC的元素 开启BFC的元素可以包含浮动的子元素 由此得到解决高度塌陷的第一种方法 1overflow: hidden; IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。 在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：zoom: 1; 最后得到以下形式 123overflow: hidden;/* zoom表示放大的意思，只在IE中支持 */zoom: 1; 7.2 用空白元素设置clear:both可以直接在高度塌陷的父元素的最后，添加一个空白的div，由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用。 123.clear { clear: both;} 1234&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 虽然可以解决问题，但会在文档中添加多余的结构，不符合结构与表现分离的思想。 7.3 隐式元素由7.2的方法可以想到用css实现的方法 123456789101112.clearfix:after { /* 添加一个内容 */ content: &quot;&quot;; /* 转换为一个块元素 */ display: block; /* 清除两侧的浮动 */ clear: both;}/* 兼容IE6 */.clearfix { zoom:1;} 参考文章http://ife.baidu.com/note/detail/id/959","link":"/2020/07/31/Css/%E6%B5%AE%E5%8A%A8%E4%B8%8EBFC/"},{"title":"Java的字符串操作","text":"一、比较 语言 操作 形式 机制 线程安全性 c/c++ char* 字符指针 通过手动修改指针指向的内存空间修改字符串 未知 c/c++ String 容器类 内部使用char数组存储字符，但内存管理，分配和null终止都由字符串类本身来处理 并发的读操作是线程安全的 Java String 1. String a = “a”，是以字面常量的形式储存在常量池中2. new String(“a”) 创建的以对象的形式存放在堆中 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象 安全 Java StringBuilder 对象 所有操作都在原有的对象上进行 不安全 Java StringBuffer 对象 所有操作都在原有的对象上进行 安全 二、性能测试测试代码1234567891011121314151617181920212223242526272829303132333435363738394041public class Main { private static int NUM = 100000; public static void main(String[] args) { System.out.println(NUM + &quot;:&quot;); testString(); testStringBuffer(); testStringBuilder(); } private static void testString() { long start = System.currentTimeMillis(); String str = &quot;&quot;; for (int i = 0; i &lt; NUM; i++) { str += i; } long end = System.currentTimeMillis(); System.out.println(&quot;String:&quot; + (end - start) + &quot;ms&quot;); } private static void testStringBuffer() { long start = System.currentTimeMillis(); StringBuffer str = new StringBuffer(); for (int i = 0; i &lt; NUM; i++) { str.append(i); } long end = System.currentTimeMillis(); System.out.println(&quot;StringBuffer:&quot; + (end - start) + &quot;ms&quot;); } private static void testStringBuilder() { long start = System.currentTimeMillis(); StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; NUM; i++) { str.append(i); } long end = System.currentTimeMillis(); System.out.println(&quot;StringBuilder:&quot; + (end - start) + &quot;ms&quot;); }} 测试结果1234100000:String: 2907msStringBuffer: 9msStringBuilder: 5ms 在该测试中String在字符串拼接上明显低于其他两者，也说明了String每次拼接字符串都要新建对象的时间消耗很大，而StringBuffer加了synchronized是线程安全的，在效率上不如StringBuilder，符合了预期。 三、java正则表达式代码1234567891011121314151617181920212223242526272829303132public static void main(String[] args) { // 邮政编码 String postal_code = &quot;[1-9]\\\\d{5}&quot;; // 区号-座机号码 String landline = &quot;\\\\d{3}-\\\\d{8}|\\\\d{4}-\\\\d{7}&quot;; // 手机号码 String phone = &quot;1[345678]\\\\d{9}&quot;; // 测试字符串 String text = &quot;513215 13411156663 010-88888888&quot;; Pattern r = Pattern.compile(postal_code); Matcher m = r.matcher(text); System.out.println(&quot;邮政编码：&quot;); if (m.find()) { System.out.println(m.group()); } r = Pattern.compile(landline); m = r.matcher(text); System.out.println(&quot;区号-座机号码：&quot;); if (m.find()) { System.out.println(m.group()); } r = Pattern.compile(phone); m = r.matcher(text); System.out.println(&quot;手机号码：&quot;); if (m.find()) { System.out.println(m.group()); }} 结果123456邮政编码：513215区号-座机号码：010-88888888手机号码：13411156663 参考资料探秘Java中的String、StringBuilder以及StringBufferC++ string class and its applicationshttps://www.runoob.com/java/java-regular-expressions.html","link":"/2020/07/31/Java/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"title":"四则运算生成命令行程序 (Python)","text":"Github项目地址：Github Pages结对项目成员：张鹏 3118004985 郑靓 3118004988 一、项目需求分析 二、功能实现 三、代码实现or功能说明★ GUI功能扩展说明 🎈 采用了多线程的界面，任何操作不会阻塞其他操作，例如：可以在生成答案的同时批改作业 得益于上面的设计，可以同时生成多个表达式文件，存储形式如下所示 对于错误的输入，会有提示，如下所示 对于文件选择后，点击批改，对于文件的格式有错误检查 通过后缀表达式的计算过程，确保生成表达式满足题目所有要求，避免重复的表达式生成 (详参下文 ‘判断重复的思路’ )★ 多线程（防止I/O阻塞）🎈 创建生产者线程, 传参进队列 ‘queue’ producer = multiprocessing.Process(target=self.expression_generator, args=(queue,)) 创建消费者进程, 传参进队列 ‘queue’ consumer = multiprocessing.Process(target=self.io_operation, args=(queue,)) 生产者——循环生成表达式 及其答案 构建随机表达式 以及生成其答案 ‘ Arithmetic(self.domain).create_arithmetic() ‘ 生成其表达式对应答案 ‘ Calculate(expression).cal_expression() ‘ 将生成后缀表达式过程中每次的结果 以及操作符集合 保存到 字典 (‘ self.no_repeat_dict ‘ ) 中, 从而确保生成等式不相同 (即 3+2+1 与 1+2+3 不相等, ６×8 与 8×6 相等) 生成完成后, 把表达式 以及 答案添加到队列 queue 中 消费者——循环生成表达式 及其答案 通过死循环不断获取队列内容, 若队列传出 ‘None’ 信号, 消费者进程停止 解析从队列获取的内容, 并将多次获取的表达式以及答案保存到 缓冲区(Buffer) 中, 有限次数后开始写入文件 并 销毁缓冲区内容 ★ 判断重复的思路 🎈 由于考虑到题目说1+2+3，2+1+3相等，1+2+3和3+2+1是不相等的，我一开始是从字符串的处理考虑，但是复杂度有点高。 所以换了一个角度考虑，从运算顺序入手，就想到用后缀表达式进行去重，并且这样也不用考虑括号，符合题目所说的（1+2)+3和1+2+3相等 具体就是存储每一次运算出来的结果，然后进行一一比较 例如（这里举的是比较简单的例子）： 1+2+3，压入的数字：[3, 6]; 3+2+1，压入的数字：[5，6]，所有两个判断为不相等 但是这样会出现1+3和2+2判断为重复的情况，所以添加两个数组——[操作数]，[运算符]，作为比较的依据 再来考虑效率，用字典的数据结构，以答案为键，其他三个比较标志作为值，只在答案相等的情况下判重 附：最终选定了添加后缀计算的去重模式，就是为了避免 (1÷1)+3 和 1+(3÷1) 这种不为重复表达式的情况，但是效率确实比只判断（操作数、运算符）的模式低了 ——创建数据结构12345678# 用答案作为索引构建的字典，{ &quot;1'2/2&quot;: [ [[压入的数字], [操作数], [运算符]], [[压入的数字], [操作数], [运算符]], ... ]} 1234567891011121314# 通过比较上述字典, 确认新表达式是否已经在上述字典中def judge_repeat(self, answer, test_sign): for expression_sign in self.no_repeat_dict[answer]: # 记录相同的个数 same_num = 0 for i in range(3): if collections.Counter(expression_sign[i]) == collections.Counter(test_sign[i]): same_num += 1 # 如果中间结果、操作数、运算符均相等，则为重复 if same_num == 3: return False return True ★ 生成表达式思路 🎈12# 表达式列表形式['10', '÷', '(', '8/9', '÷', '51', ')'] 随机生成操作数列表，运算符列表 根据以上两个列表构建无括号表达式 根据运算符个数，随机生成括号个数，最大个数为（ 1-&gt;0, 2-&gt;1, 3-&gt;2 ） 再随机括号位置，维护操作数位置列表，插入括号 1234567891011121314151617181920212223242526# 生成表达式def create_arithmetic(self): # 生成随机操作数、运算符列表 self.create_operand_list() self.create_operator_list() i = 0 # 构建表达式列表 self.expression_split.append(self.operand_list[i]) self.expression_split.append(self.operator_list[i]) i += 1 while i &lt; len(self.operator_list): self.expression_split.append(self.operand_list[i]) self.expression_split.append(self.operator_list[i]) i += 1 self.expression_split.append(self.operand_list[i]) # 插入括号 if self.operator_num != 1: bracket_num = random.randint(1, self.operator_num - 1) self.insert_bracket(bracket_num) # 删除无用括号 self.del_useless_bracket() return [self.expression_split, self.operand_list, self.operator_list] ★ 计算思路（后缀表达式） 🎈生成后缀表达式 设置两个栈，一个用以存储运算符，一个用以存储后缀表达式 循环遍历表达式列表，如果是操作数，则加入后缀栈 否则如果是运算符则进入以下判断 如果运算符栈为空，或者栈顶为 ( ，则压入运算符栈 否则如果当前运算符大于栈顶运算符的优先级，则压入运算符栈 否则弹栈并压入后缀栈直到优先级大于栈顶或空栈 否则如果遇到括号则进入以下判断 若为 ( 直接压入运算符栈 否则弹栈并压入后缀栈直到遇到 ( 将运算符栈剩余的元素压入后缀栈 计算后缀表达式 用一个栈（calculate_stack）作为计算中介 循环遍历后缀表达式，若为数字压入 calculate_stack 否则从 calculate_stack 弹出两个数字，分别化为分数类，进行计算，结果压入 calculate_stack 重复 2-3，若期间运算结果出现负数，或除数为0，则返回false 直至后缀表达式遍历完成，返回 calculate_stack 的栈顶 代码 🎈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class Calculate(object): def __init__(self, expression): self.expression = expression # 分数加法 a1/b1 + a2/b2 = (a1b2 + a2b1)/b1b2 @staticmethod def fraction_add(fra1, fra2): molecular = fra1.molecular * fra2.denominator + fra2.molecular * fra1.denominator denominator = fra1.denominator * fra2.denominator return Fraction(molecular, denominator) # 分数减法 a1/b1 - a2/b2 = (a1b2 - a2b1)/b1b2 @staticmethod def fraction_minus(fra1, fra2): molecular = fra1.molecular * fra2.denominator - fra2.molecular * fra1.denominator denominator = fra1.denominator * fra2.denominator return Fraction(molecular, denominator) # 分数乘法 a1/b1 * a2/b2 = a1a2/b1b2 @staticmethod def fraction_multiply(fra1, fra2): molecular = fra1.molecular * fra2.molecular denominator = fra1.denominator * fra2.denominator return Fraction(molecular, denominator) # 分数除法 a1/b1 ÷ a2/b2 = a1b2/a2b1 @staticmethod def fraction_divide(fra1, fra2): molecular = fra1.molecular * fra2.denominator denominator = fra1.denominator * fra2.molecular return Fraction(molecular, denominator) # 基本运算选择器 def operate(self, num1, num2, operater): if not isinstance(num1, Fraction): num1 = Fraction(num1) if not isinstance(num2, Fraction): num2 = Fraction(num2) # 计算结果 if operater == '+': return self.fraction_add(num1, num2) if operater == '-': return self.fraction_minus(num1, num2) if operater == '×': return self.fraction_multiply(num1, num2) if operater == '÷': return self.fraction_divide(num1, num2) # 转成逆波兰 def generate_postfix_expression(self): # 运算符栈 operator_stack = [] # 后缀栈 postfix_stack = [] for element in self.expression: # 如果是操作数则添加 if element not in operators: postfix_stack.append(element) # 如果是运算符则按优先级 elif element in operator.values(): # 运算符栈为空，或者栈顶为(，则压栈 if not operator_stack or operator_stack[-1] == '(': operator_stack.append(element) # 若当前运算符优先级大于运算符栈顶，则压栈 elif priority[element] &gt;= priority[operator_stack[-1]]: operator_stack.append(element) # 否则弹栈并压入后缀队列直到优先级大于栈顶或空栈 else: while operator_stack and priority[element] &lt; priority[operator_stack[-1]]: postfix_stack.append(operator_stack.pop()) operator_stack.append(element) # 如果遇到括号 else: # 若为左括号直接压入运算符栈 if element == '(': operator_stack.append(element) # 否则弹栈并压入后缀队列直到遇到左括号 else: while operator_stack[-1] != '(': postfix_stack.append(operator_stack.pop()) operator_stack.pop() while operator_stack: postfix_stack.append(operator_stack.pop()) return postfix_stack # 计算表达式(运算过程出现负数，或者除数为0，返回False，否则返回Fraction类) def cal_expression(self): # 生成后缀表达式 expressions_result = self.generate_postfix_expression() # 存储阶段性结果 stage_results = [] # 使用list作为栈来计算 calculate_stack = [] # 后缀遍历 for element in expressions_result: # 若是数字则入栈, 操作符则将栈顶两个元素出栈 if element not in operators: calculate_stack.append(element) else: # 操作数 num1 = calculate_stack.pop() # 操作数 num2 = calculate_stack.pop() # 除数不能为0 if num1 == &quot;0&quot; and element == '÷': return [False, []] # 结果 result = self.operate(num2, num1, element) if result.denominator == 0 or '-' in result.to_string(): return [False, []] stage_results.append(result.to_string()) # 结果入栈 calculate_stack.append(result) # 返回结果 return [calculate_stack[0], stage_results] 四、实际测试 通过命令行控制python ArithmeticCLMode.py [args|args][args]├─ -h –help # 输出帮助信息├─ -n # 指定生成表达式数量，默认100├─ -r # 指定生成表达式各个数字的取值范围，默认100├─ -a # 需和-e参数共同使用进行批改，指定答案文件├─ -e # 需和-a参数共同使用进行批改，指定练习文件└─ -g # 开启GUI 通过gui控制 python ArithmeticGMode.py 执行代码1python ArithmeticCLMode.py -n 100 -r 100 12# 将上述执行生成的 Exercise.txt 中的1~10题的答案改为错误 执行python ArithmeticCLMode.py -e ./docs/Exercise.txt -a ./docs/Answer.txt 五、效能分析 由Pycharm测试输出性能测试 程序耗时在多线程中的 生成表达式及计算, 以及I/O操作 在值域1000的情况下各生成不同数量级四则运算的耗时测试 六、PSP表格 🚩 PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟） Planning 计划 30 10 · Estimate · 估计这个任务需要多少时间 30 10 Development 开发 1055 1480 · Analysis · 需求分析 (包括学习新技术) 120 335 · Design Spec · 生成设计文档 60 35 · Design Review · 设计复审 (和同事审核设计文档) 5 5 · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 10 5 · Design · 具体设计 200 120 · Coding · 具体编码 600 580 · Code Review · 代码复审 30 120 · Test · 测试（自我测试，修改代码，提交修改） 30 150 Reporting 报告 85 130 · Test Report · 测试报告 60 30 · Size Measurement · 计算工作量 10 10 · Postmortem &amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 15 90 合计 1170 1620 七、总结 🚀 优点： 在此次项目合作中，我们通过 “Notion” 这一个软件完成设计我们的 开发流程、工作分配以及我们的代码规范的设计。我们将需求列出，根据难度不同从而安排开发流程，每个人根据自己能力特出点不同而去做不同的需求，再通过交流约定我们每个人的接口。简化开发流程。 交流和配合都挺顺畅的 不足： 开发中各个模块的依赖关系在开发任务中没有处理清楚，导致双方都有空窗期 互评 ❤💛💙 To 郑靓能力强，效率高，非常积极主动。能根据自己日常使用的工具提高效率，在实际开发中有明确的开发流程思路，开发过程中有部分函数代码注释思路不清。 To 张鹏配合和交流能力强，效率高，能主动揽接任务，思维挺好的，但比较被动","link":"/2020/07/29/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%94%9F%E6%88%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F-Python/"},{"title":"WordCount (Python)","text":"WordCount (Python)Github项目地址：https://github.com/w1036933220/WordCount 一、解题思路 把项目需求理清楚，画一个思维导图 考虑各部分功能所需要的大概实现思路 然后完成了计算文件属性的算法部分 再回头想对指令的解析问题，顺带添加了递归处理多个文件的功能 查python的os库文档，最后决定用os.walk读取当前文件夹内的所有文件夹和文件，替换掉输入的*和?通配符，再进行匹配 三、设计实现过程及代码说明 main.py（入口文件） 123456from utils.utils import *if __name__ == '__main__': command = input(&quot;请输入命令(wc.exe [parameter] {file_name}):\\n&quot;)parse_command(command) orders.py 存放指令集，和输出各类数据的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from utils.count import *from views.main_view import *import tkinter as tk# 输出字符数def print_char_num(text): print(&quot;字符数：&quot; + str(FileProperties(text).count_char_num()))# 输出单词数def print_word_num(text): print(&quot;词数：&quot; + str(FileProperties(text).count_word_num()))# 输出行数def print_line_num(text): print(&quot;行数：&quot; + str(FileProperties(text).count_line_num()))# 输出代码行/空行/注释行def print_code_property(text): file_properties = FileProperties(text) print(&quot;空行：&quot; + str(file_properties.count_null_line_num())) print(&quot;注释行：&quot; + str(file_properties.count_annotation_line_num())) print(&quot;代码行：&quot; + str(file_properties.count_code_line_num()))# 调出图形界面def draw_view(): root = MainView(tk.Tk())def print_error(): print(&quot;指令输入错误&quot;)# 单指令命令集orders = { '-c': print_char_num, '-w': print_word_num, &quot;-l&quot;: print_line_num, &quot;-a&quot;: print_code_property, &quot;-s&quot;: print_error, &quot;-x&quot;: draw_view} utils.py 放置解析指令、读取文件、模糊搜素的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import osfrom utils.orders import *# description：parse command# param：order input# return：[order, [file_list]] / FALSEdef parse_command(command): command = command.strip().split(&quot; &quot;) # 指令若为空或者起始不为wc.exe则报错 if command == [] or command[0] != &quot;wc.exe&quot;: print(&quot;指令输入错误&quot;) # 打开图形界面的指令(一级指令) if &quot;-x&quot; in command: orders.get(&quot;-x&quot;) elif len(command) &gt; 2: order = command[-2] file_name = command[-1] file_list = get_file_list(file_name) # 递归调用的指令 if &quot;-s&quot; in command: if file_list: for file in file_list: print(file + &quot;:&quot;) text = read_file(file) orders.get(order)(text) else: print(file_list[0] + &quot;:&quot;) text = read_file(file_name) orders.get(order)(text) else: print(&quot;指令输入错误&quot;)# 读取目录下符合条件的文件名def get_file_list(file_name): # 最终构建的文件列表 file_list = [] # 匹配到的文件夹列表、需二次处理 dir_list = [] file_name = file_name.replace(&quot;?&quot;, &quot;\\\\S&quot;).replace(&quot;*&quot;, &quot;\\\\S+&quot;) file_name += &quot;$&quot; for root, dirs, files in os.walk(&quot;.&quot;, topdown=False): for name in files: if re.match(file_name, name): file_list.append(os.path.join(root, name)) for name in dirs: if re.match(file_name, name): dir_list.append(os.path.join(os.getcwd() + os.sep, name)) # 如果文件夹非空，则继续收集 if dir_list: for item in dir_list: all_file = os.listdir(item) for file in all_file: # 文件的完整路径 file_path = item + os.sep + file if os.path.isfile(file_path): file_list.append(file_path) print(file_list) return file_list# description：read files# param：file_list# return：file contentdef read_file(file): with open(file, 'r') as f: return f.readlines() count.py 存放计算文件属性的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import reclass FileProperties(object): def __init__(self, file_text): self.file_text = file_text # 字符数 self.char_num = 0 # 单词数 self.word_num = 0 # 行数 self.line_num = len(file_text) # 空行 self.null_line_num = 0 # 代码行 self.code_line_num = 0 # 注释行数 self.annotation_line_num = 0 # 计算字符数 def count_char_num(self): for line in self.file_text: self.char_num += len(line.strip()) return self.char_num # 计算单词数 def count_word_num(self): for line in self.file_text: # 正则匹配一行中的所有单词，并计算单词数 self.word_num += len(re.findall(r'[a-zA-Z0-9]+[\\-\\']?[a-zA-Z]*', line)) return self.word_num # 计算行数 def count_line_num(self): return self.line_num # 计算空行数 def count_null_line_num(self): for line in self.file_text: # 只有不超过一个可显示的字符 if len(re.findall(r'\\S', line)) &lt;= 1: self.null_line_num += 1 return self.null_line_num # 计算代码行 def count_code_line_num(self): return self.line_num - self.null_line_num - self.annotation_line_num # 计算注释行 def count_annotation_line_num(self): flag = 0 for line in self.file_text: line = line.strip() # 匹配不是代码行且有// if re.match(r'^\\S?\\s*?\\/\\/', line): self.annotation_line_num += 1 # 匹配不是代码行且有/* elif re.match(r'^\\S?\\s*?\\/\\*', line): flag = 1 self.annotation_line_num += 1 if line.endswith('*/'): flag = 0 elif flag == 1: self.annotation_line_num += 1 elif &quot;*/&quot; in line: self.annotation_line_num += 1 flag = 0 return self.annotation_line_num 5.main_view.py(新增) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import tkinter as tkfrom tkinter import ttkimport tkinter.filedialogfrom utils.utils import *from utils.count import *class MainView(object): def __init__(self, window): self.window = window self.window.title(&quot;这是船新的版本！&quot;) self.window.geometry(&quot;540x290&quot;) self.data_tree = ttk.Treeview(self.window, show=&quot;headings&quot;) self.creat_view() def creat_view(self): # 选择文件按钮 btn = tk.Button(self.window, text=&quot;选择文件&quot;, command=self.file_choose).place(x=240, y=247) # 文件数据显示表格 self.data_tree.place(x=8, y=8) # 定义列 self.data_tree[&quot;columns&quot;] = (&quot;文件名&quot;, &quot;字符数&quot;, &quot;单词数&quot;, &quot;行数&quot;, &quot;空行数&quot;, &quot;代码行数&quot;, &quot;注释行数&quot;) # 设置列属性，列不显示 self.data_tree.column(&quot;文件名&quot;, width=100) self.data_tree.column(&quot;字符数&quot;, width=70) self.data_tree.column(&quot;单词数&quot;, width=70) self.data_tree.column(&quot;行数&quot;, width=70) self.data_tree.column(&quot;空行数&quot;, width=70) self.data_tree.column(&quot;代码行数&quot;, width=70) self.data_tree.column(&quot;注释行数&quot;, width=70) # 设置表头 self.data_tree.heading(&quot;文件名&quot;, text=&quot;文件名&quot;) self.data_tree.heading(&quot;字符数&quot;, text=&quot;字符数&quot;) self.data_tree.heading(&quot;单词数&quot;, text=&quot;单词数&quot;) self.data_tree.heading(&quot;行数&quot;, text=&quot;行数&quot;) self.data_tree.heading(&quot;空行数&quot;, text=&quot;空行数&quot;) self.data_tree.heading(&quot;代码行数&quot;, text=&quot;代码行数&quot;) self.data_tree.heading(&quot;注释行数&quot;, text=&quot;注释行数&quot;) self.window.mainloop() def file_choose(self): file_list = tk.filedialog.askopenfilenames() for index, file in enumerate(file_list): text = read_file(file) [char_num, word_num, line_num, null_line_num, code_line_num, annotation_line_num] = FileProperties(text).all_count() file = file.split(&quot;/&quot;)[-1] self.data_tree.insert('', index, values=(file, char_num, word_num, line_num, null_line_num, code_line_num, annotation_line_num)) 五、PSP表格 PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟） Planning 计划 10 8 · Estimate · 估计这个任务需要多少时间 10 8 Development 开发 460 610 · Analysis · 需求分析 (包括学习新技术) 120 200 · Design Spec · 生成设计文档 90 60 · Design Review · 设计复审 (和同事审核设计文档) 5 5 · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 5 0 · Design · 具体设计 120 100 · Coding · 具体编码 90 200 · Code Review · 代码复审 10 30 · Test · 测试（自我测试，修改代码，提交修改） 20 15 Reporting 报告 30 32 · Test Report · 测试报告 10 12 · Size Measurement · 计算工作量 10 5 · Postmortem &amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 10 8 合计 355 630 六、测试运行 图形界面测试（新增） 七、总结 太久没写python了，发现居然没有switch这个语句，百度查到了表驱动这个东西 用时与预计的出入有点大 输入验证处理没有做完全，图形界面没时间做了（过了大半年遗忘率确实高） 写的时候发现python有些问题不知道是bug还是什么 1234567orders = { '-c': print_char_num, '-w': print_word_num, &quot;-l&quot;: print_line_num, &quot;-a&quot;: print_code_property, &quot;-s&quot;: print_error,} 这是我的指令集，如果把他写成像js 12345orders = { '-c': function () { // 某些操作 },} python不管会不会用到这个指令集，都会把字典中的值执行一遍，所以只能放函数名，js就不会","link":"/2020/07/28/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/WordCount-Python/"},{"title":"仿网易云音乐的对话气泡框","text":"主要就是对话框小三角的实现，效果如下 主要难点就是三角形的实现，有两种思路，一种是利用border，网易云音乐是用两个 ◆ 层叠显示边框的，下面是核心代码 html12345678&lt;div class=&quot;comment&quot;&gt; &lt;span class=&quot;darr&quot;&gt; &lt;i class=&quot;bd&quot;&gt;◆&lt;/i&gt; &lt;i class=&quot;bg&quot;&gt;◆&lt;/i&gt; &lt;/span&gt; &lt;a href=&quot;#&quot;&gt;liang&lt;/a&gt; ：&lt;span&gt;嘤嘤嘤呀呀呀呀呀呀晕晕晕晕&lt;/span&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233.comment { position: relative; width: 200px; padding: 10px 15px; background-color: #f4f4f4; text-align: left; border: 1px solid #dedede;}.darr { position: absolute; top: -7px; left: 20px; font-size: 15px; line-height: 14px;}i { font-style: normal; position: absolute; top: 0; left: 0;}.bg { color: #f4f4f4; top: 1px;}// 边框.bd { color: #dedede;}","link":"/2020/07/17/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AF%B9%E8%AF%9D%E6%B0%94%E6%B3%A1%E6%A1%86/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Less","slug":"Less","link":"/tags/Less/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"ts","slug":"ts","link":"/tags/ts/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"前端性能优化","slug":"前端性能优化","link":"/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"编译器配置","slug":"编译器配置","link":"/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"name":"egg.js","slug":"egg-js","link":"/tags/egg-js/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"微信网页","slug":"微信网页","link":"/tags/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5/"},{"name":"项目总结","slug":"项目总结","link":"/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}],"categories":[{"name":"大学课程","slug":"大学课程","link":"/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"源码解读","slug":"前端/源码解读","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"},{"name":"源码解读","slug":"后端/源码解读","link":"/categories/%E5%90%8E%E7%AB%AF/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"},{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"},{"name":"编译器配置","slug":"编译器配置","link":"/categories/%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"源码解读","slug":"源码解读","link":"/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"}]}