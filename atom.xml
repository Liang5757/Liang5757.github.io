<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liang的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liang5757.github.io/"/>
  <updated>2023-10-06T12:43:21.067Z</updated>
  <id>https://liang5757.github.io/</id>
  
  <author>
    <name>Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npm script</title>
    <link href="https://liang5757.github.io/2023/10/06/Js/npm-script/"/>
    <id>https://liang5757.github.io/2023/10/06/Js/npm-script/</id>
    <published>2023-10-06T11:27:17.000Z</published>
    <updated>2023-10-06T12:43:21.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="串行-or-并行"><a href="#串行-or-并行" class="headerlink" title="串行 or 并行"></a>串行 or 并行</h2><p>并行跑命令：&amp;，在命令结尾加<code>&amp; wait</code>，可以使用ctrl c关闭命令行来结束进程<br>串行跑命令：&amp;&amp;</p><h2 id="控制日志输出"><a href="#控制日志输出" class="headerlink" title="控制日志输出"></a>控制日志输出</h2><ul><li>–silent（-s）：输出尽可能少的日志</li><li>–verbose：显示尽可能多的状态，日志级别的输出，用于调试</li></ul><a id="more"></a><h2 id="npm自动补全"><a href="#npm自动补全" class="headerlink" title="npm自动补全"></a>npm自动补全</h2><blockquote><p>不支持workspace的仓库</p></blockquote><p>npm官方支持补全：<a href="https://docs.npmjs.com/cli/v9/commands/npm-completion">npm-completion</a></p><p>第 1 步，把 npm completion 产生的命令放在单独的文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm completion &gt;&gt; ~/.npm-completion.bash</span><br></pre></td></tr></table></figure><p>第 2 步，在 .bashrc 或者 .zshrc 中引入这个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>最后执行 <code>source ~/.zshrc</code> 或者 <code>source ~/.bashrc</code>，来让自动完成生效。</p><p>使用补全方式：尝试在命令行中输入 npm run，<strong>然后键入空格（空格很重要）</strong>，然后键入 tab 键</p><h2 id="一些跨平台的第三方库"><a href="#一些跨平台的第三方库" class="headerlink" title="一些跨平台的第三方库"></a>一些跨平台的第三方库</h2><ul><li><a href="https://github.com/isaacs/rimraf">rimraf</a> 或 <a href="https://www.npmjs.com/package/del-cli">del-cli</a>，用来删除文件和目录，实现类似于 <code>rm -rf</code> 的功能；</li><li><a href="https://www.npmjs.com/package/cpr">cpr</a>，用于拷贝、复制文件和目录，实现类似于 <code>cp -r</code> 的功能；</li><li><a href="https://www.npmjs.com/package/make-dir-cli">make-dir-cli</a>，用于创建目录，实现类似于 <code>mkdir -p</code> 的功能；</li></ul><h3 id="跨平台的引用变量"><a href="#跨平台的引用变量" class="headerlink" title="跨平台的引用变量"></a>跨平台的引用变量</h3><p>Linux 下直接可以用 <code>$npm_package_name</code>，而 Windows 下必须使用 <code>%npm_package_name%</code>，我们可以使用 <a href="https://www.npmjs.com/package/cross-var">cross-var</a> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cross-var -D</span><br></pre></td></tr></table></figure><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">-    <span class="string">&quot;cover:open&quot;</span>: <span class="string">&quot;opn http://localhost:<span class="variable">$npm_package_config_port</span>&quot;</span>,</span><br><span class="line">+    <span class="string">&quot;cover:open&quot;</span>: <span class="string">&quot;cross-var opn http://localhost:<span class="variable">$npm_package_config_port</span>&quot;</span>,</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>引入 cross-var 之后，它竟然给我们安装了 babel，如果想保持依赖更轻量的话，可以考虑使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fcross-var-no-babel">cross-var-no-babel</a></p><h3 id="跨平台的环境变量"><a href="#跨平台的环境变量" class="headerlink" title="跨平台的环境变量"></a>跨平台的环境变量</h3><p>因为不同平台的环境变量语法不同，我们可以使用 <a href="https://www.npmjs.com/package/cross-env">cross-env</a> 来实现 npm script 的跨平台兼容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cross-env -D</span><br></pre></td></tr></table></figure><h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">-    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;NODE_ENV=test mocha tests/&quot;</span>,</span><br><span class="line">+    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=test mocha tests/&quot;</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="抽离script到单独文件"><a href="#抽离script到单独文件" class="headerlink" title="抽离script到单独文件"></a>抽离script到单独文件</h2><p>当 npm script 不断累积、膨胀的时候，全部放在 package.json 里面可能并不是个好主意，因为这样会导致 package.json 糟乱，可读性降低。</p><p>借助 <a href="https://github.com/testdouble/scripty">scripty</a> 我们可以将 npm script 剥离到单独的文件中，从而把复杂性隔到单独的模块里面，让代码整体看起来更加清晰。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i scripty -D</span><br></pre></td></tr></table></figure><h3 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h3><p>执行<code>npm run foo:bar</code>会向<code>scripts/foo/bar</code>寻找可执行脚本并执行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;foo:bar&quot;</span>: <span class="string">&quot;scripty&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><p>npm script 的设计者为命令的执行增加了类似生命周期的机制，具体来说就是 <code>pre</code> 和 <code>post</code> 钩子脚本</p><p>举例来说，运行 npm run test 的时候，分 3 个阶段：</p><ol><li>检查 scripts 对象中是否存在 pretest 命令，如果有，先执行该命令；</li><li>检查是否有 test 命令，有的话运行 test 命令，没有的话报错；</li><li>检查是否存在 posttest 命令，如果有，执行 posttest 命令；</li></ol><h2 id="在-Git-Hooks-中执行-npm-script"><a href="#在-Git-Hooks-中执行-npm-script" class="headerlink" title="在 Git Hooks 中执行 npm script"></a>在 Git Hooks 中执行 npm script</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D husky</span><br></pre></td></tr></table></figure><p>在package.json增加</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;precommit&quot;</span>: <span class="string">&quot;eslint src/**/*.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会检查到项目中所有的lint错误，如何只检查提交的文件呢？</p><p>需要用到<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fokonet%2Flint-staged">lint-staged</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D lint-staged</span><br></pre></td></tr></table></figure><p>package.json改为如下，就可以只lint提交的文件啦</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;precommit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;src/**/*.js&quot;</span>: <span class="string">&quot;eslint&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844903479283040269">用 husky 和 lint-staged 构建超溜的代码检查工作流</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;串行-or-并行&quot;&gt;&lt;a href=&quot;#串行-or-并行&quot; class=&quot;headerlink&quot; title=&quot;串行 or 并行&quot;&gt;&lt;/a&gt;串行 or 并行&lt;/h2&gt;&lt;p&gt;并行跑命令：&amp;amp;，在命令结尾加&lt;code&gt;&amp;amp; wait&lt;/code&gt;，可以使用ctrl c关闭命令行来结束进程&lt;br&gt;串行跑命令：&amp;amp;&amp;amp;&lt;/p&gt;
&lt;h2 id=&quot;控制日志输出&quot;&gt;&lt;a href=&quot;#控制日志输出&quot; class=&quot;headerlink&quot; title=&quot;控制日志输出&quot;&gt;&lt;/a&gt;控制日志输出&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;–silent（-s）：输出尽可能少的日志&lt;/li&gt;
&lt;li&gt;–verbose：显示尽可能多的状态，日志级别的输出，用于调试&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vueuse源码解读</title>
    <link href="https://liang5757.github.io/2023/09/10/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vueuse%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://liang5757.github.io/2023/09/10/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Vueuse%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2023-09-10T08:53:55.000Z</published>
    <updated>2023-09-10T08:54:37.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文不会放api的用法，建议先看看是怎么用的</p><p>写本篇文章时间间隔较长，所以代码版本不一</p></blockquote><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>采用monorepo的形式，项目目录下有多个子项目，下面放了资料链接和几处用法，其他本文不多赘述。</p><p><a href="https://juejin.cn/post/6944877410827370504">现代前端工程为什么越来越离不开 Monorepo?</a><br><a href="https://www.codeleading.com/article/46915806308/">为什么使用pnpm可以光速建立好用的monorepo（比yarn/lerna效率高）</a><br><a href="https://pnpm.io/zh/workspaces">pnpm workspace文档</a></p><a id="more"></a><p>为了使<strong>所有子项目都使用同一个依赖版本</strong>，使用<a href="https://pnpm.io/zh/package_json#pnpmoverrides">pnpm.overrides</a>配置，如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;pnpm&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;vue-demi&quot;</span>: <span class="string">&quot;0.12.1&quot;</span>, <span class="comment">// 在postinstall钩子中根据当前环境的vue版本，获取兼容vue3和vue2的api</span></span><br><span class="line">      <span class="attr">&quot;vite&quot;</span>: <span class="string">&quot;^2.6.7&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常配置下，如果直接<code>pnpm install</code>将会在每个子项目的<code>node_modules</code>有同样的依赖，但是所有子项目相同的依赖其实只需要提取出来放在根目录的<code>node_modules</code>下即可，可配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;@vue/composition-api&quot;</span>: <span class="string">&quot;^1.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.0 || ^3.2.0&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>详情请看如下链接</p><p><a href="https://www.cnblogs.com/wonyun/p/9692476.html">探讨npm依赖管理之peerDependencies</a><br><a href="https://blog.csdn.net/qq_21567385/article/details/121088506">pnpm monorepo之多组件实例和peerDependencies困境回溯</a><br><a href="https://pnpm.io/zh/how-peers-are-resolved">如何处理 peers</a></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="unref-ref的反操作"><a href="#unref-ref的反操作" class="headerlink" title="unref - ref的反操作"></a>unref - ref的反操作</h3><ul><li>如果传入一个ref，返回其值</li><li>否则原样放回</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unref</span>&lt;<span class="title">T</span>&gt;(<span class="params">ref: T | Ref&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isRef(ref) ? ref.value : ref</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用例子：实现一个响应式的add函数，可以传入<strong>ref或值</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a: Ref&lt;<span class="built_in">number</span>&gt; | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  b: Ref&lt;<span class="built_in">number</span>&gt; | <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function">() =&gt;</span> unref(a) + unref(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MaybeRef类型"><a href="#MaybeRef类型" class="headerlink" title="MaybeRef类型"></a>MaybeRef类型</h3><p>vueuse大量使用<code>MaybeRef</code>来支持<strong>可选择性的响应式参数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T</span><br></pre></td></tr></table></figure><p>上面的加法函数就可以简写为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: MaybeRef&lt;<span class="built_in">number</span>&gt;, b: MaybeRef&lt;<span class="built_in">number</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function">() =&gt;</span> unref(a) + unref(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Effect作用域API"><a href="#Effect作用域API" class="headerlink" title="Effect作用域API"></a>Effect作用域API</h3><p>Vue官方文档：<a href="https://v3.cn.vuejs.org/api/effect-scope.html#effectscope">Effect 作用域 API</a></p><p><strong>动机</strong></p><p>在Vue的setup中，响应式effect会在初始化的时候被收集，在实例被卸载的时候，响应式effect就会自动被取消了，但是在我们在组件外写一个独立的包（就如vueuse）时，我们该如何取消computed &amp; watch的响应式依赖呢？vue3.2提出了<code>effectScope</code>，接下来介绍相关的api</p><h4 id="effectScope"><a href="#effectScope" class="headerlink" title="effectScope"></a>effectScope</h4><p>利用<code>effectScope</code>创建一个作用域对象，如下面接口定义所示，<code>run</code>接受一个函数，这个作用域对象会自动捕获函数内部的响应式effect (例如计算属性或侦听器)</p><p><strong>类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effectScope</span>(<span class="params">detached?: <span class="built_in">boolean</span></span>): <span class="title">EffectScope</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">EffectScope</span> </span>&#123;</span><br><span class="line">  run&lt;T&gt;(fn: <span class="function">() =&gt;</span> T): T | <span class="literal">undefined</span> <span class="comment">// 如果这个域不活跃则为 undefined</span></span><br><span class="line">  stop(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = effectScope()</span><br><span class="line"></span><br><span class="line">scope.run(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> doubled = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line">  watch(doubled, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(doubled.value))</span><br><span class="line">  watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Count: &#x27;</span>, doubled.value))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢弃(dispose) 该作用域内的所有 effect</span></span><br><span class="line">scope.stop()</span><br></pre></td></tr></table></figure><h4 id="getCurrentScope"><a href="#getCurrentScope" class="headerlink" title="getCurrentScope"></a>getCurrentScope</h4><p>如果有，则返回当前活跃的 <a href="https://v3.cn.vuejs.org/api/effect-scope.html#effectscope">effect 作用域</a>。</p><p><strong>类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentScope</span>(<span class="params"></span>): <span class="title">EffectScope</span> | <span class="title">undefined</span> </span></span><br></pre></td></tr></table></figure><h4 id="onScopeDispose"><a href="#onScopeDispose" class="headerlink" title="onScopeDispose"></a>onScopeDispose</h4><p>在当前活跃的 <a href="https://v3.cn.vuejs.org/api/effect-scope.html#effectscope">effect 作用域</a>上注册一个处理回调。该回调会在相关的 effect 作用域结束之后被调用，在VCA（Vue Composition API）函数中可用作<code>onUnmounted</code>的非组件替代品，区别在于其工作在scope中而不是组件实例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前 effectScope 结束后调用</span></span><br><span class="line">onScopeDispose(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, handler)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么如此抽象的<code>effectScope</code>在尤大降低心智负担的主张下为什么要被提出呢，下面列了个官方rfc中的例子</p><p><strong>示例</strong></p><p>在vue的rfc中<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md">reactivity-effect-scope</a>有这样的一个例子，如果有个监控鼠标位置的hook（useMouse），需要监听<code>mousemove</code>事件，如果在多个组件调用了这个hook，而内部是通过在<code>onUnmounted</code>钩子来移除<code>mousemove</code>监听器，<code>onUnmounted</code>耦合在每个组件实例，则无法以更有效率的方式共享这个<code>mousemove</code>监听器（即）</p><p>为了做到在组件间共享<code>useMouse</code>的响应式effect和监听器，可以创建一个函数来管理scope如下（这个hook也在vueuse中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSharedComposable</span>(<span class="params">composable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> subscribers = <span class="number">0</span> <span class="comment">// 订阅计数器，每次调用subscribers + 1</span></span><br><span class="line">  <span class="keyword">let</span> state, scope</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scope &amp;&amp; --subscribers &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">      scope.stop()</span><br><span class="line">      state = scope = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    subscribers++</span><br><span class="line">    <span class="keyword">if</span> (!state) &#123; <span class="comment">// 只在第一次创建effectScope</span></span><br><span class="line">      scope = effectScope(<span class="literal">true</span>) <span class="comment">// true为独立的scope作用域</span></span><br><span class="line">      state = scope.run(<span class="function">() =&gt;</span> composable(...args))</span><br><span class="line">    &#125;</span><br><span class="line">    onScopeDispose(dispose) <span class="comment">// 在当前活跃的effect作用域上注册一个回调</span></span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到dispose函数的含义是，当<strong>没有一个组件在使用</strong>它的时候会注销(dispose)创建的<code>effectScope</code>，我们只需要如下操作，即可得到一个<strong>在所有组件共享</strong>的<code>useMouse</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useSharedMouse = createSharedComposable(useMouse)</span><br></pre></td></tr></table></figure><p>更加详细的关于<code>effectScope</code>的讨论在<a href="https://github.com/vuejs/rfcs/pull/212">Reactivity’s <code>effectScope</code> API #212</a></p><p>本来是打算<strong>完全</strong>按照官网的分类进行解读，但是由于VCA（Vue Composition API）的思想，hook被拆的很碎再组合在一起，并不能单纯靠分类进行解读，所以在讲某个分类的hook时也会带上其他的hooks，接下来是对我觉得 常用 或者 有学习到东西 的hook源码进行解读 </p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="createGlobalState"><a href="#createGlobalState" class="headerlink" title="createGlobalState"></a>createGlobalState</h3><blockquote><p>用来做挂组件公共状态管理</p></blockquote><p>简单的单例模式实现，<code>effectScope</code>的参数为true时，其不会被父scope收集和回收，独立存在</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createGlobalState</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  stateFactory: () =&gt; T,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">CreateGlobalStateReturn</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> initialized = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> state: T</span><br><span class="line">  <span class="keyword">const</span> scope = effectScope(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">      state = scope.run(stateFactory)!</span><br><span class="line">      initialized = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useLocalStorage"><a href="#useLocalStorage" class="headerlink" title="useLocalStorage"></a>useLocalStorage</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLocalStorage</span>&lt;<span class="title">T</span> <span class="title">extends</span>(<span class="params"><span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">boolean</span>|<span class="built_in">object</span>|<span class="literal">null</span></span>)&gt; (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialValue: MaybeRef&lt;T&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  options: StorageOptions&lt;T&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">RemovableRef</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="built_in">window</span> = defaultWindow &#125; = options</span><br><span class="line">  <span class="keyword">return</span> useStorage(key, initialValue, <span class="built_in">window</span>?.localStorage, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是用<code>useStorage</code>来实现的，<code>useSessionStorage</code>也是一样，下面我们来看看<code>useStorage</code></p><h3 id="useStorage"><a href="#useStorage" class="headerlink" title="useStorage"></a>useStorage</h3><p>在浏览器默认的Storage之上像<a href="https://github.com/marcuswestin/store.js">store.js</a>一样对数据进行预处理（序列化），否则如果存一个对象在浏览器的Storage存的会是<code>xxx.toString()</code>之后的值。但是<code>useStorage</code>比起<a href="https://github.com/marcuswestin/store.js">store.js</a>更进一步的增加了对<code>Map</code>和<code>Set</code>类型的数据的处理（<strong><code>Map</code>和<code>Set</code>存在默认的Storage和store.js都是空对象</strong>）</p><p>利用适配器模式，对每种数据类型定义<code>read</code>、<code>write</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StorageSerializers: Record&lt;<span class="string">&#x27;boolean&#x27;</span> | <span class="string">&#x27;object&#x27;</span> | <span class="string">&#x27;number&#x27;</span> | <span class="string">&#x27;any&#x27;</span> | <span class="string">&#x27;string&#x27;</span> | <span class="string">&#x27;map&#x27;</span> | <span class="string">&#x27;set&#x27;</span>, Serializer&lt;<span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  <span class="attr">boolean</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> v === <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">object</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.parse(v),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.stringify(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">number</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">Number</span>.parseFloat(v),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">any</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> v,</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">string</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> v,</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">map</span>: &#123; <span class="comment">// map序列化</span></span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(v)),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">Array</span>.from((v <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;).entries())),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: &#123; <span class="comment">// set序列化</span></span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">JSON</span>.parse(v)),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">Array</span>.from((v <span class="keyword">as</span> <span class="built_in">Set</span>&lt;<span class="built_in">any</span>&gt;).entries())),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来判断用户传入的数据类型，进行选择对应的<code>read</code>、<code>write</code>方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">guessSerializerType</span>&lt;<span class="title">T</span> <span class="title">extends</span>(<span class="params"><span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> | <span class="built_in">object</span> | <span class="literal">null</span></span>)&gt;(<span class="params">rawInit: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rawInit == <span class="literal">null</span></span><br><span class="line">    ? <span class="string">&#x27;any&#x27;</span></span><br><span class="line">    : rawInit <span class="keyword">instanceof</span> <span class="built_in">Set</span></span><br><span class="line">      ? <span class="string">&#x27;set&#x27;</span></span><br><span class="line">      : rawInit <span class="keyword">instanceof</span> <span class="built_in">Map</span></span><br><span class="line">        ? <span class="string">&#x27;map&#x27;</span></span><br><span class="line">        : rawInit <span class="keyword">instanceof</span> <span class="built_in">Date</span></span><br><span class="line">          ? <span class="string">&#x27;date&#x27;</span></span><br><span class="line">          : <span class="keyword">typeof</span> rawInit === <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">            ? <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">            : <span class="keyword">typeof</span> rawInit === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">              ? <span class="string">&#x27;string&#x27;</span></span><br><span class="line">              : <span class="keyword">typeof</span> rawInit === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">                ? <span class="string">&#x27;object&#x27;</span></span><br><span class="line">                : !<span class="built_in">Number</span>.isNaN(rawInit)</span><br><span class="line">                    ? <span class="string">&#x27;number&#x27;</span></span><br><span class="line">                    : <span class="string">&#x27;any&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">type</span> = guessSerializerType&lt;T&gt;(rawInit)</span><br><span class="line"><span class="keyword">const</span> serializer = options.serializer ?? StorageSerializers[<span class="keyword">type</span>] <span class="comment">// 用户还可以定义自己的序列化方法，但必须具有read和write方法</span></span><br></pre></td></tr></table></figure><p>下面是对数据的初始化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rawInit: T = unref(initialValue) <span class="comment">// 用户传入的初始值</span></span><br><span class="line"><span class="keyword">const</span> data = (shallow ? shallowRef : ref)(initialValue) <span class="keyword">as</span> Ref&lt;T&gt; <span class="comment">// 用户可以配置是浅响应式还是深，最后会返回给用户</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!storage)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> rawValue = storage.getItem(key)</span><br><span class="line">    <span class="keyword">if</span> (rawValue == <span class="literal">null</span>) &#123; <span class="comment">// 如果key对应的值为空，那么是首次</span></span><br><span class="line">        data.value = rawInit <span class="comment">// 初始化值</span></span><br><span class="line">        <span class="keyword">if</span> (writeDefaults &amp;&amp; rawInit !== <span class="literal">null</span>) <span class="comment">// 用户可配置（writeDefaults）是否首次存入Storage</span></span><br><span class="line">            storage.setItem(key, serializer.write(rawInit))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        data.value = serializer.read(rawValue) <span class="comment">// 如果Storage存在对应值，序列化读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    onError(e) <span class="comment">// 用户传入的错误处理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<strong>根据监听data的变化存入Storage</strong>，<code>watchWithFilter</code>可以看做是新增了<code>eventFilter</code>选项的<code>watch</code>，在后文会描述，也是vueuse很重要的一个特性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">watchWithFilter(</span><br><span class="line">    data,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.value == <span class="literal">null</span>)</span><br><span class="line">                storage.removeItem(key)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                storage.setItem(key, serializer.write(data.value))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            onError(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        flush, <span class="comment">// 均是用户可配置的选项</span></span><br><span class="line">        deep,</span><br><span class="line">        eventFilter,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>是不是觉得很OK了，但仍有巨隐蔽的bug（哈哈哈)，为了支持响应式的存取Storage，用了ref类型的data，<strong>在同源下的多个标签的情况下，其中一个页面对另一个页面用<code>useStorage</code>修改了数据，但另一个页面useStorage内部的data还是原来的值</strong></p><p>解决方式：监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/StorageEvent">storage</a>事件（当页面使用的storage被其他页面修改时会触发）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">event?: StorageEvent</span>) </span>&#123; <span class="comment">// 将上面初始化值的逻辑封装为read函数</span></span><br><span class="line">    <span class="keyword">if</span> (!storage || (event &amp;&amp; event.key !== key))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rawValue = event ? event.newValue : storage.getItem(key)</span><br><span class="line"><span class="comment">// 读值省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        onError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span> &amp;&amp; listenToStorageChanges) <span class="comment">// 用户也可以配置（listenToStorageChanges）不监听</span></span><br><span class="line">    useEventListener(<span class="built_in">window</span>, <span class="string">&#x27;storage&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> read(e), <span class="number">0</span>)) <span class="comment">// 重新读取值给data</span></span><br></pre></td></tr></table></figure><h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><blockquote><p>浏览器相关的hook，基于web暴露的api来实现</p></blockquote><h3 id="可配置全局对象"><a href="#可配置全局对象" class="headerlink" title="可配置全局对象"></a>可配置全局对象</h3><p>Browser hook的源码开头都有或类似下面这一段</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> defaultWindow = <span class="comment">/* #__PURE__ */</span> isClient ? <span class="built_in">window</span> : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useXXX</span>&lt;<span class="title">T</span>&gt;(<span class="params">options: ConfigurableWindow = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="built_in">window</span> = defaultWindow &#125; = options</span><br><span class="line">  <span class="built_in">window</span>.xxx</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以配置当前window对象，这种配置方式对于使用<strong>iframe</strong>和<strong>测试环境</strong>不同的window对象十分有用</p><h3 id="useEventListener"><a href="#useEventListener" class="headerlink" title="useEventListener"></a>useEventListener</h3><p>先上一个简易版本的<code>useEventListener</code>，利用VCA，将事件的监听和注销放在一个函数中处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEventListener</span> (<span class="params">target, listener, options, target = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    target.addEventListener(type, listener, options)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    target.removeEventListener(type, listener, options)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，源码还提供了当<code>target</code>的类型是<code>ref</code>时的情况，为了减少篇幅，下面的代码删减了参数为空的边界情况</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEventListener</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target: MaybeRef&lt;EventTarget&gt; | <span class="literal">undefined</span> = defaultWindow;</span><br><span class="line">  <span class="keyword">let</span> event: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">let</span> listener: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">let</span> options: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  [target, event, listener, options] = args</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cleanup = noop</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stopWatch = watch(</span><br><span class="line">    <span class="function">() =&gt;</span> unref(target),</span><br><span class="line">    <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">      cleanup()</span><br><span class="line">      <span class="keyword">if</span> (!el)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      el.addEventListener(event, listener, options)</span><br><span class="line"></span><br><span class="line">      cleanup = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        el.removeEventListener(event, listener, options)</span><br><span class="line">        cleanup = noop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">flush</span>: <span class="string">&#x27;post&#x27;</span> &#125;, <span class="comment">// 为什么flush是post？下面会讲解</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    stopWatch()</span><br><span class="line">    cleanup()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryOnScopeDispose(stop)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 还设计了返回stop函数，可以调用useEventListener返回的函数直接回收</span></span><br><span class="line">  <span class="keyword">return</span> stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么需要支持ref-target"><a href="#为什么需要支持ref-target" class="headerlink" title="为什么需要支持ref target"></a>为什么需要支持ref target</h4><p>用<code>unref</code>得到<code>ref</code>中的dom元素，监听dom元素的改变以重新监听事件，应用场景就放官网例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;cond&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;element&quot;</span>&gt;</span>Div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">ref</span>=<span class="string">&quot;element&quot;</span>&gt;</span>Div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEventListener &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = ref&lt;HTMLDivElement&gt;()</span><br><span class="line">useEventListener(element, <span class="string">&#x27;keydown&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(e.key) &#125;)</span><br></pre></td></tr></table></figure><h4 id="为什么需要watch设置flush为post"><a href="#为什么需要watch设置flush为post" class="headerlink" title="为什么需要watch设置flush为post"></a>为什么需要watch设置flush为post</h4><p>详情请看<a href="https://github.com/vueuse/vueuse/issues/356">#356 Bug: useEventListener doesn’t work correctly with v-if</a>，意思就是<a href="https://github.com/vuejs/vue-next/issues/1706#issuecomment-666258948%5C">新版vue</a>的<code>watch</code>默认在所有组件update前执行，那么ref没有更新导致事件没有更新，所以需要在组件update完毕后更新事件。</p><h4 id="tryOnScopeDispose是啥"><a href="#tryOnScopeDispose是啥" class="headerlink" title="tryOnScopeDispose是啥"></a>tryOnScopeDispose是啥</h4><p>先判断是否有活跃的effectScope，有的话用<code>onScopeDispose</code>在其上注册fn回调</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">tryOnScopeDispose</span>(<span class="params">fn: Fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getCurrentScope()) &#123;</span><br><span class="line">    onScopeDispose(fn)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v10.4.1更新：支持event传递数组，方便浏览器兼容事件</p><h3 id="useEyeDropper"><a href="#useEyeDropper" class="headerlink" title="useEyeDropper"></a>useEyeDropper</h3><p><code>new window.EyeDropper()</code>可以获取<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EyeDropper"><strong>取色器</strong></a>的功能</p><h3 id="usePreferredReducedMotion"><a href="#usePreferredReducedMotion" class="headerlink" title="usePreferredReducedMotion"></a>usePreferredReducedMotion</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion">prefers-reduced-motion</a>用于检测用户的系统是否被开启了动画减弱功能</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useMediaQuery(<span class="string">&#x27;(prefers-reduced-motion: reduce)&#x27;</span>, options)</span><br></pre></td></tr></table></figure><h3 id="usePreferredContrast"><a href="#usePreferredContrast" class="headerlink" title="usePreferredContrast"></a>usePreferredContrast</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast">prefers-contrast</a>判断用户喜欢何种对比度（more、less、custom）</p><h3 id="useMediaQuery"><a href="#useMediaQuery" class="headerlink" title="useMediaQuery"></a>useMediaQuery</h3><p><code>window.matchMedia(query)</code>返回<code>MediaQueryList</code>类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MediaQueryList <span class="keyword">extends</span> EventTarget &#123; <span class="comment">// 浏览器原生类型</span></span><br><span class="line">    <span class="keyword">readonly</span> matches: <span class="built_in">boolean</span>; <span class="comment">// 是否匹配</span></span><br><span class="line">    <span class="keyword">readonly</span> media: <span class="built_in">string</span>;    <span class="comment">// 媒体查询值</span></span><br><span class="line">    onchange: (<span class="function">(<span class="params"><span class="built_in">this</span>: MediaQueryList, ev: MediaQueryListEvent</span>) =&gt;</span> <span class="built_in">any</span>) | <span class="literal">null</span>; <span class="comment">// 媒体查询改变回调</span></span><br><span class="line"><span class="comment">// 事件绑定相关...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mql: MediaQueryList = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="usePermission"><a href="#usePermission" class="headerlink" title="usePermission"></a>usePermission</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/permissions">navigator.permissions</a>可以获取用户权限（摄像头、麦克风等）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = <span class="built_in">Boolean</span>(navigator &amp;&amp; <span class="string">&#x27;permissions&#x27;</span> <span class="keyword">in</span> navigator)</span><br><span class="line"><span class="keyword">const</span> state = ref&lt;PermissionState | <span class="literal">undefined</span>&gt;() <span class="comment">// 存权限状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (permissionStatus)</span><br><span class="line">        state.value = permissionStatus.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    permissionStatus = <span class="keyword">await</span> navigator!.permissions.query(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;camera&#x27;</span> <span class="comment">// https://w3c.github.io/permissions/#enumdef-permissionname</span></span><br><span class="line">    &#125;)</span><br><span class="line">    useEventListener(permissionStatus, <span class="string">&#x27;change&#x27;</span>, onChange) <span class="comment">// 有三个状态 denied&quot; | &quot;granted&quot; | &quot;prompt&quot;</span></span><br><span class="line">    onChange()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    state.value = <span class="string">&#x27;prompt&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="usePreferredLanguages"><a href="#usePreferredLanguages" class="headerlink" title="usePreferredLanguages"></a>usePreferredLanguages</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/languages">navigator.languages</a>可以获取用户的偏好语言，可以通过<code>languagechange</code>事件监听改变</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = ref&lt;<span class="keyword">readonly</span> <span class="built_in">string</span>[]&gt;(navigator.languages)</span><br><span class="line"></span><br><span class="line">useEventListener(<span class="built_in">window</span>, <span class="string">&#x27;languagechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    value.value = navigator.languages</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="useShare"><a href="#useShare" class="headerlink" title="useShare"></a>useShare</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/share">navigator.share</a>可以进行分享</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = navigator &amp;&amp; <span class="string">&#x27;canShare&#x27;</span> <span class="keyword">in</span> navigator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSupported) &#123;</span><br><span class="line">    granted = navigator.canShare(&#123; <span class="comment">// 判断是否能被分享</span></span><br><span class="line">        title?: <span class="built_in">string</span></span><br><span class="line">        files?: File[]</span><br><span class="line">        text?: <span class="built_in">string</span></span><br><span class="line">        url?: <span class="built_in">string</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (granted)</span><br><span class="line">        <span class="keyword">return</span> navigator.share!(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useWakeLock"><a href="#useWakeLock" class="headerlink" title="useWakeLock"></a>useWakeLock</h3><p> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API">Screen Wake Lock API</a>可以阻止设备变暗或锁屏</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = navigator &amp;&amp; <span class="string">&#x27;wakeLock&#x27;</span> <span class="keyword">in</span> navigator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"><span class="keyword">type</span>: WakeLockType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSupported) <span class="keyword">return</span></span><br><span class="line">    wakeLock = <span class="keyword">await</span> navigator.wakeLock.request(<span class="keyword">type</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">release</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSupported || !wakeLock) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">await</span> wakeLock.release() <span class="comment">// 释放WakeLockSentinel</span></span><br><span class="line">    wakeLock = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useVibrate"><a href="#useVibrate" class="headerlink" title="useVibrate"></a>useVibrate</h3><p> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API">Vibration API</a>可以使设备振动</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.vibrate([<span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>]); <span class="comment">// 设备振动 200 ms，然后暂停 100 ms，然后再次振动设备 200 ms</span></span><br><span class="line">navigator.vibrate(<span class="number">0</span>); <span class="comment">// 停止振动</span></span><br></pre></td></tr></table></figure><h3 id="useWebNotification"><a href="#useWebNotification" class="headerlink" title="useWebNotification"></a>useWebNotification</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/notification">Notification</a>可以给用户发送消息</p><h3 id="useFullscreen"><a href="#useFullscreen" class="headerlink" title="useFullscreen"></a>useFullscreen</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fullscreen_API">Fullscreen_API</a>用以控制全屏展示，虽然常见，但是看源码对兼容性有了多一层考虑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求全屏</span></span><br><span class="line"><span class="keyword">const</span> requestMethod = computed&lt;<span class="string">&#x27;requestFullscreen&#x27;</span> | <span class="literal">undefined</span>&gt;(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&#x27;requestFullscreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitRequestFullscreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitEnterFullscreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitEnterFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitRequestFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mozRequestFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;msRequestFullscreen&#x27;</span>,</span><br><span class="line">  ].find(<span class="function"><span class="params">m</span> =&gt;</span> (<span class="built_in">document</span> &amp;&amp; m <span class="keyword">in</span> <span class="built_in">document</span>) || (targetRef.value &amp;&amp; m <span class="keyword">in</span> targetRef.value)) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出全屏</span></span><br><span class="line"><span class="keyword">const</span> exitMethod = computed&lt;<span class="string">&#x27;exitFullscreen&#x27;</span> | <span class="literal">undefined</span>&gt;(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&#x27;exitFullscreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitExitFullscreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitExitFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitCancelFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mozCancelFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;msExitFullscreen&#x27;</span>,</span><br><span class="line">  ].find(<span class="function"><span class="params">m</span> =&gt;</span> (<span class="built_in">document</span> &amp;&amp; m <span class="keyword">in</span> <span class="built_in">document</span>) || (targetRef.value &amp;&amp; m <span class="keyword">in</span> targetRef.value)) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前是否处于全屏状态的判断</span></span><br><span class="line"><span class="keyword">const</span> fullscreenEnabled = computed&lt;<span class="string">&#x27;fullscreenEnabled&#x27;</span> | <span class="literal">undefined</span>&gt;(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&#x27;fullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitIsFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webkitDisplayingFullscreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mozFullScreen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;msFullscreenElement&#x27;</span>,</span><br><span class="line">  ].find(<span class="function"><span class="params">m</span> =&gt;</span> (<span class="built_in">document</span> &amp;&amp; m <span class="keyword">in</span> <span class="built_in">document</span>) || (targetRef.value &amp;&amp; m <span class="keyword">in</span> targetRef.value)) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前全屏元素的方法名</span></span><br><span class="line"><span class="keyword">const</span> fullscreenElementMethod = [</span><br><span class="line">  <span class="string">&#x27;fullscreenElement&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;webkitFullscreenElement&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;mozFullScreenElement&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;msFullscreenElement&#x27;</span>,</span><br><span class="line">].find(<span class="function"><span class="params">m</span> =&gt;</span> (<span class="built_in">document</span> &amp;&amp; m <span class="keyword">in</span> <span class="built_in">document</span>)) <span class="keyword">as</span> <span class="string">&#x27;fullscreenElement&#x27;</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用适配器的方式进行调用，<code>target[requestMethod.value]()</code></p><p>下面是不同浏览器监听全局变化的事件名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventHandlers = [</span><br><span class="line">  <span class="string">&#x27;fullscreenchange&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;webkitfullscreenchange&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;webkitendfullscreen&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;mozfullscreenchange&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;MSFullscreenChange&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// useEventListener支持传数组</span></span><br><span class="line">useEventListener(<span class="function">() =&gt;</span> unrefElement(targetRef), eventHandlers, handlerCallback, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h2 id="Sensors"><a href="#Sensors" class="headerlink" title="Sensors"></a>Sensors</h2><h3 id="onStartTyping"><a href="#onStartTyping" class="headerlink" title="onStartTyping"></a>onStartTyping</h3><p>在开始输入的时候执行，我们可以拿来做到<strong>不管编辑器是否聚焦，只要输入就聚焦到编辑器并输入</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onStartTyping</span>(<span class="params">callback: (event: KeyboardEvent) =&gt; <span class="built_in">void</span>, options: ConfigurableDocument = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="built_in">document</span> = defaultDocument &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keydown = <span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      isTypedCharValid(event) <span class="comment">// 检测是否是有效输入 0...9 A...Z a...z</span></span><br><span class="line">      &amp;&amp; callback(event)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>)</span><br><span class="line">    useEventListener(<span class="built_in">document</span>, <span class="string">&#x27;keydown&#x27;</span>, keydown, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的基础上还需要做一点，如果已经聚焦到<code>non-editable elements</code>，那么就不执行，如何检测<code>non-editable elements</code>呢，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFocusedElementEditable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; activeElement, body &#125; = <span class="built_in">document</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!activeElement)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (activeElement === body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (activeElement.tagName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INPUT&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;TEXTAREA&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> activeElement.hasAttribute(<span class="string">&#x27;contenteditable&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useMagicKeys"><a href="#useMagicKeys" class="headerlink" title="useMagicKeys"></a>useMagicKeys</h3><p>恰如其名，<strong>magic</strong>，先上用法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; space, shift &#125; = useMagicKeys()</span><br><span class="line"></span><br><span class="line">watch(space, <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (v)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;space has been pressed&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>又没传参，他怎么监听到我要的<code>space</code>和<code>shift</code>，难不成他返回了所有键？那当然不是，上源码（抽离了关键逻辑）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useMagicKeys</span>(<span class="params">options: UseMagicKeysOptions&lt;<span class="built_in">boolean</span>&gt; = &#123;&#125;</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = reactive(<span class="keyword">new</span> <span class="built_in">Set</span>&lt;<span class="built_in">string</span>&gt;())</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> &#123;&#125; &#125;,</span><br><span class="line">    current,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> refs: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; = useReactive ? reactive(obj) : obj</span><br><span class="line">  </span><br><span class="line">  useEventListener(target, <span class="string">&#x27;keydown&#x27;</span>, <span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    updateRefs(e, <span class="literal">true</span>) <span class="comment">// 更新按下的键到refs，键为e.key?.toLowerCase()，值为true</span></span><br><span class="line">  &#125;, &#123; passive &#125;)</span><br><span class="line">    </span><br><span class="line">  useEventListener(target, <span class="string">&#x27;keyup&#x27;</span>, <span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    updateRefs(e, <span class="literal">false</span>) <span class="comment">// 更新按下的键到refs，键为e.key?.toLowerCase()，值为false</span></span><br><span class="line">  &#125;, &#123; passive &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">    refs,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params">target, prop, rec</span>)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (!(prop <span class="keyword">in</span> refs)) &#123;</span><br><span class="line">          <span class="comment">// 初始将对应的键设为false，如&#x27;shift&#x27;</span></span><br><span class="line">          refs[prop] = ref(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> r = <span class="built_in">Reflect</span>.get(target, prop, rec)</span><br><span class="line">        <span class="keyword">return</span> useReactive ? toValue(r) : r</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxy <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样refs只存了取的键的状态，而不是所有键的状态</p><h3 id="usePageLeave"><a href="#usePageLeave" class="headerlink" title="usePageLeave"></a>usePageLeave</h3><p>用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/relatedTarget">MouseEvent.relatedTarget</a>检测是否离开屏幕</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">usePageLeave</span>(<span class="params">options: ConfigurableWindow = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = event.relatedTarget || event.toElement <span class="comment">// 如果为null，则移出屏幕</span></span><br><span class="line">    isLeft.value = !<span class="keyword">from</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>) &#123;</span><br><span class="line">    useEventListener(<span class="built_in">window</span>, <span class="string">&#x27;mouseout&#x27;</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    useEventListener(<span class="built_in">window</span>.document, <span class="string">&#x27;mouseleave&#x27;</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    useEventListener(<span class="built_in">window</span>.document, <span class="string">&#x27;mouseenter&#x27;</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isLeft</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useSpeechSynthesis"><a href="#useSpeechSynthesis" class="headerlink" title="useSpeechSynthesis"></a>useSpeechSynthesis</h3><p>利用<a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis">SpeechSynthesis</a>来做到语音阅读</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useSpeechSynthesis</span>(<span class="params">text: MaybeRefOrGetter&lt;<span class="built_in">string</span>&gt;, options: UseSpeechSynthesisOptions = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> synth = <span class="built_in">window</span> &amp;&amp; (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).speechSynthesis <span class="keyword">as</span> SpeechSynthesis;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> bindEventsForUtterance = <span class="function">(<span class="params">utterance: SpeechSynthesisUtterance</span>) =&gt;</span> &#123;</span><br><span class="line">    utterance.lang = toValue(lang)</span><br><span class="line">    utterance.voice = toValue(options.voice) || <span class="literal">null</span></span><br><span class="line">    utterance.pitch = toValue(pitch)</span><br><span class="line">    utterance.rate = toValue(rate)</span><br><span class="line">    utterance.volume = volume</span><br><span class="line"></span><br><span class="line">    utterance.onstart = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isPlaying.value = <span class="literal">true</span></span><br><span class="line">      status.value = <span class="string">&#x27;play&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    utterance.onpause = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isPlaying.value = <span class="literal">false</span></span><br><span class="line">      status.value = <span class="string">&#x27;pause&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    utterance.onresume = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isPlaying.value = <span class="literal">true</span></span><br><span class="line">      status.value = <span class="string">&#x27;play&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    utterance.onend = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isPlaying.value = <span class="literal">false</span></span><br><span class="line">      status.value = <span class="string">&#x27;end&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    utterance.onerror = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      error.value = event</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> utterance = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    isPlaying.value = <span class="literal">false</span></span><br><span class="line">    status.value = <span class="string">&#x27;init&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> newUtterance = <span class="keyword">new</span> SpeechSynthesisUtterance(spokenText.value)</span><br><span class="line">    bindEventsForUtterance(newUtterance)</span><br><span class="line">    <span class="keyword">return</span> newUtterance</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> speak = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    synth!.cancel()</span><br><span class="line">    utterance &amp;&amp; synth!.speak(utterance.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    synth!.cancel()</span><br><span class="line">    isPlaying.value = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryOnScopeDispose(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    isPlaying.value = <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><h3 id="useTransition"><a href="#useTransition" class="headerlink" title="useTransition"></a>useTransition</h3><p><strong>可配置项</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CubicBezierPoints = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line"><span class="keyword">type</span> EasingFunction = <span class="function">(<span class="params">n: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTransition</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  source: Ref&lt;<span class="built_in">number</span> | <span class="built_in">number</span>[]&gt; | MaybeRef&lt;<span class="built_in">number</span>&gt;[],</span></span></span><br><span class="line"><span class="params"><span class="function">  options: TransitionOptions = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ComputedRef</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="comment">// 时间相关单位均为ms</span></span><br><span class="line">    delay = <span class="number">0</span>,           <span class="comment">// delay 后执行</span></span><br><span class="line">    disabled = <span class="literal">false</span>,    <span class="comment">// 是否关闭</span></span><br><span class="line">    duration = <span class="number">1000</span>,     <span class="comment">// 持续时间</span></span><br><span class="line">    onFinished = noop,   <span class="comment">// 完成后执行</span></span><br><span class="line">    onStarted = noop,    <span class="comment">// 开始时执行</span></span><br><span class="line">    transition = linear, <span class="comment">// 转化算法 MaybeRef&lt;EasingFunction | CubicBezierPoints&gt;，默认值是 x =&gt; x</span></span><br><span class="line">  &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预处理</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTransition</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  source: Ref&lt;<span class="built_in">number</span> | <span class="built_in">number</span>[]&gt; | MaybeRef&lt;<span class="built_in">number</span>&gt;[],</span></span></span><br><span class="line"><span class="params"><span class="function">  options: TransitionOptions = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ComputedRef</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 可配置项</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建当前的过渡函数，如果用户自定义了过渡函数则不做处理，否则根据贝赛尔曲线值创建过渡函数</span></span><br><span class="line">  <span class="keyword">const</span> currentTransition = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> t = unref(transition)</span><br><span class="line">    <span class="keyword">return</span> isFunction(t) ? t : createEasingFunction(t)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用unref处理source参数，如果source是数组则依次unref</span></span><br><span class="line">  <span class="keyword">const</span> sourceValue = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = unref&lt;<span class="built_in">number</span> | MaybeRef&lt;<span class="built_in">number</span>&gt;[]&gt;(source)</span><br><span class="line">    <span class="keyword">return</span> isNumber(s) ? s : s.map(unref) <span class="keyword">as</span> <span class="built_in">number</span>[]</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 规格化source，整成数组</span></span><br><span class="line">  <span class="keyword">const</span> sourceVector = computed(<span class="function">() =&gt;</span> isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建过渡函数，纯数学</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEasingFunction</span>(<span class="params">[p0, p1, p2, p3]: CubicBezierPoints</span>): <span class="title">EasingFunction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="function">(<span class="params">a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">1</span> - <span class="number">3</span> * a2 + <span class="number">3</span> * a1</span><br><span class="line">  <span class="keyword">const</span> b = <span class="function">(<span class="params">a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">3</span> * a2 - <span class="number">6</span> * a1</span><br><span class="line">  <span class="keyword">const</span> c = <span class="function">(<span class="params">a1: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">3</span> * a1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> calcBezier = <span class="function">(<span class="params">t: <span class="built_in">number</span>, a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getSlope = <span class="function">(<span class="params">t: <span class="built_in">number</span>, a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">3</span> * a(a1, a2) * t * t + <span class="number">2</span> * b(a1, a2) * t + c(a1)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getTforX = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> aGuessT = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> currentSlope = getSlope(aGuessT, p0, p2)</span><br><span class="line">      <span class="keyword">if</span> (currentSlope === <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> aGuessT</span><br><span class="line">      <span class="keyword">const</span> currentX = calcBezier(aGuessT, p0, p2) - x</span><br><span class="line">      aGuessT -= currentX / currentSlope</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aGuessT</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> p0 === p1 &amp;&amp; p2 === p3 ? x : calcBezier(getTforX(x), p1, p3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了几种过渡预设</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TransitionPresets: Record&lt;<span class="built_in">string</span>, CubicBezierPoints | EasingFunction&gt; = &#123;</span><br><span class="line">  <span class="attr">easeInSine</span>: [<span class="number">0.12</span>, <span class="number">0</span>, <span class="number">0.39</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">easeOutSine</span>: [<span class="number">0.61</span>, <span class="number">1</span>, <span class="number">0.88</span>, <span class="number">1</span>],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可以看 <a href="https://easings.net/cn#">缓动函数</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#easing_functions">MDN：缓动函数</a></p><p><strong>关键逻辑</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> outputVector = ref(sourceVector.value.slice(<span class="number">0</span>)) <span class="comment">// 用以存储输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过渡主流程，可以暂停</span></span><br><span class="line"><span class="keyword">const</span> &#123; resume, pause &#125; = useRafFn(<span class="function">() =&gt;</span> &#123; <span class="comment">// 可以暂停、恢复的 requestAnimationFrame</span></span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">const</span> progress = clamp(<span class="number">1</span> - ((endAt - now) / currentDuration), <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// 过渡进度，clamp将值限制在0-1之间</span></span><br><span class="line"></span><br><span class="line">  outputVector.value = startVector.map(<span class="function">(<span class="params">val, i</span>) =&gt;</span> val + ((diffVector[i] ?? <span class="number">0</span>) * currentTransition.value(progress))) <span class="comment">// 更新output</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (progress &gt;= <span class="number">1</span>) &#123; <span class="comment">// 完成过渡</span></span><br><span class="line">    pause() <span class="comment">// 暂停 requestAnimationFrame</span></span><br><span class="line">    onFinished() <span class="comment">// 执行options中的完成回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">immediate</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = useTimeoutFn(start, delay, &#123; <span class="attr">immediate</span>: <span class="literal">false</span> &#125;) <span class="comment">// delay毫秒后执行start函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  pause() <span class="comment">// 暂停 过渡</span></span><br><span class="line"></span><br><span class="line">  currentDuration = unref(duration)</span><br><span class="line">  diffVector = outputVector.value.map(<span class="function">(<span class="params">n, i</span>) =&gt;</span> (sourceVector.value[i] ?? <span class="number">0</span>) - (outputVector.value[i] ?? <span class="number">0</span>)) <span class="comment">// 初始值和当前值的diff</span></span><br><span class="line">  startVector = outputVector.value.slice(<span class="number">0</span>) <span class="comment">// 拷贝初始值</span></span><br><span class="line">  startAt = <span class="built_in">Date</span>.now() <span class="comment">// 开始时间</span></span><br><span class="line">  endAt = startAt + currentDuration <span class="comment">// 结束时间，用在计算progress</span></span><br><span class="line"></span><br><span class="line">  resume() <span class="comment">// 开始过渡</span></span><br><span class="line">  onStarted() <span class="comment">// 执行options中的开始回调</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch(sourceVector, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听sourceVector的变化</span></span><br><span class="line">  <span class="keyword">if</span> (unref(disabled)) &#123; <span class="comment">// 如果暂停过渡，将输出还原回初始值</span></span><br><span class="line">    outputVector.value = sourceVector.value.slice(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (unref(delay) &lt;= <span class="number">0</span>) start() <span class="comment">// 如果没有延迟，则开始过渡</span></span><br><span class="line">    <span class="keyword">else</span> timeout.start() <span class="comment">// 如果有延迟，则开始上面创建好的timeout</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> targetVector = unref(disabled) ? sourceVector : outputVector <span class="comment">// 如果暂停过渡，将输出还原回初始值</span></span><br><span class="line">  <span class="keyword">return</span> isNumber(sourceValue.value) ? targetVector.value[<span class="number">0</span>] : targetVector.value <span class="comment">// 为值解开数组包装，数组原样返回</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Sound"><a href="#Sound" class="headerlink" title="@Sound"></a>@Sound</h2><p>可以简单的让你的网站带上声音</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> buttonSfx <span class="keyword">from</span> <span class="string">&#x27;../assets/sounds/button.mp3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; play &#125; = useSound(buttonSfx)</span><br></pre></td></tr></table></figure><p>demo：<a href="https://sound.vueuse.org/">https://sound.vueuse.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文不会放api的用法，建议先看看是怎么用的&lt;/p&gt;
&lt;p&gt;写本篇文章时间间隔较长，所以代码版本不一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目架构&quot;&gt;&lt;a href=&quot;#项目架构&quot; class=&quot;headerlink&quot; title=&quot;项目架构&quot;&gt;&lt;/a&gt;项目架构&lt;/h2&gt;&lt;p&gt;采用monorepo的形式，项目目录下有多个子项目，下面放了资料链接和几处用法，其他本文不多赘述。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6944877410827370504&quot;&gt;现代前端工程为什么越来越离不开 Monorepo?&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.codeleading.com/article/46915806308/&quot;&gt;为什么使用pnpm可以光速建立好用的monorepo（比yarn/lerna效率高）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://pnpm.io/zh/workspaces&quot;&gt;pnpm workspace文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【源码解读】p-limit 限制并发数</title>
    <link href="https://liang5757.github.io/2023/04/19/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/p-limit-%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0/"/>
    <id>https://liang5757.github.io/2023/04/19/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/p-limit-%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0/</id>
    <published>2023-04-18T16:53:37.000Z</published>
    <updated>2023-04-18T16:55:14.797Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>github: <a href="https://github.com/sindresorhus/p-limit">https://github.com/sindresorhus/p-limit</a></p></blockquote><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pLimit <span class="keyword">from</span> <span class="string">&#x27;p-limit&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> limit = pLimit(<span class="number">1</span>); <span class="comment">// 只能有一个promise在执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">limit(<span class="function">() =&gt;</span> fetchSomething(<span class="string">&#x27;foo&#x27;</span>)),</span><br><span class="line">limit(<span class="function">() =&gt;</span> fetchSomething(<span class="string">&#x27;bar&#x27;</span>)),</span><br><span class="line">limit(<span class="function">() =&gt;</span> doSomething())</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(input);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="函数源码"><a href="#函数源码" class="headerlink" title="函数源码"></a>函数源码</h2><h3 id="初始化（pLimit）"><a href="#初始化（pLimit）" class="headerlink" title="初始化（pLimit）"></a>初始化（pLimit）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue <span class="keyword">from</span> <span class="string">&quot;yocto-queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">pLimit</span>(<span class="params">concurrency</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"><span class="keyword">let</span> activeCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enqueue = <span class="function">(<span class="params">fn, resolve, args</span>) =&gt;</span> &#123;</span><br><span class="line">queue.enqueue(run.bind(<span class="literal">undefined</span>, fn, resolve, args));</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">             <span class="comment">// 思考里讲解为什么这里需要Promise.resolve()</span></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (activeCount &lt; concurrency &amp;&amp; queue.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">queue.dequeue()();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">enqueue(fn, resolve, args);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pLimit</code>函数的入参 concurrency 是最大并发数，调用一次 pLimit 会生成一个限制并发的函数 generator</p><p>依赖<code>yocto-queue</code>的队列能力，每次调用<code>generator</code>会返回个<code>promise</code></p><ol><li>会向队列入队一个<code>run</code>（执行函数）</li><li>如果当前在执行<code>promise</code>数量小于<code>concurrency</code>（并发数），就出队并执行</li></ol><h3 id="执行函数（run）"><a href="#执行函数（run）" class="headerlink" title="执行函数（run）"></a>执行函数（run）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    activeCount--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        queue.dequeue()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">async</span> (fn, resolve, args) =&gt; &#123;</span><br><span class="line">    activeCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = (<span class="keyword">async</span> () =&gt; fn(...args))();</span><br><span class="line"></span><br><span class="line">    resolve(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>run函数执行</p><ol><li><code>activeCount</code>加一</li><li>执行异步函数<code>fn</code>，并将结果传递给<code>resolve</code></li><li><code>await</code>了<code>result</code>，使得<code>next</code>执行有序</li><li>执行<code>next</code>时表示<code>promise</code>结果已经返回，<code>activeCount</code>-1，并开始执行下一个<code>promise</code></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="为什么使用队列而不是数组"><a href="#为什么使用队列而不是数组" class="headerlink" title="为什么使用队列而不是数组"></a>为什么使用队列而不是数组</h3><p>相关issus：<a href="https://github.com/sindresorhus/p-limit/pull/47">Improve performance</a></p><p><code>shift</code>方法每次调用时, 都需要遍历一次数组, 将数组进行一次平移, 时间复杂度是O(n)<br>队列的<code>dequeue</code>时间复杂度则是O(1)</p><h3 id="为什么在入队并且执行的时候，判断执行前需要await-Promise-resolve"><a href="#为什么在入队并且执行的时候，判断执行前需要await-Promise-resolve" class="headerlink" title="为什么在入队并且执行的时候，判断执行前需要await Promise.resolve()"></a>为什么在入队并且执行的时候，判断执行前需要await Promise.resolve()</h3><p>相关issus：<a href="https://github.com/sindresorhus/p-limit/pull/28">Always run limited functions asynchronously</a></p><p>不加的话，有时候执行是同步的，有时候执行是异步的，有可能会导致在下一行代码执行之前状态就已经改变了，让程序运行结果不可预测</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activeCount &lt; concurrency &amp;&amp; queue.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        queue.dequeue()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>加上可以保证所有出队执行都是异步的</p><h3 id="如何添加超时逻辑"><a href="#如何添加超时逻辑" class="headerlink" title="如何添加超时逻辑"></a>如何添加超时逻辑</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> timerPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;time out&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  timerPromise,</span><br><span class="line">  fetchPromise,</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">clearTimeout</span>(timer))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br></pre></td></tr></table></figure><p>更正规的写法可以参考：<a href="https://github.com/sindresorhus/p-timeout">p-timeout</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s/6LsPMIHdIOw3KO6F2sgRXg">Node.js 并发能力总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/sindresorhus/p-limit&quot;&gt;https://github.com/sindresorhus/p-limit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pLimit &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;p-limit&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; limit = pLimit(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 只能有一个promise在执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; input = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	limit(&lt;span class=&quot;function&quot;&gt;() =&amp;gt;&lt;/span&gt; fetchSomething(&lt;span class=&quot;string&quot;&gt;&amp;#x27;foo&amp;#x27;&lt;/span&gt;)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	limit(&lt;span class=&quot;function&quot;&gt;() =&amp;gt;&lt;/span&gt; fetchSomething(&lt;span class=&quot;string&quot;&gt;&amp;#x27;bar&amp;#x27;&lt;/span&gt;)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	limit(&lt;span class=&quot;function&quot;&gt;() =&amp;gt;&lt;/span&gt; doSomething())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; result = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.all(input);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【源码解读】arrify 转数组</title>
    <link href="https://liang5757.github.io/2022/05/21/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/arrify-%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://liang5757.github.io/2022/05/21/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/arrify-%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2022-05-21T03:33:05.000Z</published>
    <updated>2023-04-18T16:54:17.013Z</updated>
    
    <content type="html"><![CDATA[<p>半年没写博客，从简单的源码开始启动</p><a id="more"></a><blockquote><p>github: <a href="https://github.com/sindresorhus/arrify">https://github.com/sindresorhus/arrify</a></p></blockquote><h3 id="功能代码"><a href="#功能代码" class="headerlink" title="功能代码"></a>功能代码</h3><p>比较简单，就先展示一下全部js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value === <span class="literal">null</span> || value === <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> value[<span class="built_in">Symbol</span>.iterator] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [...value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我看来和Array.from的区别如下</p><table><thead><tr><th></th><th>Array.from</th><th>arrify</th></tr></thead><tbody><tr><td>undefined</td><td>报错：Uncaught TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))</td><td>[]</td></tr><tr><td>Null</td><td>报错：Uncaught TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))</td><td>[]</td></tr><tr><td>document.querySelector(‘*’)</td><td>带所有元素的数组</td><td>[document.querySelector(‘*’)]</td></tr></tbody></table><p>作者对于array like处理的<a href="https://github.com/sindresorhus/arrify/issues/2">回应</a>，翻译一下：故意这么整的，arrify应当只是数组化，而不是对类数组进行转换，对类数组转换可以用<code>Array.from</code></p><p>ps：在我尝试的时候，用chrome控制台Array.from(document.querySelector(‘<em>‘))，会得到一个*</em>空数组**，但是本地创建的html测试是没问题的，不知道为什么</p><h4 id="关于string的处理"><a href="#关于string的处理" class="headerlink" title="关于string的处理"></a>关于string的处理</h4><p>为什么不直接去掉value === ‘string’这个if语句块，这样在最后也能返回[value]？</p><p>答：string有Symbol.iterator属性，所以会执行[…value]</p><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><h4 id="重载定义？"><a href="#重载定义？" class="headerlink" title="重载定义？"></a>重载定义？</h4><p>最开始的类型定义是用<strong>重载</strong>的方式，对不同参数类型进行处理，代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>(<span class="params">value: <span class="literal">null</span> | <span class="literal">undefined</span></span>): []</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>(<span class="params">value: <span class="built_in">string</span></span>): [<span class="title">string</span>]</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>&lt;<span class="title">ValueType</span>&gt;(<span class="params">value: ValueType[]</span>): <span class="title">ValueType</span>[]</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>&lt;<span class="title">ValueType</span>&gt;(<span class="params">value: ReadonlyArray&lt;ValueType&gt;</span>): <span class="title">ReadonlyArray</span>&lt;<span class="title">ValueType</span>&gt;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>&lt;<span class="title">ValueType</span>&gt;(<span class="params">value: Iterable&lt;ValueType&gt;</span>): <span class="title">ValueType</span>[]</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>&lt;<span class="title">ValueType</span>&gt;(<span class="params">value: ValueType</span>): [<span class="title">ValueType</span>]</span>;</span><br></pre></td></tr></table></figure><p>但是在该<a href="https://github.com/sindresorhus/arrify/issues/8">issus</a>提出了，参数不支持联合类型，case如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrify(<span class="built_in">Boolean</span>() ? [<span class="number">1</span>, <span class="number">2</span>] : <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>参数会被ts推断为<code>number | number[]</code>，并不满足上面所有重载方法的定义，考虑联合类型后，各种类型组合的数量太多了，函数重载的定义方式无法满足需求。</p><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>类型定义如下，其实也和js的判断一一对应</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">arrify</span>&lt;<span class="title">ValueType</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">   value: ValueType</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ValueType</span> <span class="title">extends</span> (<span class="params"><span class="literal">null</span> | <span class="literal">undefined</span></span>)</span></span><br><span class="line"><span class="function">   ? []</span></span><br><span class="line"><span class="function">   : <span class="title">ValueType</span> <span class="title">extends</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">      ? [<span class="title">string</span>]</span></span><br><span class="line"><span class="function">      : <span class="title">ValueType</span> <span class="title">extends</span> <span class="title">readonly</span> <span class="title">unknown</span>[]</span></span><br><span class="line"><span class="function">         ? <span class="title">ValueType</span></span></span><br><span class="line"><span class="function">         : <span class="title">ValueType</span> <span class="title">extends</span> <span class="title">Iterable</span>&lt;<span class="title">infer</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">            ? <span class="title">T</span>[]</span></span><br><span class="line"><span class="function">            : [<span class="title">ValueType</span>]</span>;</span><br></pre></td></tr></table></figure><p>使用extend后，会将联合类型的每一个取出来执行判断，得出结果后再合并成联合类型，例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> value&lt;ValueType&gt; = ValueType <span class="keyword">extends</span> (<span class="literal">null</span> | <span class="literal">undefined</span>)</span><br><span class="line">? []</span><br><span class="line">: ValueType <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">? [<span class="built_in">string</span>]</span><br><span class="line">: ValueType <span class="keyword">extends</span> <span class="keyword">readonly</span> unknown[]</span><br><span class="line">? ValueType</span><br><span class="line">: ValueType <span class="keyword">extends</span> Iterable&lt;infer T&gt;</span><br><span class="line">? T[]</span><br><span class="line">: [ValueType];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test = value&lt;<span class="built_in">number</span> | <span class="built_in">string</span>[]&gt; <span class="comment">// [number] | string[]</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>还是比较老的仓库，他的一些设计理念我不是很认同，我觉得给人用的第三方库就应该能够处理所有的情况，而不是为了设计理念来严格定义，不对一些情况进行处理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;半年没写博客，从简单的源码开始启动&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Mitt源码解读</title>
    <link href="https://liang5757.github.io/2021/12/15/Ts/Mitt%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://liang5757.github.io/2021/12/15/Ts/Mitt%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-12-15T11:45:48.000Z</published>
    <updated>2021-12-23T14:58:20.060Z</updated>
    
    <content type="html"><![CDATA[<p>github地址：<a href="https://github.com/developit/mitt">https://github.com/developit/mitt</a></p><blockquote><p>200b大小的event bus库</p></blockquote><a id="more"></a><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>让人眼前一亮的是，该库对类型有着较强规范，用户可以很方便的用下面的方式定义事件类型，在该<a href="https://github.com/developit/mitt/issues/106">issus</a>被提出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Events = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>; <span class="comment">// 事件名: 参数类型</span></span><br><span class="line">  bar?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emitter = mitt&lt;Events&gt;(); <span class="comment">// inferred as Emitter&lt;Events&gt;</span></span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">&#x27;foo&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;); <span class="comment">// &#x27;e&#x27; has inferred type &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">&#x27;foo&#x27;</span>, <span class="number">42</span>); <span class="comment">// Error: Argument of type &#x27;number&#x27; is not assignable to parameter of type &#x27;string&#x27;. (2345)</span></span><br></pre></td></tr></table></figure><p>那它是如何做到的呢，先把实现代码展示出来再分部讲解（直接看懂的可以跳过讲解）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventType = <span class="built_in">string</span> | symbol;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Handler&lt;T = unknown&gt; = <span class="function">(<span class="params">event: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">mitt</span>&lt;<span class="title">Events</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">EventType</span>, <span class="title">unknown</span>&gt;&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">all?: EventHandlerMap&lt;Events&gt; <span class="comment">// 可以暂时忽略这里</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Emitter</span>&lt;<span class="title">Events</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">type</span> GenericEventHandler =</span><br><span class="line">    | Handler&lt;Events[keyof Events]&gt;</span><br><span class="line">    | WildcardHandler&lt;Events&gt;; <span class="comment">// 为了适配用 *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">on&lt;Key <span class="keyword">extends</span> keyof Events&gt; (<span class="keyword">type</span>: Key, <span class="attr">handler</span>: GenericEventHandler) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br><span class="line">off&lt;Key <span class="keyword">extends</span> keyof Events&gt; (<span class="keyword">type</span>: Key, handler?: GenericEventHandler) &#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;,</span><br><span class="line">        emit&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: Key, evt?: Events[Key])  &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p><code>Record&lt;K, T&gt;</code>是typescript内置的类型函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Construct a type with a set of properties K of type T</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代表的意思是从第一个参数获取所有键，值为第二个参数，源码中<code>Record&lt;EventType, unknown&gt;</code>即为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventType = <span class="built_in">string</span> | symbol;</span><br><span class="line">Record&lt;EventType, unknown&gt; === &#123;</span><br><span class="line">    [P <span class="keyword">in</span> <span class="built_in">string</span> | symbol]: unknown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Events extends Record&lt;EventType, unknown&gt;</code>利用泛型约束将用户传入的Events类型约束为上述类型</p><h3 id="类型编程"><a href="#类型编程" class="headerlink" title="类型编程"></a>类型编程</h3><p>就像余华老师睡一觉醒来后有了这么一个题目叫《活着》，觉得题目非常好就开始写了，第一次见到<a href="https://linbudu.top/ts-type-programming">Linbudu的博客</a>，见到了一个词——<strong>类型编程</strong>，有了这么一个概念（虽然不知道是在何时何地被提出的），突然很多知识就有了一个系统的名称，引导人们探索这个系统下的各种应用，下面就是一个很简单的一个例子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Handler&lt;T = unknown&gt; = <span class="function">(<span class="params">event: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GenericEventHandler = Handler&lt;Events[keyof Events]&gt;</span><br></pre></td></tr></table></figure><p><code>Events[keyof Events]</code>就是将用户定义的Events类型的值类型全部取出，在最上面的使用方式的例子里，会有如下的转化结果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Events = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>; <span class="comment">// 事件名: 参数类型</span></span><br><span class="line">  bar?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Events[keyof Events] === <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> GenericEventHandler = Handler&lt;Events[keyof Events]&gt; === <span class="function">(<span class="params">event: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>再看<code>on</code>、<code>off</code>、<code>emit</code>函数定义，去除了 支持type为<code>*</code>的功能</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">on&lt;Key <span class="keyword">extends</span> keyof Events&gt; (<span class="keyword">type</span>: Key, <span class="attr">handler</span>: Handler&lt;Events[Key]&gt;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">off&lt;Key <span class="keyword">extends</span> keyof Events&gt; (<span class="keyword">type</span>: Key, handler?: Handler&lt;Events[Key]&gt;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">emit&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: Key, evt?: Events[Key])  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们在<code>on</code>、<code>off</code>和<code>emit</code>只能注册或注销<strong>事件名</strong>和<strong>handler的参数</strong>与用户定义Events类型一致的事件</p><h2 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h2><h3 id="可替换的all"><a href="#可替换的all" class="headerlink" title="可替换的all"></a>可替换的all</h3><p>all用来存储用户注册的事件，mitt会初始化一个Map作为默认的，但是用户可以传入自己的Map。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">mitt</span>&lt;<span class="title">Events</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">EventType</span>, <span class="title">unknown</span>&gt;&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">all?: EventHandlerMap&lt;Events&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Emitter</span>&lt;<span class="title">Events</span>&gt; </span>&#123;</span><br><span class="line">    all = all || <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="on"><a href="#on" class="headerlink" title="on"></a>on</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">on&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: Key, <span class="attr">handler</span>: GenericEventHandler) &#123;</span><br><span class="line">    <span class="keyword">const</span> handlers: <span class="built_in">Array</span>&lt;GenericEventHandler&gt; | <span class="literal">undefined</span> = all!.get(<span class="keyword">type</span>);</span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">        handlers.push(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        all!.set(<span class="keyword">type</span>, [handler] <span class="keyword">as</span> EventHandlerList&lt;Events[keyof Events]&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果已经注册同名事件则直接将handler推进数组，否则创建个新数组存放hanlder。</p><h3 id="off"><a href="#off" class="headerlink" title="off"></a>off</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">off&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: Key, handler?: GenericEventHandler) &#123;</span><br><span class="line">    <span class="keyword">const</span> handlers: <span class="built_in">Array</span>&lt;GenericEventHandler&gt; | <span class="literal">undefined</span> = all!.get(<span class="keyword">type</span>); <span class="comment">// 对应事件名的handler数组</span></span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            all!.set(<span class="keyword">type</span>, []);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个秀操作的点，当用户传入handler要<strong>删除对应事件名下的对应handler</strong>时，有这么一段。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>我们知道</p><ul><li><code>indexOf</code>没有在数组中找到对应的值，那么就会返回-1</li><li><code>&gt;&gt;&gt; 0</code>（ 零填充右位移0位）不是没变？</li><li>而<code>splice(-1, 1)</code>表示删除最后一位</li></ul><p>综合起来看，如果<code>-1 &gt;&gt;&gt; 0</code>没变那么就会误删最后一个handler。</p><p>让我们看看<code>&gt;&gt;&gt; 0</code>是什么魔法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(-<span class="number">1</span> &gt;&gt;&gt; <span class="number">0</span>); <span class="comment">// 4294967295</span></span><br></pre></td></tr></table></figure><p>js number采用的是IEEE 754双精度浮点，<strong>&gt;&gt;&gt;会把number截断成32位int进行位移</strong>，更具体的不展开。如果没找到对应的handler，代码即为<code>handlers.splice(4294967295, 1)</code>，我们当然不可能存如此多的handler，也就不可能删除4294967295下标对应的handler，比起我们判断<code>indexOf</code>是否为-1缩短了代码（什么叫<strong>Microscopic</strong>啊？）</p><h3 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h3><ul><li>适配type为*的情况，为所有事件都注册handler，emit时取出*中的所有handler执行</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">emit&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: Key, evt?: Events[Key]) &#123;</span><br><span class="line">    <span class="keyword">let</span> handlers = all!.get(<span class="keyword">type</span>);</span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">        (handlers <span class="keyword">as</span> EventHandlerList&lt;Events[keyof Events]&gt;)</span><br><span class="line">            .slice()</span><br><span class="line">            .map(<span class="function">(<span class="params">handler</span>) =&gt;</span> &#123;</span><br><span class="line">            handler(evt!);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handlers = all!.get(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">        (handlers <span class="keyword">as</span> WildCardEventHandlerList&lt;Events&gt;)</span><br><span class="line">            .slice()</span><br><span class="line">            .map(<span class="function">(<span class="params">handler</span>) =&gt;</span> &#123;</span><br><span class="line">            handler(<span class="keyword">type</span>, evt!);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>虽然源码并没有实现，但是既然是事件总线的文章，还是提一提。在我之前面试的时候经常被问到事件总线是如何实现的，其中就有Once的实现，我没有深入思考，只想着实现就完事了：<strong>给所有handler用对象包裹一层，然后加一个Once字段标识，在emit时判断Once是否为true，true的话执行完注销事件</strong>，但是这样<code>on</code>和<code>emit</code>都需要修改，多创建了一个对象并且不优雅。</p><p>我们可以充分利用js的灵活性，用一个函数包裹用户的handler，在该函数中off掉handler。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">once</span>(<span class="params"><span class="keyword">type</span>: Key, handler: GenericEventHandler</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> self: Emitter&lt;Events&gt; = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.off(<span class="keyword">type</span>, listener);</span><br><span class="line">            handler.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.on(<span class="keyword">type</span>, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的代码有一个很隐蔽的问题：<strong>由于是用一个新的函数去包裹，在off时传旧handler去注销once事件无法成功</strong></p><p><strong>解决方式</strong></p><p>在listener函数中存旧的handler</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">once</span>(<span class="params"><span class="keyword">type</span>: Key, handler: GenericEventHandler</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> self: Emitter&lt;Events&gt; = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.off(<span class="keyword">type</span>, listener);</span><br><span class="line">            handler.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        listener.fn = handler; <span class="comment">// 增加了这里</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.on(<span class="keyword">type</span>, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过用这种方式的话，我们的<code>&gt;&gt;&gt;</code>魔法就不能使用的（这是mitt没有once的原因？）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">off&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: Key, handler?: GenericEventHandler) &#123;</span><br><span class="line">    <span class="keyword">const</span> handlers: <span class="built_in">Array</span>&lt;GenericEventHandler&gt; | <span class="literal">undefined</span> = all!.get(<span class="keyword">type</span>);</span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (handler === handlers[i] || handler === handlers[i].fn)</span><br><span class="line">                    handlers.splice(i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            all!.set(<span class="keyword">type</span>, []);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>在该<a href="https://github.com/developit/mitt/pull/114">Stronger typing #114</a>commit中，大量的any被替换为unknown</p><p>关于unknown的特点可看<a href="https://juejin.cn/post/6844903866073350151">[译] TypeScript 3.0: unknown 类型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;github地址：&lt;a href=&quot;https://github.com/developit/mitt&quot;&gt;https://github.com/developit/mitt&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;200b大小的event bus库&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="ts" scheme="https://liang5757.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>vueuse源码解析</title>
    <link href="https://liang5757.github.io/2021/12/11/Vue/vueuse%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://liang5757.github.io/2021/12/11/Vue/vueuse%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2021-12-10T17:46:15.000Z</published>
    <updated>2021-12-23T15:03:09.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文不会放api的用法，建议先看看是怎么用的</p></blockquote><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>采用monorepo的形式，项目目录下有多个子项目，下面放了资料链接和几处用法，其他本文不多赘述。</p><p><a href="https://juejin.cn/post/6944877410827370504">现代前端工程为什么越来越离不开 Monorepo?</a><br><a href="https://www.codeleading.com/article/46915806308/">为什么使用pnpm可以光速建立好用的monorepo（比yarn/lerna效率高）</a><br><a href="https://pnpm.io/zh/workspaces">pnpm workspace文档</a></p><a id="more"></a><p>为了使所有子项目都使用同一个依赖版本，使用<a href="https://pnpm.io/zh/package_json#pnpmoverrides">pnpm.overrides</a>配置，如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;pnpm&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;overrides&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;vue-demi&quot;</span>: <span class="string">&quot;0.12.1&quot;</span>, <span class="comment">// 在postinstall钩子中根据当前环境的vue版本，获取兼容vue3和vue2的api</span></span><br><span class="line">      <span class="attr">&quot;vite&quot;</span>: <span class="string">&quot;^2.6.7&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常配置下，如果直接<code>pnpm install</code>将会在每个子项目的<code>node_modules</code>有同样的依赖，但是所有子项目相同的依赖其实只需要提取出来放在根目录的<code>node_modules</code>下即可，可配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;@vue/composition-api&quot;</span>: <span class="string">&quot;^1.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.0 || ^3.2.0&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>详情请看如下链接</p><p><a href="https://www.cnblogs.com/wonyun/p/9692476.html">探讨npm依赖管理之peerDependencies</a><br><a href="https://blog.csdn.net/qq_21567385/article/details/121088506">pnpm monorepo之多组件实例和peerDependencies困境回溯</a><br><a href="https://pnpm.io/zh/how-peers-are-resolved">如何处理 peers</a></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="unref-ref的反操作"><a href="#unref-ref的反操作" class="headerlink" title="unref - ref的反操作"></a>unref - ref的反操作</h3><ul><li>如果传入一个ref，返回其值</li><li>否则原样放回</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unref</span>&lt;<span class="title">T</span>&gt;(<span class="params">ref: T | Ref&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isRef(ref) ? ref.value : ref</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用例子：实现一个响应式的add函数，可以传入<strong>ref或值</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a: Ref&lt;<span class="built_in">number</span>&gt; | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  b: Ref&lt;<span class="built_in">number</span>&gt; | <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function">() =&gt;</span> unref(a) + unref(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MaybeRef类型"><a href="#MaybeRef类型" class="headerlink" title="MaybeRef类型"></a>MaybeRef类型</h3><p>vueuse大量使用<code>MaybeRef</code>来支持<strong>可选择性的响应式参数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T</span><br></pre></td></tr></table></figure><p>上面的加法函数就可以简写为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: MaybeRef&lt;<span class="built_in">number</span>&gt;, b: MaybeRef&lt;<span class="built_in">number</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computed(<span class="function">() =&gt;</span> unref(a) + unref(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Effect作用域API"><a href="#Effect作用域API" class="headerlink" title="Effect作用域API"></a>Effect作用域API</h3><p>Vue官方文档：<a href="https://v3.cn.vuejs.org/api/effect-scope.html#effectscope">Effect 作用域 API</a></p><p><strong>动机</strong></p><p>在Vue的setup中，响应式effect会在初始化的时候被收集，在实例被卸载的时候，响应式effect就会自动被取消了，但是在我们在组件外写一个独立的包（就如vueuse）时，我们该如何停止computed &amp; watch的响应式依赖呢？vue3.2提出了<code>effectScope</code></p><h4 id="effectScope"><a href="#effectScope" class="headerlink" title="effectScope"></a>effectScope</h4><p>利用<code>effectScope</code>创建一个作用域对象，如下面接口定义所示，<code>run</code>接受一个函数，这个作用域对象会自动捕获函数内部的响应式effect (例如计算属性或侦听器)</p><p><strong>类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effectScope</span>(<span class="params">detached?: <span class="built_in">boolean</span></span>): <span class="title">EffectScope</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">EffectScope</span> </span>&#123;</span><br><span class="line">  run&lt;T&gt;(fn: <span class="function">() =&gt;</span> T): T | <span class="literal">undefined</span> <span class="comment">// 如果这个域不活跃则为 undefined</span></span><br><span class="line">  stop(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = effectScope()</span><br><span class="line"></span><br><span class="line">scope.run(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> doubled = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line">  watch(doubled, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(doubled.value))</span><br><span class="line">  watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Count: &#x27;</span>, doubled.value))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理(dispose) 该作用域内的所有 effect</span></span><br><span class="line">scope.stop()</span><br></pre></td></tr></table></figure><h4 id="getCurrentScope"><a href="#getCurrentScope" class="headerlink" title="getCurrentScope"></a>getCurrentScope</h4><p>如果有，则返回当前活跃的 <a href="https://v3.cn.vuejs.org/api/effect-scope.html#effectscope">effect 作用域</a>。</p><p><strong>类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentScope</span>(<span class="params"></span>): <span class="title">EffectScope</span> | <span class="title">undefined</span> </span></span><br></pre></td></tr></table></figure><h4 id="onScopeDispose"><a href="#onScopeDispose" class="headerlink" title="onScopeDispose"></a>onScopeDispose</h4><p>在当前活跃的 <a href="https://v3.cn.vuejs.org/api/effect-scope.html#effectscope">effect 作用域</a>上注册一个处理回调。该回调会在相关的 effect 作用域结束之后被调用，在VCA函数中可用作<code>onUnmounted</code>的非组件替代品，区别在于其工作在scope中而不是组件实例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onScopeDispose(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, handler)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>在vue的rfc中<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md">reactivity-effect-scope</a>有这样的一个例子，如果有个监控鼠标位置的hook（useMouse），需要监听<code>mousemove</code>事件，如果在多个组件调用了这个hook，而内部是通过在<code>onUnmounted</code>钩子来移除<code>mousemove</code>监听器，<code>onUnmounted</code>耦合在每个组件实例，则无法以更有效率的方式共享这个<code>mousemove</code>监听器</p><p>为了做到在组件间共享<code>useMouse</code>的响应式effect和监听器，可以创建一个函数来管理scope如下（这个hook也在vueuse中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSharedComposable</span>(<span class="params">composable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> subscribers = <span class="number">0</span> <span class="comment">// 每次调用subscribers + 1</span></span><br><span class="line">  <span class="keyword">let</span> state, scope</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scope &amp;&amp; --subscribers &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">      scope.stop()</span><br><span class="line">      state = scope = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    subscribers++</span><br><span class="line">    <span class="keyword">if</span> (!state) &#123; <span class="comment">// 只在第一次创建effectScope</span></span><br><span class="line">      scope = effectScope(<span class="literal">true</span>) <span class="comment">// true为独立的scope作用域</span></span><br><span class="line">      state = scope.run(<span class="function">() =&gt;</span> composable(...args))</span><br><span class="line">    &#125;</span><br><span class="line">    onScopeDispose(dispose) <span class="comment">// 在当前活跃的effect作用域上注册一个回调</span></span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到dispose函数的含义是，当<strong>没有一个组件在使用</strong>它的时候会注销(dispose)创建的<code>effectScope</code>，我们只需要如下操作，即可得到一个<strong>在所有组件共享</strong>的<code>useMouse</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useSharedMouse = createSharedComposable(useMouse)</span><br></pre></td></tr></table></figure><p>更加详细的关于<code>effectScope</code>的讨论在<a href="https://github.com/vuejs/rfcs/pull/212">Reactivity’s <code>effectScope</code> API #212</a></p><p>本来是打算完全按照官网的分类进行解读，但是由于VCA的思想，hook被拆的很碎再组合在一起，并不能单纯靠分类进行解读，所以在讲某个分类的hook时也会带上其他的hooks，接下来是对我觉得 常用 或者 有学习到东西 的hook源码进行解读</p><h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><blockquote><p>浏览器相关的hook，基于web暴露的api来实现</p></blockquote><h3 id="可配置全局对象"><a href="#可配置全局对象" class="headerlink" title="可配置全局对象"></a>可配置全局对象</h3><p>Browser hook的源码开头都有或类似下面这一段</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> defaultWindow = <span class="comment">/* #__PURE__ */</span> isClient ? <span class="built_in">window</span> : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useXXX</span>&lt;<span class="title">T</span>&gt;(<span class="params">options: ConfigurableWindow = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="built_in">window</span> = defaultWindow &#125; = options</span><br><span class="line">  <span class="built_in">window</span>.xxx</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以配置当前window对象，这种配置方式对于使用<strong>iframe</strong>和<strong>测试环境</strong>不同的window对象十分有用</p><h3 id="useEventListener"><a href="#useEventListener" class="headerlink" title="useEventListener"></a>useEventListener</h3><p>先上一个简易版本的<code>useEventListener</code>，利用VCA，将事件的监听和注销放在一个函数中处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEventListener</span> (<span class="params">target, listener, options, target = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    target.addEventListener(type, listener, options)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    target.removeEventListener(type, listener, options)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，源码还提供了当<code>target</code>的类型是<code>ref</code>时的情况，为了减少篇幅，下面的代码删减了参数为空的边界情况</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEventListener</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target: MaybeRef&lt;EventTarget&gt; | <span class="literal">undefined</span> = defaultWindow;</span><br><span class="line">  <span class="keyword">let</span> event: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">let</span> listener: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">let</span> options: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  [target, event, listener, options] = args</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cleanup = noop</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stopWatch = watch(</span><br><span class="line">    <span class="function">() =&gt;</span> unref(target),</span><br><span class="line">    <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">      cleanup()</span><br><span class="line">      <span class="keyword">if</span> (!el)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      el.addEventListener(event, listener, options)</span><br><span class="line"></span><br><span class="line">      cleanup = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        el.removeEventListener(event, listener, options)</span><br><span class="line">        cleanup = noop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">flush</span>: <span class="string">&#x27;post&#x27;</span> &#125;, <span class="comment">// 为什么flush是post？下面会讲解</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    stopWatch()</span><br><span class="line">    cleanup()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryOnScopeDispose(stop)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么需要支持ref-target"><a href="#为什么需要支持ref-target" class="headerlink" title="为什么需要支持ref target"></a>为什么需要支持ref target</h4><p>用<code>unref</code>得到<code>ref</code>中的dom元素，监听dom元素的改变以重新监听事件，应用场景就放官网例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;cond&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;element&quot;</span>&gt;</span>Div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">ref</span>=<span class="string">&quot;element&quot;</span>&gt;</span>Div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEventListener &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = ref&lt;HTMLDivElement&gt;()</span><br><span class="line">useEventListener(element, <span class="string">&#x27;keydown&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(e.key) &#125;)</span><br></pre></td></tr></table></figure><h4 id="为什么需要watch设置flush为post"><a href="#为什么需要watch设置flush为post" class="headerlink" title="为什么需要watch设置flush为post"></a>为什么需要watch设置flush为post</h4><p>详情请看<a href="https://github.com/vueuse/vueuse/issues/356">#356 Bug: useEventListener doesn’t work correctly with v-if</a>，意思就是<a href="https://github.com/vuejs/vue-next/issues/1706#issuecomment-666258948%5C">新版vue</a>的<code>watch</code>默认在所有组件update前执行，那么ref没有更新导致事件没有更新，所以需要在组件update完毕后更新事件。</p><h4 id="tryOnScopeDispose是啥"><a href="#tryOnScopeDispose是啥" class="headerlink" title="tryOnScopeDispose是啥"></a>tryOnScopeDispose是啥</h4><p>先判断是否有活跃的effectScope，有的话用<code>onScopeDispose</code>在其上注册fn回调</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">tryOnScopeDispose</span>(<span class="params">fn: Fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getCurrentScope()) &#123;</span><br><span class="line">    onScopeDispose(fn)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEyeDropper"><a href="#useEyeDropper" class="headerlink" title="useEyeDropper"></a>useEyeDropper</h3><p><code>new window.EyeDropper()</code>可以获取<strong>取色器</strong>的功能</p><h3 id="useMediaQuery"><a href="#useMediaQuery" class="headerlink" title="useMediaQuery"></a>useMediaQuery</h3><p><code>window.matchMedia(query)</code>返回<code>MediaQueryList</code>类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MediaQueryList <span class="keyword">extends</span> EventTarget &#123; <span class="comment">// 浏览器原生类型</span></span><br><span class="line">    <span class="keyword">readonly</span> matches: <span class="built_in">boolean</span>; <span class="comment">// 是否匹配</span></span><br><span class="line">    <span class="keyword">readonly</span> media: <span class="built_in">string</span>;    <span class="comment">// 媒体查询值</span></span><br><span class="line">    onchange: (<span class="function">(<span class="params"><span class="built_in">this</span>: MediaQueryList, ev: MediaQueryListEvent</span>) =&gt;</span> <span class="built_in">any</span>) | <span class="literal">null</span>; <span class="comment">// 媒体查询改变回调</span></span><br><span class="line"><span class="comment">// 事件绑定相关...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mql: MediaQueryList = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="usePermission"><a href="#usePermission" class="headerlink" title="usePermission"></a>usePermission</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/permissions">navigator.permissions</a>可以获取用户权限（摄像头、麦克风等）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = <span class="built_in">Boolean</span>(navigator &amp;&amp; <span class="string">&#x27;permissions&#x27;</span> <span class="keyword">in</span> navigator)</span><br><span class="line"><span class="keyword">const</span> state = ref&lt;PermissionState | <span class="literal">undefined</span>&gt;() <span class="comment">// 存权限状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (permissionStatus)</span><br><span class="line">        state.value = permissionStatus.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    permissionStatus = <span class="keyword">await</span> navigator!.permissions.query(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;camera&#x27;</span> <span class="comment">// https://w3c.github.io/permissions/#enumdef-permissionname</span></span><br><span class="line">    &#125;)</span><br><span class="line">    useEventListener(permissionStatus, <span class="string">&#x27;change&#x27;</span>, onChange) <span class="comment">// 有三个状态 denied&quot; | &quot;granted&quot; | &quot;prompt&quot;</span></span><br><span class="line">    onChange()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    state.value = <span class="string">&#x27;prompt&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="usePreferredLanguages"><a href="#usePreferredLanguages" class="headerlink" title="usePreferredLanguages"></a>usePreferredLanguages</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/languages">navigator.languages</a>可以获取用户的偏好语言，可以通过<code>languagechange</code>事件监听改变</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = ref&lt;<span class="keyword">readonly</span> <span class="built_in">string</span>[]&gt;(navigator.languages)</span><br><span class="line"></span><br><span class="line">useEventListener(<span class="built_in">window</span>, <span class="string">&#x27;languagechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    value.value = navigator.languages</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="useShare"><a href="#useShare" class="headerlink" title="useShare"></a>useShare</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/share">navigator.share</a>可以进行分享</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = navigator &amp;&amp; <span class="string">&#x27;canShare&#x27;</span> <span class="keyword">in</span> navigator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSupported) &#123;</span><br><span class="line">    granted = navigator.canShare(&#123; <span class="comment">// 判断是否能被分享</span></span><br><span class="line">        title?: <span class="built_in">string</span></span><br><span class="line">        files?: File[]</span><br><span class="line">        text?: <span class="built_in">string</span></span><br><span class="line">        url?: <span class="built_in">string</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (granted)</span><br><span class="line">        <span class="keyword">return</span> navigator.share!(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useWakeLock"><a href="#useWakeLock" class="headerlink" title="useWakeLock"></a>useWakeLock</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API">Screen Wake Lock API</a>可以阻止设备变暗或锁屏</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = navigator &amp;&amp; <span class="string">&#x27;wakeLock&#x27;</span> <span class="keyword">in</span> navigator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"><span class="keyword">type</span>: WakeLockType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSupported) <span class="keyword">return</span></span><br><span class="line">    wakeLock = <span class="keyword">await</span> navigator.wakeLock.request(<span class="keyword">type</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">release</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSupported || !wakeLock) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">await</span> wakeLock.release() <span class="comment">// 释放WakeLockSentinel</span></span><br><span class="line">    wakeLock = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h2><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="createGlobalState"><a href="#createGlobalState" class="headerlink" title="createGlobalState"></a>createGlobalState</h3><blockquote><p>用来做挂组件公共状态管理</p></blockquote><p>简单的单例模式实现，<code>effectScope</code>的参数为true时，其不会被父scope收集和回收，独立存在</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createGlobalState</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  stateFactory: () =&gt; T,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">CreateGlobalStateReturn</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> initialized = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> state: T</span><br><span class="line">  <span class="keyword">const</span> scope = effectScope(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">      state = scope.run(stateFactory)!</span><br><span class="line">      initialized = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useLocalStorage"><a href="#useLocalStorage" class="headerlink" title="useLocalStorage"></a>useLocalStorage</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLocalStorage</span>&lt;<span class="title">T</span> <span class="title">extends</span>(<span class="params"><span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">boolean</span>|<span class="built_in">object</span>|<span class="literal">null</span></span>)&gt; (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialValue: MaybeRef&lt;T&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  options: StorageOptions&lt;T&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">RemovableRef</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="built_in">window</span> = defaultWindow &#125; = options</span><br><span class="line">  <span class="keyword">return</span> useStorage(key, initialValue, <span class="built_in">window</span>?.localStorage, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是用<code>useStorage</code>来实现的，<code>useSessionStorage</code>也是一样，下面我们来看看<code>useStorage</code></p><h3 id="useStorage"><a href="#useStorage" class="headerlink" title="useStorage"></a>useStorage</h3><p>在浏览器默认的Storage之上像<a href="https://github.com/marcuswestin/store.js">store.js</a>一样对数据进行预处理（序列化），否则如果存一个对象在浏览器的Storage存的会是<code>xxx.toString()</code>之后的值。但是<code>useStorage</code>比起<a href="https://github.com/marcuswestin/store.js">store.js</a>更进一步的增加了对<code>Map</code>和<code>Set</code>类型的数据的处理（<strong><code>Map</code>和<code>Set</code>存在默认的Storage和store.js都是空对象</strong>）</p><p>利用适配器模式，对每种数据类型定义<code>read</code>、<code>write</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StorageSerializers: Record&lt;<span class="string">&#x27;boolean&#x27;</span> | <span class="string">&#x27;object&#x27;</span> | <span class="string">&#x27;number&#x27;</span> | <span class="string">&#x27;any&#x27;</span> | <span class="string">&#x27;string&#x27;</span> | <span class="string">&#x27;map&#x27;</span> | <span class="string">&#x27;set&#x27;</span>, Serializer&lt;<span class="built_in">any</span>&gt;&gt; = &#123;</span><br><span class="line">  <span class="attr">boolean</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> v === <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">object</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.parse(v),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.stringify(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">number</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">Number</span>.parseFloat(v),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">any</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> v,</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">string</span>: &#123;</span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> v,</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">String</span>(v),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">map</span>: &#123; <span class="comment">// map序列化</span></span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(v)),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">Array</span>.from((v <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;).entries())),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: &#123; <span class="comment">// set序列化</span></span><br><span class="line">    <span class="attr">read</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">JSON</span>.parse(v)),</span><br><span class="line">    <span class="attr">write</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">Array</span>.from((v <span class="keyword">as</span> <span class="built_in">Set</span>&lt;<span class="built_in">any</span>&gt;).entries())),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来判断用户传入的数据类型，进行选择对应的<code>read</code>、<code>write</code>方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">type</span> = rawInit == <span class="literal">null</span></span><br><span class="line">  ? <span class="string">&#x27;any&#x27;</span></span><br><span class="line">  : rawInit <span class="keyword">instanceof</span> <span class="built_in">Set</span></span><br><span class="line">    ? <span class="string">&#x27;set&#x27;</span></span><br><span class="line">    : rawInit <span class="keyword">instanceof</span> <span class="built_in">Map</span></span><br><span class="line">      ? <span class="string">&#x27;map&#x27;</span></span><br><span class="line">      : <span class="keyword">typeof</span> rawInit === <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">        ? <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">        : <span class="keyword">typeof</span> rawInit === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">          ? <span class="string">&#x27;string&#x27;</span></span><br><span class="line">          : <span class="keyword">typeof</span> rawInit === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">            ? <span class="string">&#x27;object&#x27;</span></span><br><span class="line">            : <span class="built_in">Array</span>.isArray(rawInit) <span class="comment">// 这里不太认同，typeof [] === &#x27;object&#x27;，没必要再加这个判断了把</span></span><br><span class="line">              ? <span class="string">&#x27;object&#x27;</span></span><br><span class="line">              : !<span class="built_in">Number</span>.isNaN(rawInit)</span><br><span class="line">                ? <span class="string">&#x27;number&#x27;</span></span><br><span class="line">                : <span class="string">&#x27;any&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serializer = options.serializer ?? StorageSerializers[<span class="keyword">type</span>] <span class="comment">// 用户还可以定义自己的序列化方法，但必须具有read和write方法</span></span><br></pre></td></tr></table></figure><p>下面是对数据的初始化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rawInit: T = unref(initialValue) <span class="comment">// 用户传入的初始值</span></span><br><span class="line"><span class="keyword">const</span> data = (shallow ? shallowRef : ref)(initialValue) <span class="keyword">as</span> Ref&lt;T&gt; <span class="comment">// 用户可以配置是浅响应式还是深，最后会返回给用户</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!storage)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> rawValue = storage.getItem(key)</span><br><span class="line">    <span class="keyword">if</span> (rawValue == <span class="literal">null</span>) &#123; <span class="comment">// 如果key对应的值为空，那么是首次</span></span><br><span class="line">        data.value = rawInit <span class="comment">// 初始化值</span></span><br><span class="line">        <span class="keyword">if</span> (writeDefaults &amp;&amp; rawInit !== <span class="literal">null</span>) <span class="comment">// 用户可配置是否首次存入Storage</span></span><br><span class="line">            storage.setItem(key, serializer.write(rawInit))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        data.value = serializer.read(rawValue) <span class="comment">// 如果Storage存在对应值，序列化读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    onError(e) <span class="comment">// 用户传入的错误处理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是根据监听data的变化存入Storage，<code>watchWithFilter</code>可以看做是新增了<code>eventFilter</code>选项的<code>watch</code>，在后文会描述，也是vueuse很重要的一个特性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">watchWithFilter(</span><br><span class="line">    data,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.value == <span class="literal">null</span>)</span><br><span class="line">                storage.removeItem(key)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                storage.setItem(key, serializer.write(data.value))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            onError(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        flush, <span class="comment">// 均是用户可配置的选项</span></span><br><span class="line">        deep,</span><br><span class="line">        eventFilter,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>但仍有巨隐蔽的bug（哈哈哈)，为了支持响应式的存取Storage，用了ref类型的data，<strong>在同源下的多个标签的情况下，其中一个页面对另一个页面用<code>useStorage</code>修改了数据，但另一个页面useStorage内部的data还是原来的值</strong></p><p>解决方式：监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/StorageEvent">storage</a>事件（当页面使用的storage被其他页面修改时会触发）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">event?: StorageEvent</span>) </span>&#123; <span class="comment">// 将上面初始化值的逻辑封装为read函数</span></span><br><span class="line">    <span class="keyword">if</span> (!storage || (event &amp;&amp; event.key !== key))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rawValue = event ? event.newValue : storage.getItem(key)</span><br><span class="line"><span class="comment">// 读值省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        onError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span> &amp;&amp; listenToStorageChanges) <span class="comment">// 用户也可以配置不监听</span></span><br><span class="line">    useEventListener(<span class="built_in">window</span>, <span class="string">&#x27;storage&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> read(e), <span class="number">0</span>)) <span class="comment">// 重新读取值给data</span></span><br></pre></td></tr></table></figure><h2 id="Sensors"><a href="#Sensors" class="headerlink" title="Sensors"></a>Sensors</h2><h3 id="onClickOutside"><a href="#onClickOutside" class="headerlink" title="onClickOutside"></a>onClickOutside</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><h3 id="useRafFn"><a href="#useRafFn" class="headerlink" title="useRafFn"></a>useRafFn</h3><blockquote><p>可以暂停、恢复、获取当前状态的<code>requestAnimationFrame</code></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useRafFn</span>(<span class="params">fn: Fn, options: RafFnOptions = &#123;&#125;</span>): <span class="title">Pausable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    immediate = <span class="literal">true</span>,</span><br><span class="line">    <span class="built_in">window</span> = defaultWindow,</span><br><span class="line">  &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isActive = ref(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isActive.value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    fn()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>)</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resume</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isActive.value) &#123; <span class="comment">// 如果是非活跃状态才可以恢复</span></span><br><span class="line">      isActive.value = <span class="literal">true</span></span><br><span class="line">      loop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pause</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    isActive.value = <span class="literal">false</span> <span class="comment">// 暂停就直接设置为false，在loop中如果false则直接跳过fn执行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (immediate)</span><br><span class="line">    resume()</span><br><span class="line"></span><br><span class="line">  tryOnScopeDispose(pause)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    isActive,</span><br><span class="line">    pause,</span><br><span class="line">    resume,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留有疑问：为什么pause中不用<code>cancelAnimationFrame</code>来取消<code>requestAnimationFrame</code></p><h3 id="useTransition"><a href="#useTransition" class="headerlink" title="useTransition"></a>useTransition</h3><p><strong>可配置项</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CubicBezierPoints = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line"><span class="keyword">type</span> EasingFunction = <span class="function">(<span class="params">n: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTransition</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  source: Ref&lt;<span class="built_in">number</span> | <span class="built_in">number</span>[]&gt; | MaybeRef&lt;<span class="built_in">number</span>&gt;[],</span></span></span><br><span class="line"><span class="params"><span class="function">  options: TransitionOptions = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ComputedRef</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="comment">// 时间相关单位均为ms</span></span><br><span class="line">    delay = <span class="number">0</span>,           <span class="comment">// delay 后执行</span></span><br><span class="line">    disabled = <span class="literal">false</span>,    <span class="comment">// 是否关闭</span></span><br><span class="line">    duration = <span class="number">1000</span>,     <span class="comment">// 持续时间</span></span><br><span class="line">    onFinished = noop,   <span class="comment">// 完成后执行</span></span><br><span class="line">    onStarted = noop,    <span class="comment">// 开始时执行</span></span><br><span class="line">    transition = linear, <span class="comment">// 转化算法 MaybeRef&lt;EasingFunction | CubicBezierPoints&gt;，默认值是 x =&gt; x</span></span><br><span class="line">  &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预处理</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTransition</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  source: Ref&lt;<span class="built_in">number</span> | <span class="built_in">number</span>[]&gt; | MaybeRef&lt;<span class="built_in">number</span>&gt;[],</span></span></span><br><span class="line"><span class="params"><span class="function">  options: TransitionOptions = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ComputedRef</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 可配置项</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建当前的过渡函数，如果用户自定义了过渡函数则不做处理，否则根据贝赛尔曲线值创建过渡函数</span></span><br><span class="line">  <span class="keyword">const</span> currentTransition = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> t = unref(transition)</span><br><span class="line">    <span class="keyword">return</span> isFunction(t) ? t : createEasingFunction(t)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用unref处理source参数，如果source是数组则依次unref</span></span><br><span class="line">  <span class="keyword">const</span> sourceValue = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = unref&lt;<span class="built_in">number</span> | MaybeRef&lt;<span class="built_in">number</span>&gt;[]&gt;(source)</span><br><span class="line">    <span class="keyword">return</span> isNumber(s) ? s : s.map(unref) <span class="keyword">as</span> <span class="built_in">number</span>[]</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 规格化source，整成数组</span></span><br><span class="line">  <span class="keyword">const</span> sourceVector = computed(<span class="function">() =&gt;</span> isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建过渡函数，纯数学</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEasingFunction</span>(<span class="params">[p0, p1, p2, p3]: CubicBezierPoints</span>): <span class="title">EasingFunction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="function">(<span class="params">a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">1</span> - <span class="number">3</span> * a2 + <span class="number">3</span> * a1</span><br><span class="line">  <span class="keyword">const</span> b = <span class="function">(<span class="params">a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">3</span> * a2 - <span class="number">6</span> * a1</span><br><span class="line">  <span class="keyword">const</span> c = <span class="function">(<span class="params">a1: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">3</span> * a1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> calcBezier = <span class="function">(<span class="params">t: <span class="built_in">number</span>, a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getSlope = <span class="function">(<span class="params">t: <span class="built_in">number</span>, a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">3</span> * a(a1, a2) * t * t + <span class="number">2</span> * b(a1, a2) * t + c(a1)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getTforX = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> aGuessT = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> currentSlope = getSlope(aGuessT, p0, p2)</span><br><span class="line">      <span class="keyword">if</span> (currentSlope === <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> aGuessT</span><br><span class="line">      <span class="keyword">const</span> currentX = calcBezier(aGuessT, p0, p2) - x</span><br><span class="line">      aGuessT -= currentX / currentSlope</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aGuessT</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> p0 === p1 &amp;&amp; p2 === p3 ? x : calcBezier(getTforX(x), p1, p3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了几种过渡预设</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TransitionPresets: Record&lt;<span class="built_in">string</span>, CubicBezierPoints | EasingFunction&gt; = &#123;</span><br><span class="line">  <span class="attr">easeInSine</span>: [<span class="number">0.12</span>, <span class="number">0</span>, <span class="number">0.39</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">easeOutSine</span>: [<span class="number">0.61</span>, <span class="number">1</span>, <span class="number">0.88</span>, <span class="number">1</span>],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可以看 <a href="https://easings.net/cn#">缓动函数</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#easing_functions">MDN：缓动函数</a></p><p><strong>关键逻辑</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> outputVector = ref(sourceVector.value.slice(<span class="number">0</span>)) <span class="comment">// 用以存储输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过渡主流程，可以暂停</span></span><br><span class="line"><span class="keyword">const</span> &#123; resume, pause &#125; = useRafFn(<span class="function">() =&gt;</span> &#123; <span class="comment">// 可以暂停、恢复的 requestAnimationFrame</span></span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">const</span> progress = clamp(<span class="number">1</span> - ((endAt - now) / currentDuration), <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// 过渡进度，clamp将值限制在0-1之间</span></span><br><span class="line"></span><br><span class="line">  outputVector.value = startVector.map(<span class="function">(<span class="params">val, i</span>) =&gt;</span> val + ((diffVector[i] ?? <span class="number">0</span>) * currentTransition.value(progress))) <span class="comment">// 更新output</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (progress &gt;= <span class="number">1</span>) &#123; <span class="comment">// 完成过渡</span></span><br><span class="line">    pause() <span class="comment">// 暂停 requestAnimationFrame</span></span><br><span class="line">    onFinished() <span class="comment">// 执行options中的完成回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">immediate</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = useTimeoutFn(start, delay, &#123; <span class="attr">immediate</span>: <span class="literal">false</span> &#125;) <span class="comment">// delay毫秒后执行start函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  pause() <span class="comment">// 暂停 过渡</span></span><br><span class="line"></span><br><span class="line">  currentDuration = unref(duration)</span><br><span class="line">  diffVector = outputVector.value.map(<span class="function">(<span class="params">n, i</span>) =&gt;</span> (sourceVector.value[i] ?? <span class="number">0</span>) - (outputVector.value[i] ?? <span class="number">0</span>)) <span class="comment">// 初始值和当前值的diff</span></span><br><span class="line">  startVector = outputVector.value.slice(<span class="number">0</span>) <span class="comment">// 拷贝初始值</span></span><br><span class="line">  startAt = <span class="built_in">Date</span>.now() <span class="comment">// 开始时间</span></span><br><span class="line">  endAt = startAt + currentDuration <span class="comment">// 结束时间，用在计算progress</span></span><br><span class="line"></span><br><span class="line">  resume() <span class="comment">// 开始过渡</span></span><br><span class="line">  onStarted() <span class="comment">// 执行options中的开始回调</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch(sourceVector, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听sourceVector的变化</span></span><br><span class="line">  <span class="keyword">if</span> (unref(disabled)) &#123; <span class="comment">// 如果暂停过渡，将输出还原回初始值</span></span><br><span class="line">    outputVector.value = sourceVector.value.slice(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (unref(delay) &lt;= <span class="number">0</span>) start() <span class="comment">// 如果没有延迟，则开始过渡</span></span><br><span class="line">    <span class="keyword">else</span> timeout.start() <span class="comment">// 如果有延迟，则开始上面创建好的timeout</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> targetVector = unref(disabled) ? sourceVector : outputVector <span class="comment">// 如果暂停过渡，将输出还原回初始值</span></span><br><span class="line">  <span class="keyword">return</span> isNumber(sourceValue.value) ? targetVector.value[<span class="number">0</span>] : targetVector.value <span class="comment">// 为值解开数组包装，数组原样返回</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文不会放api的用法，建议先看看是怎么用的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目架构&quot;&gt;&lt;a href=&quot;#项目架构&quot; class=&quot;headerlink&quot; title=&quot;项目架构&quot;&gt;&lt;/a&gt;项目架构&lt;/h2&gt;&lt;p&gt;采用monorepo的形式，项目目录下有多个子项目，下面放了资料链接和几处用法，其他本文不多赘述。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6944877410827370504&quot;&gt;现代前端工程为什么越来越离不开 Monorepo?&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.codeleading.com/article/46915806308/&quot;&gt;为什么使用pnpm可以光速建立好用的monorepo（比yarn/lerna效率高）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://pnpm.io/zh/workspaces&quot;&gt;pnpm workspace文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="vue" scheme="https://liang5757.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>【源码解读】模块懒加载(在使用时)</title>
    <link href="https://liang5757.github.io/2021/09/23/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E5%9D%97%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://liang5757.github.io/2021/09/23/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E5%9D%97%E6%87%92%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-09-23T15:53:24.000Z</published>
    <updated>2023-04-18T16:54:30.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在看为什么vue文档能做到<strong>新内容可用更新</strong>（利用service worker）的时候，顺便看到了<a href="https://github.com/yeoman/update-notifier">update-notifier</a>（提示版本更新的库，实现方式：定时检查npm上的版本和本地package.json的版本对比，有差异就提示用户更新），看<code>update-notifier</code>源码的时候发现有很多<a href="https://github.com/sindresorhus/import-lazy">lazyImport</a>，觉得挺新奇，于是有了这篇文章</p></blockquote><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>为了提高应用的启动时间，在没有用到仓库的额外功能时不加载模块，所以将模块加载延迟到使用之前</p><a id="more"></a><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> importLazy = <span class="built_in">require</span>(<span class="string">&#x27;import-lazy&#x27;</span>)(<span class="built_in">require</span>);</span><br><span class="line"><span class="keyword">const</span> _ = importLazy(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line">_.isNumber(<span class="number">2</span>); <span class="comment">// 在使用的时候才触发模块加载</span></span><br></pre></td></tr></table></figure><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>实际上是用proxy代理了get操作，在get的时候才触发模块加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lazy = <span class="function">(<span class="params">importedModule, importFn, moduleId</span>) =&gt;</span></span><br><span class="line">importedModule === <span class="literal">undefined</span> ? importFn(moduleId) : importedModule;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">importFn</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">moduleId</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> importedModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"><span class="attr">get</span>: <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">importedModule = lazy(importedModule, importFn, moduleId);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.get(importedModule, property);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">apply</span>: <span class="function">(<span class="params">target, thisArgument, argumentsList</span>) =&gt;</span> &#123;</span><br><span class="line">importedModule = lazy(importedModule, importFn, moduleId);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(importedModule, thisArgument, argumentsList);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">construct</span>: <span class="function">(<span class="params">target, argumentsList</span>) =&gt;</span> &#123;</span><br><span class="line">importedModule = lazy(importedModule, importFn, moduleId);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(importedModule, argumentsList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eslint-disable-next-line prefer-arrow-callback</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, handler);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这也导致我们在使用import-lazy的时候不能按需加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;isNumber, isString&#125; = importLazy(<span class="string">&#x27;lodash&#x27;</span>); <span class="comment">// 不支持</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在看为什么vue文档能做到&lt;strong&gt;新内容可用更新&lt;/strong&gt;（利用service worker）的时候，顺便看到了&lt;a href=&quot;https://github.com/yeoman/update-notifier&quot;&gt;update-notifier&lt;/a&gt;（提示版本更新的库，实现方式：定时检查npm上的版本和本地package.json的版本对比，有差异就提示用户更新），看&lt;code&gt;update-notifier&lt;/code&gt;源码的时候发现有很多&lt;a href=&quot;https://github.com/sindresorhus/import-lazy&quot;&gt;lazyImport&lt;/a&gt;，觉得挺新奇，于是有了这篇文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h2&gt;&lt;p&gt;为了提高应用的启动时间，在没有用到仓库的额外功能时不加载模块，所以将模块加载延迟到使用之前&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>跨平台的拖拽</title>
    <link href="https://liang5757.github.io/2021/09/12/Js/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8B%96%E6%8B%BD/"/>
    <id>https://liang5757.github.io/2021/09/12/Js/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8B%96%E6%8B%BD/</id>
    <published>2021-09-12T08:46:27.000Z</published>
    <updated>2021-12-23T16:13:49.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://liang5757.github.io/2021/04/06/Js/crossvent%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">crossvent</a>：封装跨平台事件绑定的库</p></blockquote><h2 id="跨平台的触摸事件"><a href="#跨平台的触摸事件" class="headerlink" title="跨平台的触摸事件"></a>跨平台的触摸事件</h2><p>利用<code>crossvent</code>封装绑定<strong>跨平台拖拽事件</strong>的方法<code>touchy</code>，以便支持移动端和pc端</p><p>根据环境获取的触摸事件名，<strong>用懒加载的方式替换掉touchy函数，之后绑定事件不需要再判断</strong></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add <span class="keyword">as</span> addEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;crossvent&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> touchy = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> touch = &#123;</span><br><span class="line">        <span class="attr">mouseup</span>: <span class="string">&#x27;touchend&#x27;</span>,</span><br><span class="line">        <span class="attr">mousedown</span>: <span class="string">&#x27;touchstart&#x27;</span>,</span><br><span class="line">        <span class="attr">mousemove</span>: <span class="string">&#x27;touchmove&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> pointers = &#123;</span><br><span class="line">        <span class="attr">mouseup</span>: <span class="string">&#x27;pointerup&#x27;</span>,</span><br><span class="line">        <span class="attr">mousedown</span>: <span class="string">&#x27;pointerdown&#x27;</span>,</span><br><span class="line">        <span class="attr">mousemove</span>: <span class="string">&#x27;pointermove&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> microsoft = &#123;</span><br><span class="line">        <span class="attr">mouseup</span>: <span class="string">&#x27;MSPointerUp&#x27;</span>,</span><br><span class="line">        <span class="attr">mousedown</span>: <span class="string">&#x27;MSPointerDown&#x27;</span>,</span><br><span class="line">        <span class="attr">mousemove</span>: <span class="string">&#x27;MSPointerMove&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.navigator.pointerEnabled) &#123;</span><br><span class="line">        touchy = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">            addEvent(el, pointers[type], fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.navigator.msPointerEnabled) &#123;</span><br><span class="line">        touchy = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">            addEvent(el, microsoft[type], fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        touchy = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">            addEvent(el, touch[type], fn);</span><br><span class="line">            addEvent(el, type, fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    touchy(el, type, fn);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> documentElement = <span class="built_in">document</span>.documentElement;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draggable</span> (<span class="params">dom</span>) </span>&#123;</span><br><span class="line">    initEvents();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        touchy(dom, <span class="string">&#x27;mousedown&#x27;</span>, mousedown);</span><br><span class="line">        touchy(documentElement, <span class="string">&#x27;mousemove&#x27;</span>, mousemove);</span><br><span class="line">        touchy(documentElement, <span class="string">&#x27;mouseup&#x27;</span>, mouseup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在<code>documentElement</code>上绑定<code>mousemove</code>和<code>mouseup</code>事件，是<strong>因为避免渲染速度低于拖拽速度，导致鼠标超出拖拽范围而无法拖拽和释放</strong></p><p>这里提一下绑定事件时有一个<code>passive</code>选项，具体可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#使用_passive_改善的滚屏性能">使用 passive 改善的滚屏性能</a>，可以设置为<code>false</code>，使事件回调可以使用<code>e.preventDefault</code>禁用默认的行为</p><h2 id="mousedown"><a href="#mousedown" class="headerlink" title="mousedown"></a>mousedown</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousedown</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    active = <span class="literal">true</span>;</span><br><span class="line">    e = getEventHost(e);</span><br><span class="line">    _moveX = e.clientX;</span><br><span class="line">    _moveY = e.clientY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>documentElement</code>上绑定<code>mousemove</code>和<code>mouseup</code>事件，所以需要标记是否是处于拖拽状态，然后<code>mousemove</code>和<code>mouseup</code>中判断如果不是拖拽状态则跳出函数。</p><p>为了适配移动端（<code>touchEvent</code>没有<code>clientX</code>、<code>clientY</code>、<code>x</code>、<code>y</code>），引出了<code>getEventHost</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEventHost</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.targetTouches &amp;&amp; e.targetTouches.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.targetTouches[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.changedTouches &amp;&amp; e.changedTouches.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.changedTouches[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看touch、targetTouches、changedTouches的定义</p><ul><li><strong>touches: 当前屏幕上所有触摸点的列表</strong></li><li><strong>targetTouches: 当前对象上所有触摸点的列表</strong></li><li><strong>changedTouches: 涉及当前(引发)事件的触摸点的列表</strong></li></ul><h2 id="mousemove"><a href="#mousemove" class="headerlink" title="mousemove"></a>mousemove</h2><p>这里实现的是可拖拽范围为<code>document</code>的可视区域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousemove</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123; <span class="comment">// 如果不是出于拖拽状态直接放回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = getEventHost(e);</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y, height, width &#125; = dom.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">const</span> curLeft = x + e.clientX - _moveX;</span><br><span class="line">    <span class="keyword">const</span> curTop = y + e.clientY - _moveY;</span><br><span class="line"></span><br><span class="line">    dom.style.left = <span class="string">`<span class="subst">$&#123;clamp(curLeft, <span class="number">0</span>, documentElement.clientWidth - width - <span class="number">1</span>)&#125;</span>px`</span>;</span><br><span class="line">    dom.style.top = <span class="string">`<span class="subst">$&#123;clamp(curTop, <span class="number">0</span>, documentElement.clientHeight - height)&#125;</span>px`</span>;</span><br><span class="line">    _moveX = e.clientX;</span><br><span class="line">    _moveY = e.clientY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将value限制在[min, max]之间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clamp</span> (<span class="params">value, min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(value, min), max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mouseup"><a href="#mouseup" class="headerlink" title="mouseup"></a>mouseup</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mouseup</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以自定义mousemove的行为，但整体的框架不会变</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://liang5757.github.io/2021/04/06/Js/crossvent%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/&quot;&gt;crossvent&lt;/a&gt;：封装跨平台事件绑定的库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;跨平台的触摸事件&quot;&gt;&lt;a href=&quot;#跨平台的触摸事件&quot; class=&quot;headerlink&quot; title=&quot;跨平台的触摸事件&quot;&gt;&lt;/a&gt;跨平台的触摸事件&lt;/h2&gt;&lt;p&gt;利用&lt;code&gt;crossvent&lt;/code&gt;封装绑定&lt;strong&gt;跨平台拖拽事件&lt;/strong&gt;的方法&lt;code&gt;touchy&lt;/code&gt;，以便支持移动端和pc端&lt;/p&gt;
&lt;p&gt;根据环境获取的触摸事件名，&lt;strong&gt;用懒加载的方式替换掉touchy函数，之后绑定事件不需要再判断&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【源码解读】Axios源码解析</title>
    <link href="https://liang5757.github.io/2021/08/25/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://liang5757.github.io/2021/08/25/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2021-08-24T17:20:56.000Z</published>
    <updated>2023-04-18T16:54:34.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(thisArg, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">a, b, thisArg</span>) </span>&#123;</span><br><span class="line">  forEach(b, <span class="function"><span class="keyword">function</span> <span class="title">assignValue</span>(<span class="params">val, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thisArg &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      a[key] = bind(val, thisArg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params"><span class="comment">/* obj1, obj2, obj3, ... */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">assignValue</span>(<span class="params">val, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(result[key]) &amp;&amp; isPlainObject(val)) &#123;</span><br><span class="line">      result[key] = merge(result[key], val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(val)) &#123;</span><br><span class="line">      result[key] = merge(&#123;&#125;, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(val)) &#123;</span><br><span class="line">      result[key] = val.slice();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">    forEach(<span class="built_in">arguments</span>[i], assignValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从使用方式看起"><a href="#从使用方式看起" class="headerlink" title="从使用方式看起"></a>从使用方式看起</h2><p>对几种调用方式做了编号</p><ol><li><code>axios(option)</code></li><li><code>axios(url[, option])</code></li><li><code>axios[method](url[, option])</code>（<code>get、delete</code>等方法）</li><li><code>axios[method](url[, data[, option]])</code>（<code>post、put</code>等方法）</li><li><code>axios.request(option)</code></li></ol><p>让我们看看源码他是怎么做到能够支持这么多调用方式的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/axios.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> Axios(defaultConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等同于 Axios.prototype.request.bind(context)</span></span><br><span class="line">  <span class="comment">// request方法中对第一个参数是否为 string 做了判断，使支持1、2种调用方式</span></span><br><span class="line">  <span class="keyword">var</span> instance = bind(Axios.prototype.request, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把Axios.prototype上的方法扩展到instance对象上，</span></span><br><span class="line">  <span class="comment">// 这样 instance 就有了 get、post、put、request等方法，使支持3、4、5调用方式</span></span><br><span class="line">  <span class="comment">// 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context</span></span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把context对象上的自身属性和方法扩展到instance上</span></span><br><span class="line">  <span class="comment">// 这样，instance 就有了 defaults、interceptors 属性。（这两个属性后面我们会介绍）</span></span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收默认配置项作为参数（后面会介绍配置项），创建一个Axios实例，最终会被作为对象导出</span></span><br><span class="line"><span class="keyword">var</span> axios = createInstance(defaults);</span><br></pre></td></tr></table></figure><p>主要是为了能够做到1、2种调用方式，所以是返回request函数，并在其上挂载Axios实例的方法</p><p>接下来看看上述代码操作的主体：Axios、Axios.prototype.request 以及 Axios.prototype上的请求方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /lib/core/Axios.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.defaults = instanceConfig;</span><br><span class="line">  <span class="built_in">this</span>.interceptors = &#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    <span class="attr">response</span>: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> config === <span class="string">&#x27;string&#x27;</span>) &#123; <span class="comment">// 使支持1、2两种调用方式</span></span><br><span class="line">    config = <span class="built_in">arguments</span>[<span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">    config.url = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    config = config || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide aliases for supported request methods</span></span><br><span class="line">utils.forEach([<span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodNoData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;</span><br><span class="line">      <span class="attr">method</span>: method,</span><br><span class="line">      <span class="attr">url</span>: url,</span><br><span class="line">      <span class="attr">data</span>: (config || &#123;&#125;).data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.forEach([<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodWithData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, data, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;</span><br><span class="line">      <span class="attr">method</span>: method,</span><br><span class="line">      <span class="attr">url</span>: url,</span><br><span class="line">      <span class="attr">data</span>: data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结合上面<code>createInstance</code>的代码，我们可以看到为什么我们可以使用多种方式调用axios</p><p>我们先不看具体请求逻辑是怎么实现的，先看看拦截器是怎么做到在请求前后预处理的。</p><h2 id="拦截器（interceptor）"><a href="#拦截器（interceptor）" class="headerlink" title="拦截器（interceptor）"></a>拦截器（interceptor）</h2><p>在上文<code>Axios</code>的构造器中我们可以看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.interceptors = &#123;</span><br><span class="line">  <span class="attr">request</span>: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">  <span class="attr">response</span>: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>InterceptorManager</code>类用以管理拦截器</p><h3 id="InterceptorManager类"><a href="#InterceptorManager类" class="headerlink" title="InterceptorManager类"></a>InterceptorManager类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InterceptorManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.handlers = []; <span class="comment">// 存储拦截器函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用以添加拦截器</span></span><br><span class="line">InterceptorManager.prototype.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fulfilled, rejected, options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.handlers.push(&#123;</span><br><span class="line">    <span class="attr">fulfilled</span>: fulfilled,</span><br><span class="line">    <span class="attr">rejected</span>: rejected,</span><br><span class="line">    <span class="attr">synchronous</span>: options ? options.synchronous : <span class="literal">false</span>, <span class="comment">// 是否是同步执行</span></span><br><span class="line">    <span class="attr">runWhen</span>: options ? options.runWhen : <span class="literal">null</span> <span class="comment">// 指定拦截器在某种情况下执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.handlers.length - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除拦截器</span></span><br><span class="line">InterceptorManager.prototype.eject = <span class="function"><span class="keyword">function</span> <span class="title">eject</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.handlers[id]) &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlers[id] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将handler的每一项交由fn处理</span></span><br><span class="line">InterceptorManager.prototype.forEach = <span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  utils.forEach(<span class="built_in">this</span>.handlers, <span class="function"><span class="keyword">function</span> <span class="title">forEachHandler</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h !== <span class="literal">null</span>) &#123;</span><br><span class="line">      fn(h);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="request中InterceptorManager使用方式"><a href="#request中InterceptorManager使用方式" class="headerlink" title="request中InterceptorManager使用方式"></a>request中InterceptorManager使用方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里有合并 config 的操作，优先级是 defaults -&gt; &#123; method: &quot;get&quot; &#125; -&gt; this.defaults -&gt; config</span></span><br><span class="line">    <span class="comment">// 也就是 库默认的配置 -&gt; 默认为get请求 -&gt; 创建Axios实例设置的配置 -&gt; 请求的配置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> requestInterceptorChain = []; <span class="comment">// 请求拦截器链</span></span><br><span class="line">    <span class="built_in">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 无法通过runWhen条件的则不执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> interceptor.runWhen === <span class="string">&#x27;function&#x27;</span> &amp;&amp; interceptor.runWhen(config) === <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 fulfilled、rejected 成对unshift到 requestInterceptorChain</span></span><br><span class="line">        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> responseInterceptorChain = []; <span class="comment">// 响应拦截器链</span></span><br><span class="line">    <span class="built_in">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 以 fulfilled、rejected 成对unshift到 responseInterceptorChain</span></span><br><span class="line">        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> promise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatchRequest是发送请求，第二个undefined是为了符合提取方式的占位值</span></span><br><span class="line">    <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 请求拦截器 放置在dispatchRequest前面 </span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.unshift.apply(chain, requestInterceptorChain);</span><br><span class="line">    <span class="comment">// 将 响应拦截器 放置在dispatchRequest后面</span></span><br><span class="line">    chain.concat(responseInterceptorChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过此方式将config传入到请求拦截器的第一个fulfilled</span></span><br><span class="line">    promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">        <span class="comment">// 因为在chain中fulfilled、rejected是成对存在的</span></span><br><span class="line">        <span class="comment">// 而 请求拦截器 必须返回config，下一个 请求拦截器 就会接受上一个config</span></span><br><span class="line">        <span class="comment">// 响应拦截器 会接受 dispatchRequest 的响应体或错误</span></span><br><span class="line">        promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程就是如此</p><h3 id="synchronous"><a href="#synchronous" class="headerlink" title="synchronous"></a>synchronous</h3><p>但是axios还为<strong>请求拦截器</strong>提供了<code>synchronous</code>选项，需要<strong>全部</strong>请求拦截器设置<code>synchronous</code>为true，那么就以同步的方式运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> requestInterceptorChain = [];</span><br><span class="line">  <span class="comment">// 新增：用以标记是否是同步执行请求拦截器</span></span><br><span class="line">  <span class="keyword">var</span> synchronousRequestInterceptors = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> interceptor.runWhen === <span class="string">&#x27;function&#x27;</span> &amp;&amp; interceptor.runWhen(config) === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 新增：需要 全部请求拦截器 设置synchronous成true才会同步执行</span></span><br><span class="line">    synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous;</span><br><span class="line"></span><br><span class="line">    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> responseInterceptorChain = [];</span><br><span class="line">  <span class="built_in">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> promise;</span><br><span class="line">  <span class="comment">// 新增：默认是异步的方式执行</span></span><br><span class="line">  <span class="keyword">if</span> (!synchronousRequestInterceptors) &#123;</span><br><span class="line">    <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.prototype.unshift.apply(chain, requestInterceptorChain);</span><br><span class="line">    chain.concat(responseInterceptorChain);</span><br><span class="line"></span><br><span class="line">    promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">      promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增：同步的方式执行请求拦截器</span></span><br><span class="line">  <span class="keyword">var</span> newConfig = config;</span><br><span class="line">  <span class="keyword">while</span> (requestInterceptorChain.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> onFulfilled = requestInterceptorChain.shift();</span><br><span class="line">    <span class="keyword">var</span> onRejected = requestInterceptorChain.shift();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      newConfig = onFulfilled(newConfig);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      onRejected(error);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    promise = dispatchRequest(newConfig);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (responseInterceptorChain.length) &#123;</span><br><span class="line">    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="启发：链式调用"><a href="#启发：链式调用" class="headerlink" title="启发：链式调用"></a>启发：链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Man(<span class="string">&quot;Hank&quot;</span>).sleep(<span class="number">1</span>).eat(<span class="string">&quot;supper&quot;</span>).sleep(<span class="number">1</span>).eat(<span class="string">&quot;me&quot;</span>).sleepFirst(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// &#x27;This is Hank&#x27; -(等待2s)--&gt; &#x27;Wale up after 2&#x27; -(等待1s)--&gt; &#x27;Wale up after 1&#x27; &#x27;Eat supper&#x27; -(等待1s)--&gt; &#x27;Eat me&#x27;</span></span><br></pre></td></tr></table></figure><p>写法放在文末</p><h2 id="发起请求dispatchRequest"><a href="#发起请求dispatchRequest" class="headerlink" title="发起请求dispatchRequest"></a>发起请求dispatchRequest</h2><p>在拿到请求拦截器处理后的config后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /lib/core/dispatchRequest.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.请求如果被取消则 throw cancel Error</span></span><br><span class="line">  throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.确保headers存在</span></span><br><span class="line">  config.headers = config.headers || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.后面会讲：数据转化器转化请求data，也可以在config自定义配置transformRequest</span></span><br><span class="line">  config.data = transformData.call(</span><br><span class="line">    config,</span><br><span class="line">    config.data,</span><br><span class="line">    config.headers,</span><br><span class="line">    config.transformRequest</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.扁平header设置，这里可以利用config.headers.get = &#123;&#125;设置某种请求类型的headers</span></span><br><span class="line">  config.headers = utils.merge(</span><br><span class="line">    config.headers.common || &#123;&#125;,</span><br><span class="line">    config.headers[config.method] || &#123;&#125;,</span><br><span class="line">    config.headers</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.删除无用header，因为在第四步时扁平化定义在headers了</span></span><br><span class="line">  utils.forEach(</span><br><span class="line">    [<span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;common&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cleanHeaderConfig</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">delete</span> config.headers[method];</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以自定义适配器，默认为XHR（web）或http（node）适配器</span></span><br><span class="line">  <span class="keyword">var</span> adapter = config.adapter || defaults.adapter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">onAdapterRejection</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfCancellationRequested</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">    config.cancelToken.throwIfRequested();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨端实现（adapter）"><a href="#跨端实现（adapter）" class="headerlink" title="跨端实现（adapter）"></a>跨端实现（adapter）</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul><li>是否有<code>XMLHttpRequest</code>对象来判断是否是web环境</li><li>是否有<code>process</code>对象来判断node环境</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /lib/defaults.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultAdapter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adapter;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/xhr&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(process) === <span class="string">&#x27;[object process]&#x27;</span>) &#123;</span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/http&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装xhr"><a href="#封装xhr" class="headerlink" title="封装xhr"></a>封装xhr</h3><p>返回一个promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /lib/adapters/xhr.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchXhrRequest</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">var</span> fullPath = buildFullPath(config.baseURL, config.url);</span><br><span class="line">    <span class="comment">// buildURL: 格式化url; config.paramsSerializer: 序列化方式；</span></span><br><span class="line">    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), <span class="literal">true</span>);</span><br><span class="line">    request.timeout = config.timeout;</span><br><span class="line">      </span><br><span class="line">    request.onloadend = <span class="function"><span class="keyword">function</span> <span class="title">onloadend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      settle(resolve, reject, response); <span class="comment">// 下面有代码</span></span><br><span class="line">      request = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.onabort = <span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="comment">/**/</span>);</span><br><span class="line">      request = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="comment">/**/</span>);</span><br><span class="line">      request = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">request.ontimeout = <span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="comment">/**/</span>);</span><br><span class="line">  request = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">    request.send(requestData);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>验证服务端的返回结果是否通过验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /lib/core/settle.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">settle</span>(<span class="params">resolve, reject, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> validateStatus = response.config.validateStatus; <span class="comment">// 可以自定义成功规则</span></span><br><span class="line">  <span class="keyword">if</span> (!response.status || !validateStatus || validateStatus(response.status)) &#123;</span><br><span class="line">    resolve(response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="comment">/**/</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理将http封装成promise</p><h2 id="取消请求（cancelToken）"><a href="#取消请求（cancelToken）" class="headerlink" title="取消请求（cancelToken）"></a>取消请求（cancelToken）</h2><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种取消方法</span></span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="params">cancel</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 取消条件 */</span>) &#123;</span><br><span class="line">      cancel(<span class="string">&#x27;取消日志&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种取消方法</span></span><br><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.token</span><br><span class="line">&#125;);</span><br><span class="line">source.cancel(<span class="string">&#x27;取消日志&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;executor must be a function.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resolvePromise;</span><br><span class="line">  <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">promiseExecutor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolvePromise = resolve;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> token = <span class="built_in">this</span>;</span><br><span class="line">  executor(<span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">message</span>) </span>&#123; <span class="comment">// 等到executor调用cancel方法，上面的this.promise就会执行下面的then回调</span></span><br><span class="line">    <span class="keyword">if</span> (token.reason) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token.reason = <span class="keyword">new</span> Cancel(message);</span><br><span class="line">    resolvePromise(token.reason); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法的实现</span></span><br><span class="line">CancelToken.source = <span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cancel;</span><br><span class="line">  <span class="keyword">var</span> token = <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">token</span>: token,</span><br><span class="line">    <span class="attr">cancel</span>: cancel</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /lib/adapters/xhr.js 在send之前执行</span></span><br><span class="line"><span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">  config.cancelToken.promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onCanceled</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    request.abort(); <span class="comment">// xhr的取消请求</span></span><br><span class="line">    reject(cancel);</span><br><span class="line">    request = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.arr = [];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> executor = <span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="built_in">this</span>.arr.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr[i]().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(value);</span><br><span class="line">          executor(i + <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">      executor(<span class="number">0</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">sleep</span>(<span class="params">sec</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.arr.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">`Wale up after <span class="subst">$&#123;sec&#125;</span>`</span>);</span><br><span class="line">        &#125;, sec * <span class="number">1000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params">food</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.arr.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">`Eat <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">sleepFirst</span>(<span class="params">sec</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.arr.unshift(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">`Wale up after <span class="subst">$&#123;sec&#125;</span>`</span>);</span><br><span class="line">        &#125;, sec * <span class="number">1000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ronffy/axios-tutoria">Axios源码深度剖析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工具类&quot;&gt;&lt;a href=&quot;#工具类&quot; class=&quot;headerlink&quot; title=&quot;工具类&quot;&gt;&lt;/a&gt;工具类&lt;/h2&gt;&lt;h3 id=&quot;bind&quot;&gt;&lt;a href=&quot;#bind&quot; class=&quot;headerlink&quot; title=&quot;bind&quot;&gt;&lt;/a&gt;bind&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn, thisArg&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; args = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; args.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      args[i] = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fn.apply(thisArg, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>egg入门</title>
    <link href="https://liang5757.github.io/2021/07/18/node.js/egg%E5%85%A5%E9%97%A8/"/>
    <id>https://liang5757.github.io/2021/07/18/node.js/egg%E5%85%A5%E9%97%A8/</id>
    <published>2021-07-18T15:28:05.000Z</published>
    <updated>2021-12-23T16:15:48.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速初始化"><a href="#快速初始化" class="headerlink" title="快速初始化"></a>快速初始化</h2><p>用npm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init egg --<span class="built_in">type</span>=simple</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选) # 用于自定义启动时的初始化工作</span><br><span class="line">├── agent.js (可选) # 用于自定义启动时的初始化工作</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js  # 用于配置 URL 路由规则</span><br><span class="line">│   ├── controller  # 用于解析用户的输入，处理后返回相应的结果</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选) # 用于编写业务逻辑层</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选) # 用于编写中间件</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)# 用于定时任务</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选) # 用于放置静态资源</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)# 用于放置模板文件</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选) # 用于框架的扩展</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config # 用于编写配置文件</span><br><span class="line">|   ├── plugin.js  # 用于配置需要加载的插件</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── test # 用于单元测试</span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure><h2 id="路由（Router）"><a href="#路由（Router）" class="headerlink" title="路由（Router）"></a>路由（Router）</h2><blockquote><p>将用户的请求基于 method 和 URL 分发到了对应的 Controller 上，感觉api和Koa差不多。</p></blockquote><h3 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h3><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>就列一个query参数的获取，需要注意的是，app.controller.search与文件相对应（也就是app/controller/search.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// curl http://127.0.0.1:7001/search?name=egg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.get(<span class="string">&#x27;/search&#x27;</span>, app.controller.search.index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/controller/search.js</span></span><br><span class="line"><span class="built_in">exports</span>.index = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`search: <span class="subst">$&#123;ctx.query.name&#125;</span>`</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>为了避免用户恶意传递重复key的query参数导致系统报错，ctx.query只取第一次出现的值，并且保证一定是字符串类型</strong></p><p>如果必须要重复的key，比如需要传递数组：id=1&amp;id=2&amp;id=3，可以用<code>ctx.queries</code>，其也保证了一定是数组类型</p><h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p>框架内置了 <a href="https://github.com/koajs/bodyparser">bodyParser</a> 中间件来对JSON和Form-Data的请求 body 解析成 object 挂载到 <code>ctx.request.body</code> 上。</p><p>body 最大长度为 <code>100kb</code>，超出长度413状态码，可以在 <code>config/config.default.js</code> 中覆盖框架的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">bodyParser</span>: &#123;</span><br><span class="line">    <span class="attr">jsonLimit</span>: <span class="string">&#x27;1mb&#x27;</span>,</span><br><span class="line">    <span class="attr">formLimit</span>: <span class="string">&#x27;1mb&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ctx.body是ctx.response.body的简写</p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>可以通过<code>ctx.get(name)</code>获取，其会自动处理大小写</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>获取、设置方式和Koa一样，配置方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">cookies</span>: &#123;</span><br><span class="line">    <span class="comment">// httpOnly: true | false,</span></span><br><span class="line">    <span class="comment">// sameSite: &#x27;none|lax|strict&#x27;,</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>框架内置 <a href="https://github.com/eggjs/egg-session">Session</a> 插件，可以通过<code>ctx.session</code>，具体配置可以看 <a href="https://eggjs.org/zh-cn/core/cookie-and-session.html#session">Cookie 与 Session</a></p><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>借助 <a href="https://github.com/eggjs/egg-validate">Validate</a> 插件提供便捷的参数校验机制，配置方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/plugin.js</span></span><br><span class="line"><span class="built_in">exports</span>.validate = &#123;</span><br><span class="line">  <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">package</span>: <span class="string">&#x27;egg-validate&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ctx上有一个validate方法，可以传入校验配置来对参数进行校验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// curl -X POST http://127.0.0.1:7001/user --data &#x27;username=abc@abc.com&amp;password=111111&amp;re-password=111111&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.post(<span class="string">&#x27;/user&#x27;</span>, app.controller.user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/controller/user.js</span></span><br><span class="line"><span class="keyword">const</span> createRule = &#123;</span><br><span class="line">  <span class="attr">username</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;email&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">    <span class="attr">compare</span>: <span class="string">&#x27;re-password&#x27;</span>, <span class="comment">// 与re-password比较，是否一致</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.create = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果校验报错，会抛出异常</span></span><br><span class="line">  ctx.validate(createRule);</span><br><span class="line">  ctx.body = ctx.request.body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="内部重定向"><a href="#内部重定向" class="headerlink" title="内部重定向"></a>内部重定向</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.redirect(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/home/index&#x27;</span>, <span class="number">302</span>);</span><br></pre></td></tr></table></figure><h4 id="外部重定向"><a href="#外部重定向" class="headerlink" title="外部重定向"></a>外部重定向</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.redirect(<span class="string">`http://cn.bing.com`</span>);</span><br></pre></td></tr></table></figure><h3 id="resources生成CRUD路由结构"><a href="#resources生成CRUD路由结构" class="headerlink" title="resources生成CRUD路由结构"></a>resources生成CRUD路由结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">    router.resources(<span class="string">&#x27;posts&#x27;</span>, <span class="string">&#x27;/api/posts&#x27;</span>, controller.posts);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来在对应文件下实现对应函数就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/controller/posts.js</span></span><br><span class="line"><span class="built_in">exports</span>.index = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.new = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.create = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.show = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.edit = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.update = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.destroy = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Method</th><th>Path</th><th>Route Name</th><th>Controller.Action</th></tr></thead><tbody><tr><td>GET</td><td>/posts</td><td>posts</td><td>app.controllers.posts.index</td></tr><tr><td>GET</td><td>/posts/new</td><td>new_post</td><td>app.controllers.posts.new</td></tr><tr><td>GET</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.show</td></tr><tr><td>GET</td><td>/posts/:id/edit</td><td>edit_post</td><td>app.controllers.posts.edit</td></tr><tr><td>POST</td><td>/posts</td><td>posts</td><td>app.controllers.posts.create</td></tr><tr><td>PUT</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.update</td></tr><tr><td>DELETE</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.destroy</td></tr></tbody></table><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./router/news&#x27;</span>)(app);</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./router/admin&#x27;</span>)(app);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router/news.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.get(<span class="string">&#x27;/news/list&#x27;</span>, app.controller.news.list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router/admin.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.get(<span class="string">&#x27;/admin/user&#x27;</span>, app.controller.admin.user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="控制器（Controller）"><a href="#控制器（Controller）" class="headerlink" title="控制器（Controller）"></a>控制器（Controller）</h2><blockquote><p>解析用户的输入，处理后返回相应的结果，框架建议在 controller 对请求参数进行处理（校验、转换），然后调用对应的 service 方法处理业务</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/controller/post.js</span></span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx, service &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> createRule = &#123;</span><br><span class="line">      <span class="attr">title</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">content</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    ctx.validate(createRule);</span><br><span class="line">    <span class="comment">// 组装参数</span></span><br><span class="line">    <span class="keyword">const</span> author = ctx.session.userId;</span><br><span class="line">    <span class="keyword">const</span> req = <span class="built_in">Object</span>.assign(ctx.request.body, &#123; author &#125;);</span><br><span class="line">    <span class="comment">// 调用 Service 进行业务处理</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> service.post.create(req);</span><br><span class="line">    <span class="comment">// 设置响应内容和响应状态码</span></span><br><span class="line">    ctx.body = &#123; <span class="attr">id</span>: res.id &#125;;</span><br><span class="line">    ctx.status = <span class="number">201</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = PostController;</span><br></pre></td></tr></table></figure><h3 id="获取上传的文件"><a href="#获取上传的文件" class="headerlink" title="获取上传的文件"></a>获取上传的文件</h3><h4 id="file模式"><a href="#file模式" class="headerlink" title="file模式"></a>file模式</h4><p>在config中配置file模式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/config.default.js</span></span><br><span class="line">exports.multipart = &#123;</span><br><span class="line">  mode: &#x27;file&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>controller层代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/controller/upload.js</span></span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;mz/fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">upload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;got %d files&#x27;</span>, ctx.request.files.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> ctx.request.files) &#123; <span class="comment">// files获取上传的多文件</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;field: &#x27;</span> + file.fieldname);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;filename: &#x27;</span> + file.filename);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;encoding: &#x27;</span> + file.encoding);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;mime: &#x27;</span> + file.mime);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;tmp filepath: &#x27;</span> + file.filepath);</span><br><span class="line">      <span class="keyword">let</span> result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理文件，比如上传到云端</span></span><br><span class="line">        result = <span class="keyword">await</span> ctx.oss.put(<span class="string">&#x27;egg-multipart-test/&#x27;</span> + file.filename, file.filepath);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 需要删除临时文件</span></span><br><span class="line">        <span class="keyword">await</span> fs.unlink(file.filepath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="stream模式"><a href="#stream模式" class="headerlink" title="stream模式"></a>stream模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sendToWormhole = <span class="built_in">require</span>(<span class="string">&#x27;stream-wormhole&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploaderController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">upload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="built_in">this</span>.ctx;</span><br><span class="line">    <span class="keyword">const</span> stream = <span class="keyword">await</span> ctx.getFileStream();</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;egg-multipart-test/&#x27;</span> + path.basename(stream.filename);</span><br><span class="line">    <span class="comment">// 文件处理，上传到云存储等等</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = <span class="keyword">await</span> ctx.oss.put(name, stream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 必须将上传的文件流消费掉，要不然浏览器响应会卡死</span></span><br><span class="line">      <span class="keyword">await</span> sendToWormhole(stream);</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      <span class="attr">url</span>: result.url,</span><br><span class="line">      <span class="comment">// 所有表单字段都能通过 `stream.fields` 获取到</span></span><br><span class="line">      <span class="attr">fields</span>: stream.fields,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UploaderController;</span><br></pre></td></tr></table></figure><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><p>其不是单例，在每次请求时访问<code>ctx.service.xx</code> 时延迟实例化，所以可以用<code>this.ctx</code>获取每一次请求的上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/service/user.js</span></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Service;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">find</span>(<span class="params">uid</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="built_in">this</span>.ctx.db.query(<span class="string">&#x27;select * from user where uid = ?&#x27;</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br></pre></td></tr></table></figure><p>函数return的值会返回给前端</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>所有的定时任务都统一存放在 <code>app/schedule</code> 目录下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Subscription = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Subscription;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateCache</span> <span class="keyword">extends</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 schedule 属性来设置定时任务的执行间隔等配置</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">schedule</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">interval</span>: <span class="string">&#x27;1m&#x27;</span>, <span class="comment">// 1 分钟间隔</span></span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 指定所有的 worker 都需要执行</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// subscribe 是真正定时任务执行时被运行的函数</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">subscribe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.ctx.curl(<span class="string">&#x27;http://www.api.com/cache&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.ctx.app.cache = res.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UpdateCache;</span><br></pre></td></tr></table></figure><p>还可以简写为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">schedule</span>: &#123;</span><br><span class="line">    <span class="attr">interval</span>: <span class="string">&#x27;1m&#x27;</span>, <span class="comment">// 1 分钟间隔</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 指定所有的 worker 都需要执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">task</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ctx.curl(<span class="string">&#x27;http://www.api.com/cache&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    ctx.app.cache = res.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有用过，具体配置看官方文档 <a href="https://eggjs.org/zh-cn/basics/schedule.html">定时任务</a></p><h2 id="egg-mysql"><a href="#egg-mysql" class="headerlink" title="egg-mysql"></a>egg-mysql</h2><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save egg-mysql</span><br></pre></td></tr></table></figure><p>开启插件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/plugin.js</span></span><br><span class="line">exports.mysql = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: &#x27;egg-mysql&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据库配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/config.$&#123;env&#125;.js</span></span><br><span class="line">exports.mysql = &#123;</span><br><span class="line">  <span class="comment">// 单数据库信息配置</span></span><br><span class="line">  clients: &#123;</span><br><span class="line">    <span class="comment">// clientId, 获取client实例，需要通过 app.mysql.get(&#x27;clientId&#x27;) 获取</span></span><br><span class="line">    db1: &#123;</span><br><span class="line">      host: &#x27;mysql.com&#x27;,</span><br><span class="line">      port: &#x27;<span class="number">3306</span>&#x27;,</span><br><span class="line">      user: &#x27;test_user&#x27;,</span><br><span class="line">      password: &#x27;test_password&#x27;,</span><br><span class="line">      database: &#x27;test&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    db2: &#123;</span><br><span class="line">      host: &#x27;mysql2.com&#x27;,</span><br><span class="line">      port: &#x27;<span class="number">3307</span>&#x27;,</span><br><span class="line">      user: &#x27;test_user&#x27;,</span><br><span class="line">      password: &#x27;test_password&#x27;,</span><br><span class="line">      database: &#x27;test&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 所有数据库配置的默认值</span></span><br><span class="line">  default: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 是否加载到 app 上，默认开启</span></span><br><span class="line">  app: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 是否加载到 agent 上，默认关闭</span></span><br><span class="line">  agent: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client1 = app.mysql.get(<span class="string">&#x27;db1&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> client1.query(sql, values);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client2 = app.mysql.get(<span class="string">&#x27;db2&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> client2.query(sql, values);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速初始化&quot;&gt;&lt;a href=&quot;#快速初始化&quot; class=&quot;headerlink&quot; title=&quot;快速初始化&quot;&gt;&lt;/a&gt;快速初始化&lt;/h2&gt;&lt;p&gt;用npm&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm init egg --&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=simple&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://liang5757.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="egg.js" scheme="https://liang5757.github.io/tags/egg-js/"/>
    
  </entry>
  
  <entry>
    <title>redux入门</title>
    <link href="https://liang5757.github.io/2021/06/15/React/redux%E5%85%A5%E9%97%A8/"/>
    <id>https://liang5757.github.io/2021/06/15/React/redux%E5%85%A5%E9%97%A8/</id>
    <published>2021-06-15T13:02:58.000Z</published>
    <updated>2021-12-23T16:18:02.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redux 官方文档对 Redux 的定义是：<strong>一个可预测的 JavaScript 应用状态管理容器</strong></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><blockquote><p>Redux应用只有单一的 store</p></blockquote><p>通过<code>createStore()</code>创建一个store</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span> <span class="comment">// 这个在下面会讲</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp)</span><br></pre></td></tr></table></figure><p><code>createStore()</code>的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</p><p>提供四个函数</p><ul><li><code>getState()</code>方法获取 state</li><li><code>dispatch(action)</code>方法分发 action 更新 state</li><li><code>subscribe(listener)</code>注册监听器，返回的函数注销监听器</li><li><code>replaceReducer(nextReducer)</code> 一般在 Webpack Code-Splitting 按需加载的时候用</li></ul><p>redux规定禁止直接修改 state，也就是下面的写法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = store.getState()</span><br><span class="line">state.counter = state.counter + <span class="number">1</span> <span class="comment">// 禁止在业务逻辑中直接修改 state</span></span><br></pre></td></tr></table></figure><p>只能通过 dispatch 一个 action 来修改</p><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>是把数据从应用传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。一般来说你会通过 <a href="https://cn.redux.js.org/docs/api/Store.html#dispatch"><code>store.dispatch()</code></a> 将 action 传到 store。</p><h3 id="1-Action格式"><a href="#1-Action格式" class="headerlink" title="1 Action格式"></a>1 Action格式</h3><p>除了<code>type</code>字段外，action的结构完全由你自己决定，一般参照 <a href="https://github.com/acdlite/flux-standard-action">Flux 标准 Action</a> 获取关于如何构造 action 的建议。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">&#x27;ADD_TODO&#x27;</span></span><br><span class="line"><span class="comment">// 下面是常见的action格式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: ADD_TODO,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Build my first Redux app&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Action创建函数"><a href="#2-Action创建函数" class="headerlink" title="2 Action创建函数"></a>2 Action创建函数</h3><p>就是生成action的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-dispatch"><a href="#3-dispatch" class="headerlink" title="3 dispatch"></a>3 dispatch</h3><p>只需把 action 创建函数的结果传给 <code>dispatch()</code> 方法即可发起一次 dispatch 过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch(addTodo(text))</span><br></pre></td></tr></table></figure><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>指定了应用状态的变化如何<strong>响应</strong> actions 并发送状态到 store 的，记住 actions 只是描述了<em>有事情发生了</em>这一事实，并没有描述应用如何更新 state。</p><p>reducer就是一个纯函数，<strong>接收旧的 state 和 action，返回新的 state</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">previousState, action</span>) =&gt;</span> newState</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initState = &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">todos</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 应用的初始状态是在第一次执行 reducer 时设置的 ※</span></span><br><span class="line">    <span class="keyword">if</span> (!state) state = initState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">            <span class="keyword">var</span> nextState = _.cloneDeep(state) <span class="comment">// 用到了 lodash 的深克隆</span></span><br><span class="line">            nextState.todos.push(action.payload) </span><br><span class="line">            <span class="keyword">return</span> nextState</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD_COUNT&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                <span class="attr">visibilityFilter</span>: action.filter</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="comment">// 由于 nextState 会把原 state 整个替换掉</span></span><br><span class="line">            <span class="comment">// 若无修改，必须返回原 state（否则就是 undefined）</span></span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>不要修改 <code>state</code>。</strong> 使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> 新建了一个副本。不能这样使用 <code>Object.assign(state, &#123; visibilityFilter: action.filter &#125;)</code>，因为它会改变第一个参数的值</li><li><strong>在 <code>default</code> 情况下返回旧的 <code>state</code>。</strong>否则 state 会变成<code>undefined</code></li></ul><h2 id="拆分Reducer"><a href="#拆分Reducer" class="headerlink" title="拆分Reducer"></a>拆分Reducer</h2><p>当业务逻辑复杂时，所有状态聚合在一个reducer函数里处理，逻辑会变得相当复杂。</p><p>我们可以提出一个主reducer函数，它调用多个子 reducer 分别处理子 state 中的数据，然后再把这些数据合成一个大的单一对象。</p><p>主 reducer 并不需要设置初始化时完整的 state。初始时，如果传入 <code>undefined</code>, <strong>子 reducer 将负责返回它们的默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">text</span>: action.text,</span><br><span class="line">          <span class="attr">completed</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    <span class="keyword">case</span> TOGGLE_TODO:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === action.index) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class="line">            <span class="attr">completed</span>: !todo.completed</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityFilter</span>(<span class="params">state = SHOW_ALL, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</span><br><span class="line">      <span class="keyword">return</span> action.filter</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visibilityFilter</span>: visibilityFilter(state.visibilityFilter, action),</span><br><span class="line">    <span class="attr">todos</span>: todos(state.todos, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以利用<code>combineReducers()</code>来简化代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = combineReducers(&#123;</span><br><span class="line">  visibilityFilter,</span><br><span class="line">  <span class="attr">a</span>: todos</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp</span><br></pre></td></tr></table></figure><p>注意上面的写法和下面完全等价：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visibilityFilter</span>: visibilityFilter(state.visibilityFilter, action),</span><br><span class="line">    <span class="attr">todos</span>: todos(state.todos, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a>异步数据流</h2><p>如果只是简单的redux store是不支持用dispatch异步更新store，可以使用<code>react-thunk</code>来增强</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux-thunk</span><br></pre></td></tr></table></figure><h3 id="使用applyMiddleware引入中间件"><a href="#使用applyMiddleware引入中间件" class="headerlink" title="使用applyMiddleware引入中间件"></a>使用applyMiddleware引入中间件</h3><blockquote><p>与Koa和Express类似，redux也提供了注册中间件的方法：<code>applyMiddleware</code>，这个中间件执行时间是在<strong>dispatch一个action之后，到达reducer之前</strong>，执行顺序是从上到下，传递action</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  applyMiddleware(</span><br><span class="line">    thunk, <span class="comment">// 允许我们 dispatch() 函数</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>引入后<strong>允许我们<code>dispatch</code>一个函数</strong>，这个函数内部可以<code>dispatch</code>，这个函数接受两个参数，第一个是<code>dispatch</code>，第二个是<code>getState</code>，函数内部允许放一些异步操作，来解决redux只能同步<code>dispatch(action)</code>的问题</p><h3 id="react-thunk-源码"><a href="#react-thunk-源码" class="headerlink" title="react-thunk 源码"></a>react-thunk 源码</h3><p>出乎意料的简单</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">// 如果是函数，当作函数执行</span></span><br><span class="line">            <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure><p>当然我们也可以用<code>redux-promise</code>这个中间件来<code>dispatch</code>一个<code>promise</code></p><h3 id="redux-promise-源码"><a href="#redux-promise-源码" class="headerlink" title="redux-promise 源码"></a>redux-promise 源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isPromise <span class="keyword">from</span> <span class="string">&#x27;is-promise&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isFSA &#125; <span class="keyword">from</span> <span class="string">&#x27;flux-standard-action&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseMiddleware</span>(<span class="params">&#123; dispatch &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是不是 flux 标准的action</span></span><br><span class="line">        <span class="keyword">if</span> (!isFSA(action)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPromise(action) ? action.then(dispatch) : next(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isPromise(action.payload)</span><br><span class="line">            ? action.payload</span><br><span class="line">            .then(<span class="function"><span class="params">result</span> =&gt;</span> dispatch(&#123; ...action, <span class="attr">payload</span>: result &#125;))</span><br><span class="line">            .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123; ...action, <span class="attr">payload</span>: error, <span class="attr">error</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;)</span><br><span class="line">        : next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与react配合使用"><a href="#与react配合使用" class="headerlink" title="与react配合使用"></a>与react配合使用</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-redux</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>利用 Provider 组件分发store状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./app/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在组件中使用<code>useSelector</code>，<code>useDispatch</code>来获取 state 和分发 action</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; decrement, increment &#125; <span class="keyword">from</span> <span class="string">&#x27;./counterSlice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.counter.value) <span class="comment">// 从state中获取count的值</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = useDispatch() <span class="comment">// 获取dispatch方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;</span></span><br><span class="line"><span class="xml">                Increment</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;</span></span><br><span class="line"><span class="xml">                Decrement</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用<code>connect</code>函数包裹组件，将state和dispatch映射到props中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// prop : state.xxx  | 意思是将state中的某个数据映射到props中</span></span><br><span class="line">        <span class="attr">foo</span>: state.bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123; <span class="comment">// 默认传递参数就是dispatch</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;increatment&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>this.props.foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.props.onClick&#125;</span>&gt;</span>点击increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo = connect(mapStateToProps, mapDispatchToProps)(Foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Foo;</span><br></pre></td></tr></table></figure><h2 id="同步react-router"><a href="#同步react-router" class="headerlink" title="同步react-router"></a>同步react-router</h2><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save connected-react-router</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.创建一个以history作为参数，返回根reducer的函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; connectRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;connected-react-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createRootReducer = <span class="function">(<span class="params">history</span>) =&gt;</span> combineReducers(&#123;</span><br><span class="line">  <span class="attr">router</span>: connectRouter(history),</span><br><span class="line">  ... <span class="comment">// rest of your reducers</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createRootReducer;</span><br></pre></td></tr></table></figure><p>2.创建一个history对象，将这个对象给上述的reducer和<code>createRootReducer</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configureStore.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;history&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, compose, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; routerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;connected-react-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> createRootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> history = createBrowserHistory()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">preloadedState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(</span><br><span class="line">        createRootReducer(history), <span class="comment">// root reducer with router state</span></span><br><span class="line">        preloadedState,</span><br><span class="line">        compose(</span><br><span class="line">            applyMiddleware(</span><br><span class="line">                routerMiddleware(history), <span class="comment">// for dispatching history actions</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.利用 ConnectedRouter组件，传递给他history对象作为prop，并将该组件作为 react-redux的Provider组件的子组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span> <span class="comment">// react-router v4/v5</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConnectedRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;connected-react-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> configureStore, &#123; history &#125; <span class="keyword">from</span> <span class="string">&#x27;./configureStore&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = configureStore(<span class="comment">/* 提供初始state */</span>)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ConnectedRouter</span> <span class="attr">history</span>=<span class="string">&#123;history&#125;</span>&gt;</span> &#123; /* place ConnectedRouter under Provider */ &#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;&gt;</span> </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">render</span>=<span class="string">&#123;()</span> =&gt;</span> (<span class="tag">&lt;<span class="name">div</span>&gt;</span>Match<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">render</span>=<span class="string">&#123;()</span> =&gt;</span> (<span class="tag">&lt;<span class="name">div</span>&gt;</span>Miss<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125; /&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ConnectedRouter</span>&gt;</span></span></span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;react-root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>connect-react-router也提供了路由跳转的方法，比如 push 和 replace，但是这些方法只是创建了action，需要dispatch这些方法产生的action</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;push, replace&#125; <span class="keyword">from</span> <span class="string">&quot;connected-react-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">XXX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dispatch(push(<span class="string">&quot;/page1&quot;</span>))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.sakura-snow.com/post/react-node-6/">react学习笔记6-redux</a><br><a href="https://juejin.cn/post/6844903846666321934">一篇文章总结redux、react-redux、redux-saga</a><br><a href="https://cn.redux.js.org/">Redux中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Redux 官方文档对 Redux 的定义是：&lt;strong&gt;一个可预测的 JavaScript 应用状态管理容器&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save redux&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hook</title>
    <link href="https://liang5757.github.io/2021/06/08/React/React%20Hook/"/>
    <id>https://liang5757.github.io/2021/06/08/React/React%20Hook/</id>
    <published>2021-06-08T14:45:46.000Z</published>
    <updated>2021-12-23T16:17:43.521Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>函数式组件只能使用props，Hook能够在函数式组件的情况下使用state、生命周期以及其他的React特性</p></blockquote><p>为什么需要引入React Hook，可以查看官方文档：<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation">https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation</a></p><a id="more"></a><h2 id="1-注意事项"><a href="#1-注意事项" class="headerlink" title="1. 注意事项"></a>1. 注意事项</h2><ul><li>只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用</li><li>只能在 React 的函数组件或自定义Hook中调用 Hook，不要在其他 JavaScript 函数中调用</li><li>Hook 在 class 内部是<strong>不</strong>起作用的</li></ul><h2 id="2-useState"><a href="#2-useState" class="headerlink" title="2. useState"></a>2. useState</h2><p>useState在组件内创建的内部state，React 会在重复渲染时保留这个 state，该函数的<strong>第一个参数是初始值</strong>，可以传入一个函数，此函数只在初始渲染中被调用。调用该函数会返回一对值：[当前状态，更新当前状态的函数]。</p><p>这个更新状态的函数<strong>不会对state进行合并，而是直接替换</strong>，可以传递一个回调函数，携带参数是上一次的state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>; <span class="number">2</span>:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>); <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">                Click me</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部使用<code>Object.js</code>（浅）来比较新/旧<code>state</code>是否相等，在修改状态时，<strong>传的状态值没有变化，则不重新渲染</strong></p><h3 id="惰性初始值"><a href="#惰性初始值" class="headerlink" title="惰性初始值"></a>惰性初始值</h3><p>下面的代码中，<code>initialState</code>是只在初始化时有其存在价值，但是如果真如下面一样写了，那么这个计算出<code>initialState</code>昂贵的操作在每次render都会执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = someExpensiveComputation(props); <span class="comment">// 这是一个耗时的操作</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure><p>我们可以让<code>someExpensiveComputation</code> 运行在一个<code>useState</code>匿名函数参数下，该函数当且仅当初始化时被调用，从而优化性能。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">    <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h2><p>用来在函数式组件内使用class组件的生命周期函数，可以传递两个参数，第一个是执行回调函数，第二个是监听的变量数组。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="1-只在第一次的componentDidMount执行"><a href="#1-只在第一次的componentDidMount执行" class="headerlink" title="1.只在第一次的componentDidMount执行"></a>1.只在第一次的componentDidMount执行</h4><p>第二个参数为 []</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h4 id="2-在第一次渲染和每次更新后执行"><a href="#2-在第一次渲染和每次更新后执行" class="headerlink" title="2. 在第一次渲染和每次更新后执行"></a>2. 在第一次渲染和每次更新后执行</h4><p>第二个参数为空</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-监听变量的变化执行"><a href="#3-监听变量的变化执行" class="headerlink" title="3. 监听变量的变化执行"></a>3. 监听变量的变化执行</h4><p>第二个参数是一个变量数组，只要有一个变量变化了就会执行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// count改变才会执行</span></span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><h4 id="4-在componentWillUnmount中执行"><a href="#4-在componentWillUnmount中执行" class="headerlink" title="4. 在componentWillUnmount中执行"></a>4. 在componentWillUnmount中执行</h4><p>第一个回调函数可以return一个函数，这个return的函数会在<code>componentWillUnmount</code>这个生命周期执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;use effect...&#x27;</span>, count)</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> setCount(count +<span class="number">1</span>), <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-useRef"><a href="#3-useRef" class="headerlink" title="3. useRef"></a>3. useRef</h2><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。</p><p><strong>和createRef的区别</strong>：createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用（可以解决每次渲染引用不同的useState，导致状态异常的bug）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [renderIndex, setRenderIndex] = useState(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> refFromUseRef = useRef();</span><br><span class="line">    <span class="keyword">const</span> refFromCreateRef = createRef();</span><br><span class="line">    <span class="keyword">if</span> (!refFromUseRef.current) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;useRef&quot;</span>)</span><br><span class="line">        refFromUseRef.current = renderIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!refFromCreateRef.current) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;createRef&quot;</span>)</span><br><span class="line">        refFromCreateRef.current = renderIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            Current render index: &#123;renderIndex&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>refFromUseRef value: &#123;refFromUseRef.current&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>refFromCreateRef value: &#123;refFromCreateRef.current&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setRenderIndex(prev =&gt; prev + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">                Cause re-render</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![image-20210606235123989](D:\OneDrive - mail2.gdut.edu.cn\typora_img\React Hook\image-20210606235123989.png)</p><h2 id="4-useImperativeHandle"><a href="#4-useImperativeHandle" class="headerlink" title="4. useImperativeHandle"></a>4. useImperativeHandle</h2><p><code>useImperativeHandle</code>可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛</p><p><code>useImperativeHandle</code> 应当与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">props, parentRef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子组件内部自己创建 ref</span></span><br><span class="line">    <span class="keyword">let</span> focusRef = useRef();</span><br><span class="line">    <span class="keyword">let</span> inputRef = useRef();</span><br><span class="line">    useImperativeHandle(parentRef, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这个函数会返回一个对象</span></span><br><span class="line">        <span class="comment">// 该对象会作为父组件 current 属性的值</span></span><br><span class="line">        <span class="comment">// 通过这种方式，父组件可以使用操作子组件中的多个 ref</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            focusRef,</span><br><span class="line">            inputRef,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;计数器&#x27;</span>,</span><br><span class="line">            focus () &#123;</span><br><span class="line">                focusRef.current.focus();</span><br><span class="line">            &#125;,</span><br><span class="line">            changeText (text) &#123;</span><br><span class="line">                inputRef.current.value = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;focusRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child = forwardRef(Child);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parentRef = useRef();<span class="comment">//&#123;current:&#x27;&#x27;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        parentRef.current.focus();</span><br><span class="line">        <span class="comment">// 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效</span></span><br><span class="line">        <span class="comment">// parentRef.current.addNumber(666);</span></span><br><span class="line">        parentRef.current.changeText(<span class="string">&#x27;777&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(parentRef.current.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;parentRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;getFocus&#125;</span>&gt;</span>获得焦点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-useMemo"><a href="#5-useMemo" class="headerlink" title="5.useMemo"></a>5.useMemo</h2><blockquote><p>父组件的state改变，子组件也会随之重新render，即使子组件内部state没有改变，我们可以用useMemo来进行性能优化</p></blockquote><p>参数列表</p><ul><li>回调函数，return出来的值作为useMemo的返回值</li><li>依赖项数组，只要有一个变量改变，就会重新执行回调，但不会触发渲染，如果<strong>没有提供依赖数组，则<code>useMemo</code> 在每次渲染时都会计算新的值</strong></li></ul><p><code>useMemo</code>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 值，它仅会在会在某个依赖项改变时才重新计算 memoized 值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = memo(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child render...&#x27;</span>, data.name)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;data.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hook = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hook render...&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">&#x27;rose&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [name])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;count&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;update count <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Child</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-useCallback"><a href="#6-useCallback" class="headerlink" title="6. useCallback"></a>6. useCallback</h2><blockquote><p><code>useCallback</code>与<code>useMemo</code>的差别是，前者是缓存函数，后者是缓存值</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onChange = useCallback(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(e.target.value)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p><code>useCallback(fn, deps)</code>相当于<code>useMemo(() =&gt; fn, deps)</code></p><h2 id="7-useContext"><a href="#7-useContext" class="headerlink" title="7. useContext"></a>7. useContext</h2><p>接收一个 context 对象（由<code>React.createContext</code> 所创建）并返回该 context 的当前值，当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TextContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">TextContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;666&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">TextContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">xxxButton</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxxButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> text = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">text</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      I am styled by theme context!</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，也会在组件本身使用 <code>useContext</code> 时重新渲染</p><h2 id="8-useLayoutEffect"><a href="#8-useLayoutEffect" class="headerlink" title="8. useLayoutEffect"></a>8. useLayoutEffect</h2><ul><li><p><code>useLayoutEffect</code>会在浏览器 layout 之后，painting 之前执行</p></li><li><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect</p></li><li><p><strong>可以使用它来读取 DOM 布局并同步触发重渲染</strong></p></li><li><p><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LayoutEffect</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = useState(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">    useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        alert(color);</span><br><span class="line">    &#125;);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;color&#x27;</span>, color);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>颜色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&#x27;red&#x27;)&#125;&gt;红<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&#x27;yellow&#x27;)&#125;&gt;黄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&#x27;blue&#x27;)&#125;&gt;蓝<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 先alert出red，再渲染出页面，阻塞渲染</p><h2 id="9-自定义Hook"><a href="#9-自定义Hook" class="headerlink" title="9. 自定义Hook"></a>9. 自定义Hook</h2><p>其实就是写一个函数内部调用其他Hook，每次使用自定义Hook时，所有的state和副作用都是完全隔离的</p><p>例如：我们可以对useRef封装成自定义Hook来获取上一次的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usePrevious = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ref = useRef();</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        ref.current = state;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> prevCount = usePrevious(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">                Cause re-render</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;count&#125; &#123;prevCount&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次点击button，prevCount都是上一次count的值</p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><h3 id="1-为什么我的count没有更新"><a href="#1-为什么我的count没有更新" class="headerlink" title="1. 为什么我的count没有更新"></a>1. 为什么我的count没有更新</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，用户点击div，count只会加到1，后面就不会再加了。</p><p>原因是：每次 <code>count</code> 都是重新声明的变量，指向一个全新的数据；每次的 <code>setCount</code> 虽然是重新声明的，但指向的是同一个引用。</p><h3 id="解决方式一：函数式更新"><a href="#解决方式一：函数式更新" class="headerlink" title="解决方式一：函数式更新"></a>解决方式一：函数式更新</h3><p>用回调函数的形式，<code>() =&gt; setCount(prevCount =&gt; ++prevCount)</code>，来消除对外部count的引用。</p><h3 id="解决方式二：重新绑定事件"><a href="#解决方式二：重新绑定事件" class="headerlink" title="解决方式二：重新绑定事件"></a>解决方式二：重新绑定事件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> dom.current.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">&#125;, [count]); <span class="comment">// 在这里对count进行监听，每次改变都会重新绑定事件</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="解决方式三：用ref重新获取引用"><a href="#解决方式三：用ref重新获取引用" class="headerlink" title="解决方式三：用ref重新获取引用"></a>解决方式三：用ref重新获取引用</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> countRef = useRef(count);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        countRef.current++;</span><br><span class="line">        setCount(countRef.current);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904090032406536">写React Hooks前必读</a><br><a href="https://juejin.cn/post/6844904072168865800">终于搞懂 React Hooks了！！！！！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数式组件只能使用props，Hook能够在函数式组件的情况下使用state、生命周期以及其他的React特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么需要引入React Hook，可以查看官方文档：&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation&quot;&gt;https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Router</title>
    <link href="https://liang5757.github.io/2021/05/28/React/React%20Router/"/>
    <id>https://liang5757.github.io/2021/05/28/React/React%20Router/</id>
    <published>2021-05-28T12:13:21.000Z</published>
    <updated>2021-12-23T16:18:02.100Z</updated>
    
    <content type="html"><![CDATA[<ul><li>react-router：路由核心库，包含诸多和路由功能相关的核心代码</li><li>react-router-dom：利用路由核心库，结合实际的页面，实现跟页面路由密切相关的功能</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># react-router-dom依赖react-router</span></span><br><span class="line"><span class="comment"># 安装的时候会把react-router一起安装了</span></span><br><span class="line">npm install react-router-dom -S</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-两种路由模式-Hash、History"><a href="#1-两种路由模式-Hash、History" class="headerlink" title="1.两种路由模式 Hash、History"></a>1.两种路由模式 Hash、History</h2><ul><li><code>HashRouter</code>：使用 hash 模式匹配</li><li><code>BrowserRouter</code>：使用 BrowserHistory 模式匹配</li></ul><p>两者区别<br>1.底层原理不一样：<br>    BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。<br>    HashRouter使用的是URL的哈希值。<br>2.path表现形式不一样<br>    BrowserRouter的路径中没有#，例如：localhost:3000/demo/test<br>    HashRouter的路径包含#,例如：localhost:3000/#/demo/test<br>3.刷新后对路由state参数的影响<br>    BrowserRouter没有任何影响，因为state保存在history对象中。<br>    HashRouter刷新后会导致路由state参数的丢失！！！<br>4.备注：HashRouter可以用于解决一些路径错误相关的问题。</p><h2 id="2-跳转组件-Link和NavLink"><a href="#2-跳转组件-Link和NavLink" class="headerlink" title="2. 跳转组件 Link和NavLink"></a>2. 跳转组件 Link和NavLink</h2><p>Link组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/xxxxx&quot;</span>&gt;Demo&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>Link组件配置方式</p><ul><li><p>to：要跳转的链接（String | Object  | Function）</p></li><li><p>replace：设置为true，则跳转替换路由栈顶</p></li><li><p>innerRef：可以将内部的a元素的ref附着在传递的对象或函数参数上（Function | RefObject）</p></li><li><p>component：可以设置自定义的导航组件</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyLink = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span>💅 &#123;props.children&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span> component=&#123;FancyLink&#125; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>NavLink</strong>可以实现路由链接的高亮，通过<code>activeClassName</code>指定样式类名</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">&quot;/xxxxx&quot;</span>&gt;Demo&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><h2 id="3-route组件"><a href="#3-route组件" class="headerlink" title="3. route组件"></a>3. route组件</h2><p>配置方式</p><ul><li>path：匹配的路径<ul><li>默认情况下，不区分大小写，可以设置sensitive属性为true，来区分大小写</li><li>默认情况下，只匹配初始目录，如果要精确匹配，配置exact属性为true</li><li>如果不写path，则会匹配任意路径</li></ul></li><li>component：匹配成功后要显示的组件</li><li>children<ul><li>传递React元素，无论是否匹配，一定会显示children，并且会忽略component属性</li><li>传递一个函数，该函数有多个参数，这些参数来自于上下文，该函数返回react元素，则一定会显示返回的元素，并且忽略component属性</li></ul></li><li>render：匹配成功渲染的组件，内联书写render，而不是创建一个React元素</li><li>sensitive：true则对paht的大小写敏感</li><li>exact：精确匹配</li></ul><h3 id="route嵌套"><a href="#route嵌套" class="headerlink" title="route嵌套"></a>route嵌套</h3><p>下述代码中，用户访问<code>/repos</code>时，会先加载<code>App</code>组件，然后在它的内部再加载<code>Repos</code>组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter history=&#123;hashHistory&#125;&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/repos&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Repos&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ol><li>:paramName</li></ol><p><code>:paramName</code>匹配URL的一个部分，直到遇到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。这个路径参数可以通过<code>this.props.params.paramName</code>取出。</p><ol start="2"><li>()</li></ol><p><code>()</code>表示URL的这个部分是可选的。</p><ol start="3"><li>*</li></ol><p><code>*</code>匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</p><ol start="4"><li>**</li></ol><p><code>**</code> 匹配任意字符，直到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。匹配方式是贪婪模式。</p><p>此外，URL的查询字符串<code>/foo?bar=baz</code>，可以用<code>this.props.location.query.bar</code>获取。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/a&quot;</span> <span class="attr">component</span>=<span class="string">&#123;A&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/a/d&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;D&#125;/</span>&gt;</span>  // 精确匹配</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;C&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/abc&#x27;</span> <span class="attr">children</span>=<span class="string">&#123;E&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>  上述代码，如果路由是 <strong>/a/d，则会渲染 A、D、C、E</strong>，react router是会从上至下完全匹配一遍，而为了解决这个问题，引入了Switch组件。</p><h2 id="4-Switch组件"><a href="#4-Switch组件" class="headerlink" title="4. Switch组件"></a>4. Switch组件</h2><p>会<strong>循环所有子元素</strong>，当匹配到第一个Route后，会立即停止匹配并渲染，因此不能在Switch组件的子元素中使用除Route外的其他组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/a&quot;</span> <span class="attr">component</span>=<span class="string">&#123;A&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/a/b&quot;</span> <span class="attr">component</span>=<span class="string">&#123;B&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;C&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><h2 id="5-Redirect组件"><a href="#5-Redirect组件" class="headerlink" title="5. Redirect组件"></a>5. Redirect组件</h2><p>一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">&quot;/about/&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="6-路由信息"><a href="#6-路由信息" class="headerlink" title="6. 路由信息"></a>6. 路由信息</h2><p>Router组件会创建一个上下文，并且向上下文中注入一些信息，该上下文对开发者是隐藏的，Route组件若匹配到了地址，则会将这些上下文中的信息作为属性传入对应的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>组件A<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/a&quot;</span> <span class="attr">component</span>=<span class="string">&#123;A&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印一下props</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>:</span><br><span class="line">go: ƒ go(n)</span><br><span class="line">goBack: ƒ goBack()</span><br><span class="line">goForward: ƒ goForward()</span><br><span class="line">push: ƒ push(path, state)</span><br><span class="line">replace: ƒ replace(path, state)</span><br><span class="line">location:</span><br><span class="line">    <span class="built_in">hash</span>：页面<span class="built_in">hash</span></span><br><span class="line">    pathname：页面的path</span><br><span class="line">    state：push时传入的数据</span><br><span class="line">    search：传入的参数</span><br><span class="line">match:</span><br><span class="line">isExact：事实上，当前的路径和路由配置的路径是否是精确匹配的</span><br><span class="line">params：获取路径中对应的数据</span><br><span class="line">path：路径规则</span><br><span class="line">url：页面路径</span><br></pre></td></tr></table></figure><h2 id="7-路由传参"><a href="#7-路由传参" class="headerlink" title="7.路由传参"></a>7.路由传参</h2><h3 id="5-1-params-参数"><a href="#5-1-params-参数" class="headerlink" title="5.1 params 参数"></a>5.1 params 参数</h3><p>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test/tom/18&#39;&#125;&gt;详情&lt;/Link&gt;</code><br>注册路由(声明接收)：<code>&lt;Route path=&quot;/demo/test/:name/:age&quot; component=&#123;Test&#125;/&gt;</code><br>接收参数：this.props.match.params</p><h3 id="5-2-search参数"><a href="#5-2-search参数" class="headerlink" title="5.2 search参数"></a>5.2 search参数</h3><p>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test?name=tom&amp;age=18&#39;&#125;&gt;详情&lt;/Link&gt;</code><br>注册路由(无需声明，正常注册即可)：<code>&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</code><br>接收参数：<code>this.props.location.search</code><br>备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</p><h3 id="5-3-state参数"><a href="#5-3-state参数" class="headerlink" title="5.3 state参数"></a>5.3 state参数</h3><p>路由链接(携带参数)：<code>&lt;Link to=&#123;&#123;pathname:'/demo/test',state:&#123;name:'tom',age:18&#125;&#125;&#125;&gt;详情&lt;/Link&gt;</code><br>注册路由(无需声明，正常注册即可)：<code>&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</code><br>接收参数：<code>this.props.location.state</code><br>备注：刷新也可以保留住参数</p><h2 id="8-编程式导航"><a href="#8-编程式导航" class="headerlink" title="8. 编程式导航"></a>8. 编程式导航</h2><p>借助<code>this.props.history</code>上的方法，基本和H5的history一致，就只是列一下了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.history.push()</span><br><span class="line"><span class="built_in">this</span>.props.history.replace()</span><br><span class="line"><span class="built_in">this</span>.props.history.goBack()</span><br><span class="line"><span class="built_in">this</span>.props.history.goForward()</span><br><span class="line"><span class="built_in">this</span>.props.history.go()</span><br></pre></td></tr></table></figure><h2 id="9-withRouter"><a href="#9-withRouter" class="headerlink" title="9. withRouter"></a>9. withRouter</h2><blockquote><p>由于<strong>只能在跳转的组件中获取路由信息</strong>，所以提出<code>withRouter</code>，用withRouter包裹的组件能获取路由信息</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ButtonContainer</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> history = props.history;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">container</span>&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;history.push(&quot;/a?key=a&quot;, &quot;A状态数据&quot;)&#125;&#125;&gt;A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;history.push(&quot;/a/b?key=b&quot;, &quot;B状态数据&quot;)&#125;&#125;&gt;B<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;history.push(&quot;/a/c?key=c&quot;, &quot;C状态数据&quot;)&#125;&#125;&gt;C<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;history.push(&quot;/a/d?key=d&quot;, &quot;D状态数据&quot;)&#125;&#125;&gt;D<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;history.push(&quot;/a/news/2020/12/21&quot;)&#125;&#125;&gt;News<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WithRouterButtonContainer = withRouter(ButtonContainer)</span><br></pre></td></tr></table></figure><p>其返回值是一个新组件</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.sakura-snow.com/post/react-node-5/">react学习笔记5-React Router</a><br>[React Router 使用教程](</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;react-router：路由核心库，包含诸多和路由功能相关的核心代码&lt;/li&gt;
&lt;li&gt;react-router-dom：利用路由核心库，结合实际的页面，实现跟页面路由密切相关的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# react-router-dom依赖react-router&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 安装的时候会把react-router一起安装了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install react-router-dom -S&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React从入门到真香</title>
    <link href="https://liang5757.github.io/2021/05/27/React/React%E5%85%A5%E9%97%A8/"/>
    <id>https://liang5757.github.io/2021/05/27/React/React%E5%85%A5%E9%97%A8/</id>
    <published>2021-05-27T15:41:33.000Z</published>
    <updated>2021-12-23T16:17:43.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设计思想"><a href="#1-设计思想" class="headerlink" title="1. 设计思想"></a>1. 设计思想</h2><ol><li><a href="https://github.com/react-guide/react-basic">React 设计思想</a></li><li><a href="http://www.infoq.com/cn/articles/react-art-of-simplity/">React的设计哲学 - 简单之美</a></li><li><a href="http://www.infoq.com/cn/articles/subversion-front-end-ui-development-framework-react/">颠覆式前端UI开发框架:React</a><a id="more"></a><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2></li></ol><h3 id="2-1-CDN的方式引入"><a href="#2-1-CDN的方式引入" class="headerlink" title="2.1 CDN的方式引入"></a>2.1 CDN的方式引入</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>react.js：React核心库</li><li>react-dom.js：提供操作 DOM 的 react 扩展库</li><li>babel.min.js：解析 JSX 语法代码转为 JS 代码的库</li></ul><h3 id="2-2-create-react-app"><a href="#2-2-create-react-app" class="headerlink" title="2.2 create-react-app"></a>2.2 create-react-app</h3><p>安装<code>create-react-app</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm isntall -g create-react-app</span><br></pre></td></tr></table></figure><p>创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure><h2 id="3-JSX"><a href="#3-JSX" class="headerlink" title="3. JSX"></a>3. JSX</h2><p>jsx 允许在模板中用<code>&#123;&#125;</code>插入JavaScript表达式，如果<code>&#123;&#125;</code>中的变量是数组，则会展开这个数组的所有成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>React is awesome<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>,</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;arr&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Emily&#x27;</span>, <span class="string">&#x27;Kate&#x27;</span>];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#123;</span></span><br><span class="line"><span class="xml">    names.map(function (name) &#123; // 列表渲染</span></span><br><span class="line"><span class="xml">      return <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example2&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>ReactDOM.render</code>第一个参数是渲染的组件，第二个参数是挂载实例的位置。</p><ul><li>className替换class</li><li>内联样式——style=</li><li>只能含有一个最外层标签</li></ul><p>对于最后一个问题，可以使用React.Fragment组件，它能够在不额外创建 DOM 元素的情况下，让render返回多个元素</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Some text.</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-组件"><a href="#4-组件" class="headerlink" title="4.组件"></a>4.组件</h2><h3 id="4-1-类组件（有状态）"><a href="#4-1-类组件（有状态）" class="headerlink" title="4.1 类组件（有状态）"></a>4.1 类组件（有状态）</h3><blockquote><p>组件类的第一个名字必须大写</p></blockquote><p>通过继承React.Component来实现类组件，需要实现一个render方法，该方法返回一个模板</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clickFunc.bind(this)&#125;</span>&gt;</span> // 将clickFunc内部this指向组件实例</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.props.date.toLocaleTimeString()&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过React.createClass生成一个组件类</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Clock = React.createClass(&#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.props.date.toLocaleTimeString()&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两种方式的区别是，前者不会自动绑定this</p><h3 id="4-2-函数式组件（无状态）"><a href="#4-2-函数式组件（无状态）" class="headerlink" title="4.2 函数式组件（无状态）"></a>4.2 函数式组件（无状态）</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name, age, sex&#125; = props;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-State"><a href="#5-State" class="headerlink" title="5. State"></a>5. State</h2><h3 id="5-1-state初始化"><a href="#5-1-state初始化" class="headerlink" title="5.1 state初始化"></a>5.1 state初始化</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一种 直接在实例上定义state属性</span></span><br><span class="line">  state = &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">6</span>,</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 第二种 在构造器中设置state</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="number">6</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-state修改"><a href="#5-2-state修改" class="headerlink" title="5.2 state修改"></a>5.2 state修改</h3><p><strong>直接修改数据是不会触发视图更新</strong>的，只有使用<code>setState</code>来修改数据，会重新触发组件的render函数</p><p>setState第一个参数就是修改后的state对象，可以修改某一个值，<strong>setState是浅合并</strong>。</p><p>如果setState的第一个参数不是一个对象而是一个函数，这个函数在执行时会通过参数被传入prevState，也就是之前的状态，而返回值就会和state进行合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState : any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">num</span> : prevState.num + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是setState有两个问题</p><ul><li>setState对状态的修改，可能是异步执行的（如果改变状态的代码处于某个HTML元素的事件中，则其是异步的，否则是同步）</li><li>React会对异步的setState进行优化，将多次setState进行合并（将多次状态改变完成后，再统一对state进行改变，然后触发render）</li></ul><p>下面给出第一个问题的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            <span class="attr">num</span>: <span class="built_in">this</span>.state.num + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.num) <span class="comment">// 第一下点击输出 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一下点击按钮的时候，console.log输出 0，说明setState在DOM事件中是异步执行的。</p><p><strong>解决方式</strong>：setState有第二个参数，来放置render执行后接着执行的回调函数</p><h2 id="6-Props"><a href="#6-Props" class="headerlink" title="6. Props"></a>6. Props</h2><h3 id="6-1-传递参数"><a href="#6-1-传递参数" class="headerlink" title="6.1 传递参数"></a>6.1 传递参数</h3><p>父组件在使用子组件的时候，通过给子组件元素设置属性的方式传递参数给子组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件设置属性给子组件传参，这里属性名用value2用作区分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">value2</span>=<span class="string">&#123;0&#125;/</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类组件 通过 this.props.[属性] 来获取参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;this.props.value2&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式组件通过 props.[属性] 来获取参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;props.value2&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-props传递事件"><a href="#6-2-props传递事件" class="headerlink" title="6.2 props传递事件"></a>6.2 props传递事件</h3><p>通过this.props.[事件名]调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">click</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;alert(&quot;click event&quot;)&#125;&#125;/&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.click&#125;</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              button</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-props校验"><a href="#6-3-props校验" class="headerlink" title="6.3 props校验"></a>6.3 props校验</h3><p>1.需要引入一个库prop-types.js</p><ul><li>cdn</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/prop-types@15.6/prop-types.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>npm</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save prop-types </span><br></pre></td></tr></table></figure><p>2.使用方式</p><p>在组件上定义 PropTypes对象，键就是props的名，值就是限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ... do things with the props</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="attr">value1</span>: PropTypes.number.isRequired,</span><br><span class="line">        <span class="attr">value2</span>: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定props默认值</span></span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        <span class="attr">value1</span>: <span class="number">666</span>,</span><br><span class="line">        <span class="attr">value2</span>: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">Square.propTypes = &#123;</span><br><span class="line">    <span class="attr">value1</span>: PropTypes.number.isRequired,</span><br><span class="line">    <span class="attr">value2</span>: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多使用方式参考：<a href="https://github.com/facebook/prop-types">https://github.com/facebook/prop-types</a></p><h3 id="6-4-this-props-children"><a href="#6-4-this-props-children" class="headerlink" title="6.4 this.props.children"></a>6.4 this.props.children</h3><blockquote><p>获取组件所有子节点</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotesList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;</span></span><br><span class="line"><span class="xml">                    React.Children.map(this.props.children, function (child) &#123;</span></span><br><span class="line"><span class="xml">                        return <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;child&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">                    &#125;)</span></span><br><span class="line"><span class="xml">                &#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">NotesList</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">NotesList</span>&gt;</span></span>,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>没有子节点：undefined</li><li>一个子节点：object</li><li>多个子节点：array</li></ul><p>可以用<code>React.Children.map</code>来遍历子节点，则不需要担心子元素个数</p><h3 id="6-5-props传递组件"><a href="#6-5-props传递组件" class="headerlink" title="6.5 props传递组件"></a>6.5 props传递组件</h3><p>React组件本质就是对象，当作props像其他数据一样传递也是可以的</p><h2 id="7-React生命周期"><a href="#7-React生命周期" class="headerlink" title="7. React生命周期"></a>7. React生命周期</h2><blockquote><p>感觉和vue差不多，直接简单带过把</p></blockquote><h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h4><p>组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作</p><h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h4><p>组件已经被渲染到页面中后触发，可以通过<code>this.getDOMNode()</code>来进行访问DOM。</p><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps()"></a>componentWillReceiveProps()</h4><p>在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化<code>render</code>时不会被调用。</p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h4><p>返回一个布尔值。在组件接收到新的<code>props</code>或者<code>state</code>时被调用。在初始化时或者使用<code>forceUpdate</code>时不被调用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。</span></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">newProps, newState</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps.number &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个<strong>父组件的重新更新会造成它旗下所有的子组件重新执行render()方法（即使没有使用父组件的state）</strong>，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染，还可以使用下面说了PureComponent</p></blockquote><h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate()"></a>componentWillUpdate()</h4><p>在组件接收到新的<code>props</code>或者<code>state</code>但还没有<code>render</code>时被调用。在初始化时不会被调用。</p><h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h4><p>在组件完成更新后立即调用。在初始化时不会被调用。</p><h4 id="componentWillUnMount"><a href="#componentWillUnMount" class="headerlink" title="componentWillUnMount()"></a>componentWillUnMount()</h4><p>组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。</p><h4 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError()"></a>getDerivedStateFromError()</h4><p>这个生命周期方法在<strong>ErrorBoundary</strong>类中使用。实际上，如果使用这个生命周期方法，任何类都会变成<code>ErrorBoundary</code>。这用于在组件树中出现错误时呈现回退UI，而不是在屏幕上显示一些奇怪的错误。</p><h4 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a>componentDidCatch()</h4><p>这个生命周期方法在<strong>ErrorBoundary</strong>类中使用。实际上，如果使用这个生命周期方法，任何类都会变成<code>ErrorBoundary</code>。这用于在组件树中出现错误时记录错误。</p><h2 id="8-Ref"><a href="#8-Ref" class="headerlink" title="8. Ref"></a>8. Ref</h2><p>用来访问DOM元素或render中的react元素，Ref的使用规则如下</p><ol><li>ref作用于内置的html组件时，得到的将是真实的dom对象</li><li>ref作用于类组件时，得到的将是类的实例</li><li>ref不能作用于函数组件（因为没有实例），但是函数组件内部可以</li></ol><h3 id="8-1-创建ref"><a href="#8-1-创建ref" class="headerlink" title="8.1 创建ref"></a>8.1 创建ref</h3><p>ref的可选值为</p><ol><li><p>字符串（不建议）</p><p> 原因：<a href="http://www.qiutianaimeili.com/html/page/2020/04/20204277uz3udr631a.html">react ref注意事项</a></p></li><li><p>回调函数</p><p> 触发时机：ref中的回调函数会在对应的<strong>普通</strong>组件（或元素）<code>componentDidMount</code>，<code>ComponentDidUpdate</code>之前，或者<code>componentWillUnmount</code>之后执行</p><p> <strong>注意：</strong>如果 <code>ref</code> 回调函数是以<strong>内联函数的方式定义</strong>的，在更新过程中它会被<strong>执行两次</strong>，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在<strong>每次渲染时会创建一个新的函数实例</strong>，所以 React 清空旧的 ref 并且设置新的</p></li><li><p>createRef</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.textInput = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">focusTextInput</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span></span><br><span class="line">        <span class="built_in">this</span>.textInput.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput.bind(this)&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-转发ref"><a href="#8-2-转发ref" class="headerlink" title="8.2 转发ref"></a>8.2 转发ref</h3><blockquote><p>用于获取组件内部的某个元素，有些高度复用的基础组件不可避免的需要在父组件获取，用以管理焦点等</p></blockquote><p><code>React.forwardRef</code>用以获取传递给它的<code>ref</code>，然后转发到渲染它的DOM。</p><p>对于<strong>函数式组件</strong>，<code>React.forwardRef</code>直接包裹函数就可以接收到ref</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">className</span>=<span class="string">&quot;FancyButton&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以直接获取 DOM button 的 ref：</span></span><br><span class="line"><span class="keyword">const</span> ref = React.createRef();</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">FancyButton</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">FancyButton</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>使用 <code>FancyButton</code> 的组件可以获取底层 DOM 节点 <code>button</code> 的 ref </p><p>而对于<strong>类组件</strong>，需要使用HOC的形式，用<code>React.forwardRef</code>包裹返回的函数式组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class="line">    <span class="comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class="line">    <span class="comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class="line">    <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>React.forwardRef</code>包裹的组件在<strong>DevTools中显示为”ForwardRef”</strong>，可以把包裹的函数用普通函数的形式命名，DevTools也将包含其名称（例如 “<em>ForwardRef(myFunction)</em>”），也可以<strong>设置函数的displayName属性</strong>来设置DevTools中显示的名字</p><h2 id="9-Context"><a href="#9-Context" class="headerlink" title="9.Context"></a>9.Context</h2><blockquote><p>跨组件的通信方式，等同Vue的provide、inject</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.创建Context容器对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效</span></span><br><span class="line"><span class="keyword">const</span> xxxContext = React.createContext(defaultValue) </span><br></pre></td></tr></table></figure><p>2.渲染子组时，外面包裹xxxContext.Provider，通过value属性给后代组件传递数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;xxxContext.Provider value=&#123;数据&#125;&gt;</span><br><span class="line">    &lt;子组件&gt;&lt;/子组件&gt;</span><br><span class="line">&lt;/xxxContext.Provider&gt;</span><br></pre></td></tr></table></figure><p>ps：如果要传多个数据，需要套多层</p><p>3.后代组件获取数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：仅适用于类组件</span></span><br><span class="line"><span class="keyword">static</span> contextType = xxxContext <span class="comment">// 声明接受context</span></span><br><span class="line"><span class="built_in">this</span>.context; <span class="comment">// 读取context中的value数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：函数组件与类组件都可以</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">xxxContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;value&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">xxxContext.Consumer</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>不建议使用该api，他提高了组件复用的难度</strong></p><h2 id="10-PureComponent"><a href="#10-PureComponent" class="headerlink" title="10.PureComponent"></a>10.PureComponent</h2><blockquote><p>父组件setState会触发子组件render，PureComponent通过prop和state的<strong>浅比较</strong>来实现shouldComponentUpdate，算是一种语法糖，帮我们应该在shouldComponentUpdate中应该手动比较的给做了</p></blockquote><p>如果是浅层state或prop没改变，那么不会触发视图更新，书写方式如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于是浅比较，所以直接修改对象内部的值是无法更新视图的</strong></p><p>在函数式组件则是用<code>React.memo</code>包裹函数式组件来做到PureComponent的效果</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/tsrot/study-notes/blob/master/React%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB.md">React学习资源汇总</a><br><a href="http://www.ruanyifeng.com/blog/2015/03/react.html">React 入门实例教程</a><br><a href="https://blog.sakura-snow.com/post/react-node-2/">react学习笔记2-react基本使用</a><br><a href="https://blog.sakura-snow.com/post/react-node-3/">react学习笔记3-react其他使用技巧</a><br><a href="https://juejin.cn/post/6844903510538977287">图解ES6中的React生命周期</a><br><a href="https://juejin.cn/post/6844903857135304718#heading-25">你要的 React 面试知识点，都在这了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-设计思想&quot;&gt;&lt;a href=&quot;#1-设计思想&quot; class=&quot;headerlink&quot; title=&quot;1. 设计思想&quot;&gt;&lt;/a&gt;1. 设计思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/react-guide/react-basic&quot;&gt;React 设计思想&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/react-art-of-simplity/&quot;&gt;React的设计哲学 - 简单之美&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/subversion-front-end-ui-development-framework-react/&quot;&gt;颠覆式前端UI开发框架:React&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>js准确倒计时</title>
    <link href="https://liang5757.github.io/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    <id>https://liang5757.github.io/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/</id>
    <published>2021-05-24T16:03:51.000Z</published>
    <updated>2024-07-04T16:43:45.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>如果用最初始的<code>setTimeout</code>递归实现定时器，一秒执行一次回调，则代码如下</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟执行大量代码</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i++ &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDown</span> (<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(), count = <span class="number">0</span>, second = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> timeCounter = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">interFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * second);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;误差：&quot;</span> + offset + <span class="string">&quot;ms，下一次执行：&quot;</span> + <span class="number">1000</span> + <span class="string">&quot;ms后，离活动开始还有：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    time -= second;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeCounter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeCounter = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        interFunc();</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countDown(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="number">10000</span>)(); <span class="comment">// 测试代码</span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/image-20210524235731030.png" alt="image-20210524235731030"></p><p>可以看到误差是会越来越多的。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>核心思想就是通过计算 <strong>当前时间 - 应该到的时间</strong> 计算出<strong>时间偏移量</strong>，<strong>下一次延迟时间就是 1s - 偏移量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟执行大量代码</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i++ &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDown</span> (<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(), count = <span class="number">0</span>, second = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> timeCounter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">interFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * second);</span><br><span class="line">    <span class="keyword">let</span> nextTime = second - offset;</span><br><span class="line">    <span class="keyword">if</span> (nextTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      nextTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;误差：&quot;</span> + offset + <span class="string">&quot;ms，下一次执行：&quot;</span> + nextTime + <span class="string">&quot;ms后，离活动开始还有：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    time -= second;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeCounter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeCounter = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        interFunc();</span><br><span class="line">      &#125;, nextTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countDown(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="number">10000</span>)(); <span class="comment">// 测试代码</span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/image-20210525000118726.png" alt="image-20210525000118726"></p><p>可以看到虽然仍有误差，但不会随着时间增大</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;如果用最初始的&lt;code&gt;setTimeout&lt;/code&gt;递归实现定时器，一秒执行一次回调，则代码如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>如何给对象设置默认值</title>
    <link href="https://liang5757.github.io/2021/05/06/Js/%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <id>https://liang5757.github.io/2021/05/06/Js/%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC/</id>
    <published>2021-05-05T17:06:29.000Z</published>
    <updated>2021-12-23T16:12:01.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用-…-解构设置"><a href="#1-用-…-解构设置" class="headerlink" title="1.用 … 解构设置"></a>1.用 … 解构设置</h2><p>在看compressor.js的时候，他用一个文件来存默认值，然后导出，最后用解构的方式，后面的值覆盖前面的方式设置默认值。当然也可以用<code>Object.assign</code>都是一样的</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defaults.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">maxWidth</span>: <span class="literal">Infinity</span>,</span><br><span class="line">    <span class="attr">maxHeight</span>: <span class="literal">Infinity</span>,</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> DEFAULTS <span class="keyword">from</span> <span class="string">&#x27;./defaults&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">option</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.option = &#123;</span><br><span class="line">            ...DEFAULTS,</span><br><span class="line">            ...option,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法看着挺方便的，但是还有缺陷，解决不了下面的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;a1&quot;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&quot;c1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defaults = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;a2&quot;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&quot;c2&quot;</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&quot;d1&quot;</span> <span class="comment">// 丢失了</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> option = &#123;</span><br><span class="line">  ...defaults,</span><br><span class="line">  ...user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(option) <span class="comment">// &#123; a: &#x27;a1&#x27;, b: &#123; c: &#x27;c1&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到默认配置中 <strong>d丢失了</strong>，下面的方法可以解决这个问题</p><h2 id="2-extend方法"><a href="#2-extend方法" class="headerlink" title="2.extend方法"></a>2.extend方法</h2><p>Mescroll.js实现的方法，适合多个方法都需要默认值的时候，并且<strong>可以深度匹配默认值</strong>，默认值作为第二个参数传入，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MeScroll.extend = <span class="function"><span class="keyword">function</span> (<span class="params">userOption, defaultOption</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!userOption) <span class="keyword">return</span> defaultOption;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> defaultOption) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userOption[key] == <span class="literal">null</span>) &#123; <span class="comment">// 如果用户没设置，则用默认值</span></span><br><span class="line">            userOption[key] = defaultOption[key]; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> userOption[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            MeScroll.extend(userOption[key], defaultOption[key]); <span class="comment">// 深度匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userOption;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有些场景我们是需要有<strong>多个配置进行合并</strong>，我们可以参考jquery的<code>extend</code>实现方式</p><h2 id="3-extend"><a href="#3-extend" class="headerlink" title="3.$.extend"></a>3.$.extend</h2><p><code>$.extend([deep,] [target,] object1 [,objectN])</code></p><blockquote><p><strong>deep</strong>: Boolen类型，可选，表示是否进行递归合并（深/浅复制），为true是为深复制；默认值为false，浅复制。<br><strong>target</strong>:扩展对象，可选，将接收新的属性。<br><strong>objectN</strong>:一个对象，包含额外的属性，扩展到目标对象（扩展对象）。</p></blockquote><p>我们可以砍掉一个没必要的功能，就是<code>$.extend</code>如果参数中只有一个对象，则扩展jquery对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法会改变原对象</span></span><br><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</span><br><span class="line">    target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;,</span><br><span class="line">    i = <span class="number">1</span>,    <span class="comment">// i表示从第几个参数开始向目标参数进行合并，默认从第2个参数开始向第1个参数进行合并</span></span><br><span class="line">    length = <span class="built_in">arguments</span>.length,</span><br><span class="line">    deep = <span class="literal">false</span>;  <span class="comment">// 默认为浅度拷贝</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果第一个参数是用来设置deep的boolean值，则将target设置为下一个参数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">    deep = target;</span><br><span class="line">    </span><br><span class="line">    target = <span class="built_in">arguments</span>[i] || &#123;&#125;;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  判断目标参数的类型，若目标参数既不是object类型，也不是function类型，则为目标参数重新赋值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> target !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    target = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从第i个参数开始</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取第i个不为null或undefined的参数</span></span><br><span class="line">    <span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">        src = target[name];</span><br><span class="line">        copy = options[name];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 防止循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">&quot;__proto__&quot;</span> || target === copy) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若deep为true，且当前参数中name字段的值存在且为object类型或Array类型，则进行深合并</span></span><br><span class="line">        <span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = <span class="built_in">Array</span>.isArray(copy)))) &#123;</span><br><span class="line">          <span class="comment">// 如果copy是数组类型，则判断目标参数中name字段的值是否存在，若存在则使用原来的，否则进行初始化</span></span><br><span class="line">          <span class="keyword">if</span> (copyIsArray &amp;&amp; !<span class="built_in">Array</span>.isArray(src)) &#123;</span><br><span class="line">            clone = [];</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!copyIsArray &amp;&amp; !isPlainObject(src)) &#123;</span><br><span class="line">            clone = &#123;&#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clone = src;</span><br><span class="line">          &#125;</span><br><span class="line">          copyIsArray = <span class="literal">false</span>;</span><br><span class="line">          </span><br><span class="line">          target[name] = merge(deep, clone, copy);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// deep为false，表示浅拷贝，直接进行赋值</span></span><br><span class="line">          <span class="comment">// 或者copy不为Object对象、数组，则直接赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="comment">// 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性</span></span><br><span class="line">          target[name] = copy;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回修改后的目标参数</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="附1：jquery重构了的一段代码"><a href="#附1：jquery重构了的一段代码" class="headerlink" title="附1：jquery重构了的一段代码"></a>附1：jquery重构了的一段代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = <span class="built_in">Array</span>.isArray(copy)))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (copyIsArray) &#123;</span><br><span class="line">        copyIsArray = <span class="literal">false</span>;</span><br><span class="line">        clone = src &amp;&amp; <span class="built_in">Array</span>.isArray(src) ? src : [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target[name] = jQuery.extend(deep, clone, copy);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) &#123;</span><br><span class="line">    target[name] = copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = <span class="built_in">Array</span>.isArray(copy)))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (copyIsArray &amp;&amp; !<span class="built_in">Array</span>.isArray(src)) &#123;</span><br><span class="line">        clone = [];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!copyIsArray &amp;&amp; !isPlainObject(src)) &#123;</span><br><span class="line">        clone = &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clone = src;</span><br><span class="line">    &#125;</span><br><span class="line">    copyIsArray = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    target[name] = merge(deep, clone, copy);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    target[name] = copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码明显下面好看了许多，可以学习一下这种重构方式</p><h2 id="附2：isEmptyObject、isPlainObject"><a href="#附2：isEmptyObject、isPlainObject" class="headerlink" title="附2：isEmptyObject、isPlainObject"></a>附2：isEmptyObject、isPlainObject</h2><h4 id="1-isEmptyObject"><a href="#1-isEmptyObject" class="headerlink" title="1.isEmptyObject"></a>1.isEmptyObject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isEmptyObject: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以利用JSON.stringify</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) == <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-isPlainObject"><a href="#2-isPlainObject" class="headerlink" title="2.isPlainObject"></a>2.isPlainObject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.先排除明显不是Object的</span></span><br><span class="line">    <span class="keyword">if</span> (!target || <span class="built_in">Object</span>.prototype.toString.call(target) !== <span class="string">&quot;[object Object]&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断是否有原型，没有原型的是简单对象</span></span><br><span class="line">    <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(target);</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断其构造函数是否为 Object</span></span><br><span class="line">    <span class="keyword">const</span> ctor = proto.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ctor === <span class="string">&quot;function&quot;</span> &amp;&amp; ctor === <span class="built_in">Object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_33694172/article/details/89369987">https://blog.csdn.net/weixin_33694172/article/details/89369987</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-用-…-解构设置&quot;&gt;&lt;a href=&quot;#1-用-…-解构设置&quot; class=&quot;headerlink&quot; title=&quot;1.用 … 解构设置&quot;&gt;&lt;/a&gt;1.用 … 解构设置&lt;/h2&gt;&lt;p&gt;在看compressor.js的时候，他用一个文件来存默认值，然后导出，最后用解构的方式，后面的值覆盖前面的方式设置默认值。当然也可以用&lt;code&gt;Object.assign&lt;/code&gt;都是一样的&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【源码解读】crossvent源码解读</title>
    <link href="https://liang5757.github.io/2021/04/06/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/crossvent%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://liang5757.github.io/2021/04/06/Js/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/crossvent%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-04-06T15:46:07.000Z</published>
    <updated>2024-07-04T16:52:02.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实就是一个封装事件绑定的库，但是看到了一些技巧记录下来<br>github地址：<a href="https://github.com/bevacqua/crossvent/blob/master/src/crossvent.js">https://github.com/bevacqua/crossvent/blob/master/src/crossvent.js</a></p></blockquote><h2 id="从出口开始"><a href="#从出口开始" class="headerlink" title="从出口开始"></a>从出口开始</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">add</span>: addEvent,</span><br><span class="line">  <span class="attr">remove</span>: removeEvent,</span><br><span class="line">  <span class="attr">fabricate</span>: fabricateEvent</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="add和remove函数"><a href="#add和remove函数" class="headerlink" title="add和remove函数"></a>add和remove函数</h2><p><code>addEvent</code>实际上就是判断window是否有<code>addEventListener</code>，如果没有就用<code>attachEvent</code>，remove同理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = addEventEasy;</span><br><span class="line"><span class="keyword">var</span> removeEvent = removeEventEasy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">global</span>.addEventListener) &#123;</span><br><span class="line">  addEvent = addEventHard;</span><br><span class="line">  removeEvent = removeEventHard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventEasy</span> (<span class="params">el, type, fn, capturing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> el.addEventListener(type, fn, capturing); <span class="comment">// capturing如果为true则在事件捕获阶段执行，默认为false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventHard</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, wrap(el, type, fn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEventEasy</span> (<span class="params">el, type, fn, capturing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> el.removeEventListener(type, fn, capturing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEventHard</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> listener = unwrap(el, type, fn);</span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.detachEvent(<span class="string">&#x27;on&#x27;</span> + type, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意：在不支持<code>addEventListener</code>的时候，使用<code>attachEvent</code>和<code>detachEvent</code>事件回调函数多做了一层<code>wrap</code>和<code>unwrap</code>处理</p><h2 id="wrap和unwrap"><a href="#wrap和unwrap" class="headerlink" title="wrap和unwrap"></a>wrap和unwrap</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hardCache = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经注册过这个type的事件，则unwrap即从hardCache删除事件，并在下面重新添加到hardCache数组里</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn); </span><br><span class="line">  hardCache.push(&#123;</span><br><span class="line">    <span class="attr">wrapper</span>: wrapper,</span><br><span class="line">    <span class="attr">element</span>: el,</span><br><span class="line">    <span class="attr">type</span>: type,</span><br><span class="line">    <span class="attr">fn</span>: fn</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrap</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = find(el, type, fn);</span><br><span class="line">  <span class="keyword">if</span> (i) &#123;</span><br><span class="line">    <span class="keyword">var</span> wrapper = hardCache[i].wrapper;</span><br><span class="line">    hardCache.splice(i, <span class="number">1</span>); <span class="comment">// free up a tad of memory</span></span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, item;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hardCache.length; i++) &#123;</span><br><span class="line">    item = hardCache[i];</span><br><span class="line">    <span class="keyword">if</span> (item.element === el &amp;&amp; item.type === type &amp;&amp; item.fn === fn) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是利用一个数组存储事件回调，在绑定事件和解绑事件同时对hardCache数组进行操作，但是为啥要这样呢。可以看到在wrap函数的第一行<code>var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);</code> ，实际上就是如果之前没有绑定这个type的事件，就调用<code>wrapperFactory</code>对<code>fn</code>进行二次封装，<strong><code>wrapperFactory</code>这个封装主要是为了解决event参数内的属性的兼容性</strong>。</p><p>这就解释了刚才提出的疑问，就是因为多了这层解决浏览器兼容性的包装，在解绑事件的时候，如果只是传递原来的fn，则不能解绑事件，需要一个hardCache数组来存取事件回调。</p><h2 id="wrapperFactory"><a href="#wrapperFactory" class="headerlink" title="wrapperFactory"></a>wrapperFactory</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFactory</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapper</span> (<span class="params">originalEvent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = originalEvent || <span class="built_in">global</span>.event;</span><br><span class="line">    e.target = e.target || e.srcElement;</span><br><span class="line">    e.preventDefault = e.preventDefault || <span class="function"><span class="keyword">function</span> <span class="title">preventDefault</span> (<span class="params"></span>) </span>&#123; e.returnValue = <span class="literal">false</span>; &#125;;</span><br><span class="line">    e.stopPropagation = e.stopPropagation || <span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span> (<span class="params"></span>) </span>&#123; e.cancelBubble = <span class="literal">true</span>; &#125;;</span><br><span class="line">    e.which = e.which || e.keyCode;</span><br><span class="line">    fn.call(el, e);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这层封装可以使event的各个属性在不同浏览器下行为一致。</p><p>add和revome就讲完了，我们来看看导出的最后一个函数fabricate</p><h2 id="fabricate"><a href="#fabricate" class="headerlink" title="fabricate"></a>fabricate</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fabricateEvent</span> (<span class="params">el, type, model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = eventmap.indexOf(type) === -<span class="number">1</span> ? makeCustomEvent() : makeClassicEvent(); <span class="comment">// 判断事件类型 并 创建</span></span><br><span class="line">  <span class="keyword">if</span> (el.dispatchEvent) &#123; <span class="comment">// 触发事件</span></span><br><span class="line">    el.dispatchEvent(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el.fireEvent(<span class="string">&#x27;on&#x27;</span> + type, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeClassicEvent</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建原生事件</span></span><br><span class="line">    <span class="keyword">var</span> e;</span><br><span class="line">    <span class="keyword">if</span> (doc.createEvent) &#123;</span><br><span class="line">      e = doc.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">      e.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (doc.createEventObject) &#123;</span><br><span class="line">      e = doc.createEventObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeCustomEvent</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建自定义事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> customEvent(type, &#123; <span class="attr">detail</span>: model &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eventmap</code>是原生事件名的集合，如果没有在<code>eventmap</code>找到则创建一个自定义事件，否则创建一个原生事件，然后触发事件。</p><p>那么eventmap是怎么生成的呢，我们下面来看看</p><h2 id="获取原生事件名集合"><a href="#获取原生事件名集合" class="headerlink" title="获取原生事件名集合"></a>获取原生事件名集合</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventmap = [];</span><br><span class="line"><span class="keyword">var</span> eventname = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> ron = <span class="regexp">/^on/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (eventname <span class="keyword">in</span> <span class="built_in">global</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ron.test(eventname)) &#123;</span><br><span class="line">    eventmap.push(eventname.slice(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = eventmap;</span><br></pre></td></tr></table></figure><p>其实就是正则匹配window上的开头为on的属性名</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到了挺多浏览器兼容的处理方式，以及原生事件名获取的骚操作，不过仍有一些兼容方式没看懂是兼容哪些浏览器的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实就是一个封装事件绑定的库，但是看到了一些技巧记录下来&lt;br&gt;github地址：&lt;a href=&quot;https://github.com/bevacqua/crossvent/blob/master/src/crossvent.js&quot;&gt;https://github.com/bevacqua/crossvent/blob/master/src/crossvent.js&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;从出口开始&quot;&gt;&lt;a href=&quot;#从出口开始&quot; class=&quot;headerlink&quot; title=&quot;从出口开始&quot;&gt;&lt;/a&gt;从出口开始&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;add&lt;/span&gt;: addEvent,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;remove&lt;/span&gt;: removeEvent,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;fabricate&lt;/span&gt;: fabricateEvent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Koa洋葱原型源码解读</title>
    <link href="https://liang5757.github.io/2021/02/28/node.js/Koa%E6%B4%8B%E8%91%B1%E5%8E%9F%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://liang5757.github.io/2021/02/28/node.js/Koa%E6%B4%8B%E8%91%B1%E5%8E%9F%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-02-27T16:25:27.000Z</published>
    <updated>2024-07-04T16:44:51.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版本：2.13.1</p></blockquote><h2 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.middleware = [];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个<code>middleware</code>存函数</p><a id="more"></a><h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">use</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次使用app.use()就会吧回调函数push到<code>middleware</code>里</p><h3 id="listen方法"><a href="#listen方法" class="headerlink" title="listen方法"></a>listen方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="built_in">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个服务，执行callback方法</p><h3 id="callback和handleRequest方法"><a href="#callback和handleRequest方法" class="headerlink" title="callback和handleRequest方法"></a>callback和handleRequest方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">callback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="built_in">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="built_in">this</span>.createContext(req, res); <span class="comment">// node 原生的 req、res 对象把其中的属性挂载到 ctx 上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.handleRequest(ctx, fn); <span class="comment">// 调用</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function">() =&gt;</span> respond(ctx);</span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compse函数返回一个中间件函数，在handleRequest执行中间件函数，如果全部 resolve 了就可以调用 handleResponse 发送给客户端</p><p>本片博客的重点就是compose是怎么实现koa的洋葱模型的</p><h2 id="koa-compose-js"><a href="#koa-compose-js" class="headerlink" title="koa-compose.js"></a>koa-compose.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="compose函数"><a href="#compose函数" class="headerlink" title="compose函数"></a>compose函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// last called middleware #</span></span><br><span class="line">        <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">            index = i</span><br><span class="line">            <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">            <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">            <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>compose</code>函数接收<code>middleware</code>数组，<code>dispatch(0)</code>即开始分发一号中间件。</p></li><li><p><code>dispatch(0)</code>内部，此时 fn 为一号中间件，会走到 try/catch 块，尝试执行<code>Promise.resolve(fn(context, dispatch.bind(null, i + 1)))</code>，即一号中间件此时获得入参<code>context</code>、<code>dispatch(1)</code>。</p></li><li><p>一号中间件开始执行，遇到 next()（即dispatch(1)），控制权移交，执行 dispatch(1)，此时二号中间件获得入参<code>context</code>、<code>dispatch(2)</code>。</p></li><li><p>二号中间件开始执行，执行到<code>await next()</code>时，再重复上述逻辑，dispatch(2)，但是这一次会停在这里：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = middleware[i];</span><br><span class="line"><span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line"><span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure><p>  fn = next，这里的 next 由于并没有值，所以会直接 return 一个立即 resolve 的 Promise。也就是说二号中间件内部的 await next()会立刻返回。</p></li><li><p>二号中间件做完自己的事后，相当于一号中间件内部的<code>await next()</code>返回了，因此控制权就归还给一号中间件。</p></li></ul><h2 id="如果中间件中的next-方法报错了怎么办。"><a href="#如果中间件中的next-方法报错了怎么办。" class="headerlink" title="如果中间件中的next()方法报错了怎么办。"></a>如果中间件中的<code>next()</code>方法报错了怎么办。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ctx.onerror = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.app.emit(<span class="string">&#x27;error&#x27;</span>, err, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span>  fnMiddleware = compose(<span class="built_in">this</span>.middleware);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror);</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onerror</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：中间件链错误会由<code>ctx.onerror</code>捕获，该函数中会调用<code>this.app.emit(&#39;error&#39;, err, this)</code>（因为<code>koa</code>继承自<code>Emitter</code>，所以有<code>emit</code>和<code>on</code>等方法），可以使用<code>app.on(&#39;error&#39;, (err) =&gt; &#123;&#125;)</code>，或者<code>app.onerror = (err) =&gt; &#123;&#125;</code>进行捕获。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844904088220467213#heading-16">https://juejin.cn/post/6844904088220467213#heading-16</a><br><a href="https://linbudu.top/posts/2020/02/25/koa%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB.html#new-%E4%B8%80%E4%B8%AA-koa-%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">https://linbudu.top/posts/2020/02/25/koa%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB.html#new-%E4%B8%80%E4%B8%AA-koa-%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;版本：2.13.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;application-js&quot;&gt;&lt;a href=&quot;#application-js&quot; class=&quot;headerlink&quot; title=&quot;application.js&quot;&gt;&lt;/a&gt;application.js&lt;/h2&gt;&lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;options&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.middleware = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有一个&lt;code&gt;middleware&lt;/code&gt;存函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://liang5757.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="源码解读" scheme="https://liang5757.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="node.js" scheme="https://liang5757.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>尤雨溪frontend Master课程笔记</title>
    <link href="https://liang5757.github.io/2021/02/18/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AAfrontend%20Master%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://liang5757.github.io/2021/02/18/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AAfrontend%20Master%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-17T18:46:31.000Z</published>
    <updated>2024-07-04T16:44:57.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-响应式"><a href="#1-响应式" class="headerlink" title="1.响应式"></a>1.响应式</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>实现一个神奇的函数auto，会在<code>state.count</code>改变后，自动运行里面的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">autoRun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>).innerText = state.count;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">state.count++; <span class="comment">// 重新执行autoRun内的函数</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="第一步-getter和setter"><a href="#第一步-getter和setter" class="headerlink" title="第一步 getter和setter"></a>第一步 getter和setter</h3><p>需要能监听到对象内属性的改变</p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br><span class="line">observer(obj);</span><br><span class="line">obj.foo <span class="comment">// 需要打印: &#x27;getting key &quot;foo&quot;: 123&#x27;</span></span><br><span class="line">obj.foo = <span class="number">234</span> <span class="comment">// 需要打印: &#x27;setting key &quot;foo&quot; to 234&#x27;</span></span><br><span class="line">obj.foo <span class="comment">// 需要打印: &#x27;getting key &quot;foo&quot;: 234&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保存属性初始值</span></span><br><span class="line">    <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      get () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting key &quot;<span class="subst">$&#123;key&#125;</span>&quot;: <span class="subst">$&#123;internalValue&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> internalValue</span><br><span class="line">      &#125;,</span><br><span class="line">      set (newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting key &quot;<span class="subst">$&#123;key&#125;</span>&quot; to: <span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">        internalValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步-依赖收集-Dep"><a href="#第二步-依赖收集-Dep" class="headerlink" title="第二步 依赖收集 Dep"></a>第二步 依赖收集 Dep</h3><h4 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h4><p>即一个发布订阅模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">autoRun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  dep.depend()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印: &quot;updated&quot;</span></span><br><span class="line"></span><br><span class="line">dep.notify()</span><br><span class="line"><span class="comment">// 打印: &quot;updated&quot;</span></span><br></pre></td></tr></table></figure><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 订阅函数</span></span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(activeUpdate); <span class="comment">// 把全局变量activeUpdate存的函数放入订阅者列表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 发布函数</span></span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate = <span class="literal">null</span> <span class="comment">// 放置依赖函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoRun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedUpdate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    activeUpdate = wrappedUpdate <span class="comment">// 把wrappedUpdate存起来</span></span><br><span class="line">    update() <span class="comment">// 在update内部调用dep.depend()收集依赖</span></span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三步-整合一、二"><a href="#第三步-整合一、二" class="headerlink" title="第三步 整合一、二"></a>第三步 整合一、二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(activeUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">this</span>.walk(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.defineReactive(obj, key);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">defineReactive</span>(<span class="params">obj, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> internalValue = obj[key];</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        that.dep.depend();</span><br><span class="line">        <span class="keyword">return</span> internalValue;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isChanged = internalValue !== newVal;</span><br><span class="line">        <span class="keyword">if</span> (isChanged) &#123;</span><br><span class="line">          internalValue = newVal;</span><br><span class="line">          that.dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">autoRun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedUpdate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    activeUpdate = wrappedUpdate <span class="comment">// 把wrappedUpdate存起来</span></span><br><span class="line">    update() <span class="comment">// 在update内部调用dep.depend()收集依赖</span></span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-虚拟DOM"><a href="#2-虚拟DOM" class="headerlink" title="2. 虚拟DOM"></a>2. 虚拟DOM</h2><h3 id="2-1虚拟DOM和真实的DOM的差异"><a href="#2-1虚拟DOM和真实的DOM的差异" class="headerlink" title="2.1虚拟DOM和真实的DOM的差异"></a>2.1虚拟DOM和真实的DOM的差异</h3><p>1.资源消耗问题</p><p>使用javascript操作真实DOM是非常消耗资源的，虽然很多浏览器做了优化但是效果不大。你看到虚拟DOM是一个纯javascript对象。而DOM节点有70＋个属性，继承层级有6，7层（文本节点6层，元素节点7层）,访问一个属性，可能会追溯几重原型链。</p><p>2.执行效率问题</p><p>如果你要修改一个真实DOM，一般调用<code>innerHTML</code>方法，那浏览器会把旧的节点移除再添加新的节点，但是在虚拟DOM中，只需要修改一个对象的属性，再把虚拟DOM渲染到真实DOM上。很多人会误解虚拟DOM比真实DOM速度快，其实虚拟DOM只是把DOM变更的逻辑提取出来，使用javascript计算差异，减少了操作真实DOM的次数，只在最后一次才操作真实DOM，所以如果你的应用有复杂的DOM变更操作，虚拟DOM会比较快。</p><p>3.虚拟DOM还有其他好处</p><p>其实虚拟DOM还可以应用在其他地方，因为他们只是抽象节点，可以把它编译成其他平台，例如android、ios。市面上利用形同架构模式的应用有React Native，Weeks，Native script，就是利用虚拟DOM的特点实现的。</p><h3 id="2-2-虚拟DOM在线查看"><a href="#2-2-虚拟DOM在线查看" class="headerlink" title="2.2 虚拟DOM在线查看"></a>2.2 虚拟DOM在线查看</h3><p>使用Vue Template Explorer可以查看Vue是如何转换虚拟DOM的。</p><p><a href="https://template-explorer.vuejs.org/">访问地址</a></p><h2 id="3-template和jsx对比"><a href="#3-template和jsx对比" class="headerlink" title="3.template和jsx对比"></a>3.template和jsx对比</h2><p><strong>模版的优势</strong>：模版是一种更静态更具有约束的表现形态，它可以避免发明新语法，任何可以解析HTML的引擎都可以使用它，迁移成本更低；另外最重要的是<strong>静态模版可以在编译进行比较多的优化</strong>，而动态语言就没法实现了。</p><p><strong>jsx的优势</strong>：更灵活，任何的js代码都可以放在jsx中执行实现你想要的效果，但是也<strong>由于他的灵活性导致在编译阶段优化比较困难，只能通过开发者自己优化</strong>。</p><h2 id="4-函数组件"><a href="#4-函数组件" class="headerlink" title="4. 函数组件"></a>4. 函数组件</h2><p>函数组件就是不包含state和props的组件，就像它的名字一样，你可以理解为他就是一个函数，在Vue中声明一个函数组件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line"><span class="attr">functional</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>组件不支持实例化。</li><li>优化更优，因为在Vue中它的渲染函数比父级组件更早被调用，但是他并不会占用很多资源，因为它没有保存数据和属性，所以它常用于优化一个有很多节点的组件。</li><li>容易扩展，如果你的组件只是用来接收 prop然后显示数据，或者一个没有状态的按钮，建议使用函数组件。</li><li>函数组件没有this，获取prop可以通过render函数的第二参数得到<code>render(h, context)</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">functional</span>: <span class="literal">true</span>, <span class="comment">// 声明是函数组件</span></span><br><span class="line">    <span class="comment">// 因为函数组件没有this,可以通过render第二参数获取相关信息</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params">h, &#123; props: &#123; tags &#125; &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// context.slots() 通过slots方法获取子节点</span></span><br><span class="line">        <span class="comment">// context.children 获取子组件</span></span><br><span class="line">        <span class="comment">// context.parent 父组件，因为函数组件实挂载到根节点上，也就是&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">        <span class="comment">// context.props 组件属性，这里得到tags属性</span></span><br><span class="line">        <span class="comment">// return h(&#x27;div&#x27;, this.tags.map((tag, i) =&gt; h(tag, i)))</span></span><br><span class="line">        <span class="comment">// 通过函数组件实现标签动态渲染</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, tags.map(<span class="function">(<span class="params">tag, i</span>) =&gt;</span> h(tag, i)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-HOC-高阶组件"><a href="#5-HOC-高阶组件" class="headerlink" title="5.HOC 高阶组件"></a>5.HOC 高阶组件</h2><blockquote><p>高阶组件是一个函数，接收一个组件，然后返回一个新的组件，类似装饰者模式</p></blockquote><p>这里不展开说了，大概列一下写法，下面模拟了一个图片骨架</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mock API</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchURL</span> (<span class="params">username, cb</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// hard coded, bonus: exercise: make it fetch from gravatar!</span></span><br><span class="line">    cb(<span class="string">&#x27;https://avatars3.githubusercontent.com/u/6128107?v=4&amp;s=200&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Avatar = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;src&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;img :src=&quot;src&quot;&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withAvatarURL</span> (<span class="params">InnerComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">attrs</span>: <span class="built_in">this</span>.$attrs, <span class="comment">// 2.4 only</span></span><br><span class="line">      <span class="attr">username</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://via.placeholder.com/200x200&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      fetchURL(<span class="built_in">this</span>.username, <span class="function">(<span class="params">url</span>) =&gt;</span> &#123; <span class="built_in">this</span>.url = url &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(InnerComponent, &#123; <span class="attr">props</span>: &#123; <span class="attr">src</span>: <span class="built_in">this</span>.url &#125; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SmartAvatar = withAvatarURL(Avatar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; SmartAvatar &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><strong>重用性</strong>：因为minxin对原组件具有侵入性，这会导致原来组件的可重用性降低，而高阶组件不会，高阶组件对原组件只是一个调用关系，并没有修改原来组件任何内容。</li><li><strong>可测试性</strong>：因为高阶组件只是一个嵌套关系，在组件测试的时候，可以单独的测试原始组件和高阶组件。</li><li><strong>层级问题</strong>：高阶组件也有他的弊端，如果你高阶组件嵌套层级太深，会导致出错的时候调试困难的问题，所以到底使用高阶组件和minxin需要看实际场景。</li></ol><h2 id="6-路由"><a href="#6-路由" class="headerlink" title="6. 路由"></a>6. 路由</h2><p>实现根据路由匹配显示组件，并路由匹配参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    <span class="attr">props</span>: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;foo with id: &#123;&#123; id &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span> &#125;</span><br><span class="line"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;not found!&lt;/div&gt;`</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由表</span></span><br><span class="line"><span class="keyword">const</span> routeTable = &#123;</span><br><span class="line">    <span class="string">&#x27;/foo/:id&#x27;</span>: Foo,</span><br><span class="line">    <span class="string">&#x27;/bar&#x27;</span>: Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由表的键通过 path-to-regexp库 进行正则封装</span></span><br><span class="line"><span class="comment">// 下面这个数组储存：组件、正则对象、匹配的name</span></span><br><span class="line"><span class="keyword">const</span> compiledRoutes = []</span><br><span class="line"><span class="built_in">Object</span>.keys(routeTable).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dynamicSegments = []</span><br><span class="line">    <span class="keyword">const</span> regex = pathToRegexp(key, dynamicSegments)</span><br><span class="line">    <span class="keyword">const</span> component = routeTable[key]</span><br><span class="line">    compiledRoutes.push(&#123;</span><br><span class="line">        component,</span><br><span class="line">        regex,</span><br><span class="line">        dynamicSegments</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听hashchange，将改变的路由赋值给url</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">const</span> path = <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> componentToRender <span class="comment">// 要渲染的组件</span></span><br><span class="line">        <span class="keyword">let</span> props = &#123;&#125; <span class="comment">// 路由匹配到的值</span></span><br><span class="line"></span><br><span class="line">        compiledRoutes.some(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> match = route.regex.exec(path) <span class="comment">// 执行匹配</span></span><br><span class="line">            componentToRender = NotFound</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                componentToRender = route.component</span><br><span class="line">                <span class="comment">// 设置参数</span></span><br><span class="line">                route.dynamicSegments.forEach(<span class="function">(<span class="params">segment, index</span>) =&gt;</span> &#123;</span><br><span class="line">                    props[segment.name] = match[index + <span class="number">1</span>]</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">            h(componentToRender, &#123; props &#125;),</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/123&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 123&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/234&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 234&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#bar&#x27;</span> &#125;&#125;, <span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#garbage&#x27;</span> &#125;&#125;, <span class="string">&#x27;garbage&#x27;</span>)</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-响应式&quot;&gt;&lt;a href=&quot;#1-响应式&quot; class=&quot;headerlink&quot; title=&quot;1.响应式&quot;&gt;&lt;/a&gt;1.响应式&lt;/h2&gt;&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;实现一个神奇的函数auto，会在&lt;code&gt;state.count&lt;/code&gt;改变后，自动运行里面的函数&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;autoRun(&lt;span class=&quot;function&quot;&gt;() =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&amp;quot;app&amp;quot;&lt;/span&gt;).innerText = state.count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;state.count++; &lt;span class=&quot;comment&quot;&gt;// 重新执行autoRun内的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://liang5757.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MPA首屏加载速率优化实战</title>
    <link href="https://liang5757.github.io/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"/>
    <id>https://liang5757.github.io/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</id>
    <published>2021-02-14T07:45:27.000Z</published>
    <updated>2024-07-04T16:45:09.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    学校实验室的项目，因为学校只开放给我们一个端口，所以只能把后台管理和学生端合并成多页应用，我是做后台管理的，老师要求某个功能要加上代码高亮，在全局引入highlight.js后发现首屏加载速率不行了，记录一下发现更多问题并优化的过程。</p><a id="more"></a><h2 id="有用的优化"><a href="#有用的优化" class="headerlink" title="有用的优化"></a>有用的优化</h2><h3 id="1-HighLight-js被放在首屏加载了"><a href="#1-HighLight-js被放在首屏加载了" class="headerlink" title="1. HighLight.js被放在首屏加载了"></a>1. HighLight.js被放在首屏加载了</h3><p>首先用<code>webpack-bundle-analyer</code>进行构建分析</p><p><img src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126203158808-1613288799701.png" alt="image-20210126203158808"></p><p>发现了两个巨大的包<code>chunk-vendors.44cd6d2c.js</code>有2.4MB，<code>chunk-94715762.bb0c42f0.js</code>有1.4MB，不幸的是c端需要在首屏同时下载两个大包（此处有误，后面讲解，正确的是左边这个包加入口）才开始渲染，而c端并没有用到<code>highlight.js</code>但是他也得等待下载。</p><p>然后把<code>highlight.js</code>放到封装的组件里引用，然后打包分析</p><p><img src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126204428302.png" alt="image-20210126204428302"></p><p>发现就分离了，<strong>2.4MB的包变成了1.5MB</strong></p><h3 id="2-两个应用使用的element组件没有分离"><a href="#2-两个应用使用的element组件没有分离" class="headerlink" title="2. 两个应用使用的element组件没有分离"></a>2. 两个应用使用的element组件没有分离</h3><p>但是又发现了新的问题——<code>element-ui</code>两个应用使用的组件被打包到了一起，即时c端没有使用到诸如<code>el-upload</code>、<code>el-pagination</code>等组件，但是也要首屏也要下载，想了想<code>highlight.js</code>被放到b端入口文件引入就被打进这个包里。</p><p>是不是<strong>两个入口使用了同一个element按需引入文件的原因</strong>，然后我给<strong>两个应用各开了自己的按需引入文件</strong>。<strong>打包分析没啥变化</strong>。</p><p>问了大哥，大哥甩手就是一个连接<a href="https://www.cnblogs.com/HYZhou2018/p/10419703.html">https://www.cnblogs.com/HYZhou2018/p/10419703.html</a></p><p>大概就是<code>vue-cli3</code>的脚手架配置自动分包的时候是针对单页应用的，下面是<code>vue-cli3</code>的配置项</p><p><img src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126205853873.png" alt="image-20210126205853873"></p><p><code>splitChunks</code>默认<code>minChunks</code>是1，但是我们是多页应用啊，所以两个应用使用的第三方库全被抽离到一个<code>chunk-vendor.js</code>了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config.optimization.splitChunks(&#123;</span><br><span class="line">    <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">vendors</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;chunk-vendors&#x27;</span>,</span><br><span class="line">            <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 设置为2，两个应用同时使用才抽离</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            priority: -<span class="number">10</span>,</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;initial&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">common</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次打包分析</p><p><img src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126210625547.png" alt="image-20210126210625547"></p><p>不仅分离了一些组件，还把一些使用到的第三方库给分离了，这个2.4MB的打包到此为止就变成了<strong>1.2MB</strong>的包。</p><h2 id="2021-9-2-更新"><a href="#2021-9-2-更新" class="headerlink" title="2021/9/2 更新"></a>2021/9/2 更新</h2><p>在上图可以看到，一些node_modules里的第三方库被打包到业务代码中了，这就导致了我们就算只是更新业务代码，但是用户也需要重新下载当前组件引用到的第三方库，我们可以设置更细粒度的分包，在cacheGroups中添加如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">teacher: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;chunk-teacher&quot;</span>,</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  minChunks: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">chunks</span>(<span class="params">chunk</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk.name === <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">priority</span>: -<span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">student</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;chunk-student&quot;</span>,</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  minChunks: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">chunks</span>(<span class="params">chunk</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk.name === <span class="string">&quot;student&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">priority</span>: -<span class="number">1</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210902014110713.png" alt="image-20210902014110713"></p><p>可以看到红框圈起来的就是新分出来的包，里面只有被引次数为1的第三方库，保证了业务和依赖的抽离</p><h2 id="走过的坑"><a href="#走过的坑" class="headerlink" title="走过的坑"></a>走过的坑</h2><h3 id="1-怎么coding包还是在首屏下载了"><a href="#1-怎么coding包还是在首屏下载了" class="headerlink" title="1.怎么coding包还是在首屏下载了"></a>1.怎么coding包还是在首屏下载了</h3><p>已经使用了路由懒加载，为什么coding包还是在首屏下载了，我曾一度以为是没有<a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/"><code>syntax-dynamic-import</code></a>这个插件的原因，还装过了试了下，但是并没有什么用，而且webpack已经使用动态import来做到懒加载了。</p><p>查阅<a href="https://blog.csdn.net/sinat_35538827/article/details/87969834">文章</a>发现</p><p>原来 vue-cli3 默认会把所有通过<code>import()</code>按需加载的javascript文件加上 prefetch 。</p><p><strong>prefetch是什么？</strong>在打包后的文件中，查看index.html我们会发现类似这个 <link href="/js/chunk-118075e7.5725ab1a.js" rel="prefetch">。<link rel="prefetch">会在页面加载完成后，利用空闲时间提前加载获取用户未来可能会访问的内容。</p><p><strong>prefetch链接会消耗宽带，如果是在移动端，而且存在大量的chunk，那么可以关掉 prefetch 链接，手动选择要提前获取的代码区块。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动选定要提前获取的代码</span></span><br><span class="line"><span class="keyword">import</span>(webpackPrefetch: <span class="literal">true</span>, <span class="string">&#x27;./someAsyncComponent.vue&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>关闭prefetch:</strong> (官网示例)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 移除 prefetch 插件</span></span><br><span class="line">    config.plugins.delete(<span class="string">&#x27;prefetch&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// 修改它的选项：</span></span><br><span class="line">    config.plugin(<span class="string">&#x27;prefetch&#x27;</span>).tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">      options[<span class="number">0</span>].fileBlacklist = options[<span class="number">0</span>].fileBlacklist || []</span><br><span class="line">      options[<span class="number">0</span>].fileBlacklist.push(<span class="regexp">/myasyncRoute(.)+?\.js$/</span>)</span><br><span class="line">      <span class="keyword">return</span> options</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-第三方库怎么这么多重复的bn-js"><a href="#2-第三方库怎么这么多重复的bn-js" class="headerlink" title="2. 第三方库怎么这么多重复的bn.js"></a>2. 第三方库怎么这么多重复的bn.js</h3><p><img src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126212734717.png" alt="image-20210126212734717"></p><p>可以看到有8个重复的<code>bn.js</code>，一个40KB，gzip后10KB，离谱。</p><p>但是大小是不一样的，可能<strong>用的版本不同</strong>，目前没有好的方法抽离。。</p><p>其实可以用cdn来搞，但是第三方的cdn不稳定，就没搞。</p><h3 id="3-打包后mini-css-extract-plugin警告Conflicting-order"><a href="#3-打包后mini-css-extract-plugin警告Conflicting-order" class="headerlink" title="3. 打包后mini-css-extract-plugin警告Conflicting order"></a>3. 打包后mini-css-extract-plugin警告Conflicting order</h3><p>对应的issus：<a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250">https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250</a></p><p>是由于组件使用顺序不一致导致的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    学校实验室的项目，因为学校只开放给我们一个端口，所以只能把后台管理和学生端合并成多页应用，我是做后台管理的，老师要求某个功能要加上代码高亮，在全局引入highlight.js后发现首屏加载速率不行了，记录一下发现更多问题并优化的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
</feed>
